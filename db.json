{"meta":{"version":1,"warehouse":"5.0.1"},"models":{"Asset":[{"_id":"node_modules/hexo-theme-landscape/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/fancybox/jquery.fancybox.min.css","path":"fancybox/jquery.fancybox.min.css","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/fancybox/jquery.fancybox.min.js","path":"fancybox/jquery.fancybox.min.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/js/jquery-3.6.4.min.js","path":"js/jquery-3.6.4.min.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/js/script.js","path":"js/script.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/css/cyberpunk.styl","path":"css/cyberpunk.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/css/default.styl","path":"css/default.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/img/avatar.png","path":"img/avatar.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/img/favicon.svg","path":"img/favicon.svg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/img/logo.svg","path":"img/logo.svg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/img/og_image.png","path":"img/og_image.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/img/razor-bottom-black.svg","path":"img/razor-bottom-black.svg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/img/razor-top-black.svg","path":"img/razor-top-black.svg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/js/animation.js","path":"js/animation.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/js/back_to_top.js","path":"js/back_to_top.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/js/column.js","path":"js/column.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"source/images/spec依赖检查机制/image-20230701170955227.png","path":"images/spec依赖检查机制/image-20230701170955227.png","modified":0,"renderable":0},{"_id":"source/images/spec依赖检查机制/image-20230701171040194.png","path":"images/spec依赖检查机制/image-20230701171040194.png","modified":0,"renderable":0},{"_id":"source/images/spec依赖检查机制/image-20230701173341798.png","path":"images/spec依赖检查机制/image-20230701173341798.png","modified":0,"renderable":0},{"_id":"source/images/spec依赖检查机制/image-20230701173925324.png","path":"images/spec依赖检查机制/image-20230701173925324.png","modified":0,"renderable":0},{"_id":"source/images/spec依赖检查机制/image-20230701174018570.png","path":"images/spec依赖检查机制/image-20230701174018570.png","modified":0,"renderable":0},{"_id":"source/images/spec依赖检查机制/image-20230701175121884.png","path":"images/spec依赖检查机制/image-20230701175121884.png","modified":0,"renderable":0},{"_id":"source/images/编程语言兼容性/image-20230611113916798.png","path":"images/编程语言兼容性/image-20230611113916798.png","modified":0,"renderable":0},{"_id":"source/images/编程语言兼容性/image-20230611121349952.png","path":"images/编程语言兼容性/image-20230611121349952.png","modified":0,"renderable":0},{"_id":"source/images/编程语言源/image-20230929220230437.png","path":"images/编程语言源/image-20230929220230437.png","modified":0,"renderable":0},{"_id":"source/images/编程语言源/image-20230929231952522.png","path":"images/编程语言源/image-20230929231952522.png","modified":0,"renderable":0},{"_id":"source/images/编程语言源/image-20230930004122812.png","path":"images/编程语言源/image-20230930004122812.png","modified":0,"renderable":0},{"_id":"source/images/链接/image-20240611002011827.png","path":"images/链接/image-20240611002011827.png","modified":0,"renderable":0},{"_id":"source/images/链接/image-20240610184504549.png","path":"images/链接/image-20240610184504549.png","modified":0,"renderable":0},{"_id":"source/images/链接/image-20240610231929156.png","path":"images/链接/image-20240610231929156.png","modified":0,"renderable":0},{"_id":"source/images/链接/image-20240611001854930.png","path":"images/链接/image-20240611001854930.png","modified":0,"renderable":0},{"_id":"source/images/链接/image-20240611001920437.png","path":"images/链接/image-20240611001920437.png","modified":0,"renderable":0}],"Cache":[{"_id":"source/_posts/hello-world.md","hash":"79fba985b900320efc9abe47f3e808a23657a655","modified":1714638629218},{"_id":"node_modules/hexo-theme-landscape/LICENSE","hash":"c480fce396b23997ee23cc535518ffaaf7f458f8","modified":1714630997564},{"_id":"node_modules/hexo-theme-landscape/README.md","hash":"1a9b279e6dd29fd19245f913f0c4a316ffaa62db","modified":1714630998052},{"_id":"node_modules/hexo-theme-landscape/_config.yml","hash":"b608c1f1322760dce9805285a602a95832730a2e","modified":1714630998108},{"_id":"node_modules/hexo-theme-landscape/package.json","hash":"4bf95d52f77edf811f23f6d264a7493311a8d078","modified":1714630998048},{"_id":"node_modules/hexo-theme-landscape/languages/de-DE.yml","hash":"d29d1c4256b7ed9df42f511c2ff0a23ad5fd6c1f","modified":1714630998108},{"_id":"node_modules/hexo-theme-landscape/languages/de.yml","hash":"3ebf0775abbee928c8d7bda943c191d166ded0d3","modified":1714630998112},{"_id":"node_modules/hexo-theme-landscape/languages/default.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1714630998112},{"_id":"node_modules/hexo-theme-landscape/languages/en-GB.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1714630998116},{"_id":"node_modules/hexo-theme-landscape/languages/en-US.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1714630998116},{"_id":"node_modules/hexo-theme-landscape/languages/en.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1714630998116},{"_id":"node_modules/hexo-theme-landscape/languages/es-ES.yml","hash":"7008a8fc91f18d2a735864817b8ebda30c7a2c66","modified":1714630998116},{"_id":"node_modules/hexo-theme-landscape/languages/es.yml","hash":"76edb1171b86532ef12cfd15f5f2c1ac3949f061","modified":1714630998120},{"_id":"node_modules/hexo-theme-landscape/languages/fr-FR.yml","hash":"8d09dbdab00a30a2870b56f7c0a7ca7deafa7b88","modified":1714630998120},{"_id":"node_modules/hexo-theme-landscape/languages/fr.yml","hash":"415e1c580ced8e4ce20b3b0aeedc3610341c76fb","modified":1714630998120},{"_id":"node_modules/hexo-theme-landscape/languages/hu-HU.yml","hash":"712d18664898fa21ba38d4973e90ef41a324ea25","modified":1714630998124},{"_id":"node_modules/hexo-theme-landscape/languages/hu.yml","hash":"284d557130bf54a74e7dcef9d42096130e4d9550","modified":1714630998124},{"_id":"node_modules/hexo-theme-landscape/languages/it-IT.yml","hash":"2cb6dc2fab9bd2dbe1c8bb869a9e8bf85a564fdd","modified":1714630998124},{"_id":"node_modules/hexo-theme-landscape/languages/it.yml","hash":"89b7d91306b2c1a0f3ac023b657bf974f798a1e8","modified":1714630998128},{"_id":"node_modules/hexo-theme-landscape/languages/ja-JP.yml","hash":"08481267e0c112e1f6855620f2837ec4c4a98bbd","modified":1714630998128},{"_id":"node_modules/hexo-theme-landscape/languages/ja.yml","hash":"a73e1b9c80fd6e930e2628b393bfe3fb716a21a9","modified":1714630998128},{"_id":"node_modules/hexo-theme-landscape/languages/ko-KR.yml","hash":"19209ad8f9d4057e8df808937f950eb265e1db69","modified":1714630998132},{"_id":"node_modules/hexo-theme-landscape/languages/ko.yml","hash":"881d6a0a101706e0452af81c580218e0bfddd9cf","modified":1714630998132},{"_id":"node_modules/hexo-theme-landscape/languages/mn-MN.yml","hash":"b9e5f3e7c0c2f779cf2cfded6db847b5941637ca","modified":1714630998132},{"_id":"node_modules/hexo-theme-landscape/languages/mn.yml","hash":"2e7523951072a9403ead3840ad823edd1084c116","modified":1714630998136},{"_id":"node_modules/hexo-theme-landscape/languages/nl-NL.yml","hash":"5ebbc30021f05d99938f96dfff280392df7f91f0","modified":1714630998136},{"_id":"node_modules/hexo-theme-landscape/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1714630998136},{"_id":"node_modules/hexo-theme-landscape/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1714630998140},{"_id":"node_modules/hexo-theme-landscape/languages/pt-PT.yml","hash":"0f852b6b228e6ea59aa3540574bb89b233f2a098","modified":1714630998140},{"_id":"node_modules/hexo-theme-landscape/languages/pt.yml","hash":"57d07b75d434fbfc33b0ddb543021cb5f53318a8","modified":1714630998140},{"_id":"node_modules/hexo-theme-landscape/languages/ru-RU.yml","hash":"360d11a28bb768afb1dd15f63fa7fd3a8cc547ee","modified":1714630998140},{"_id":"node_modules/hexo-theme-landscape/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1714630998144},{"_id":"node_modules/hexo-theme-landscape/languages/th-TH.yml","hash":"ebfdba9bc4842c829473c1e6e4544344f182724d","modified":1714630998144},{"_id":"node_modules/hexo-theme-landscape/languages/th.yml","hash":"84a55b00aa01f03982be294e43c33a20e6d32862","modified":1714630998144},{"_id":"node_modules/hexo-theme-landscape/languages/tr.yml","hash":"a1cdbfa17682d7a971de8ab8588bf57c74224b5b","modified":1714630998144},{"_id":"node_modules/hexo-theme-landscape/languages/zh-CN.yml","hash":"1efd95774f401c80193eac6ee3f1794bfe93dc5a","modified":1714630998148},{"_id":"node_modules/hexo-theme-landscape/languages/zh-TW.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1714630998148},{"_id":"node_modules/hexo-theme-landscape/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1714630997848},{"_id":"node_modules/hexo-theme-landscape/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1714630997876},{"_id":"node_modules/hexo-theme-landscape/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1714630997908},{"_id":"node_modules/hexo-theme-landscape/layout/layout.ejs","hash":"0d1765036e4874500e68256fedb7470e96eeb6ee","modified":1714630997912},{"_id":"node_modules/hexo-theme-landscape/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1714630997920},{"_id":"node_modules/hexo-theme-landscape/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1714630997924},{"_id":"node_modules/hexo-theme-landscape/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1714630997944},{"_id":"node_modules/hexo-theme-landscape/scripts/fancybox.js","hash":"c857d7a5e4a5d71c743a009c5932bf84229db428","modified":1714630998008},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/after-footer.ejs","hash":"377d257d5d16e0158a4405c72401517b074fd7ff","modified":1714630997740},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/archive-post.ejs","hash":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":1714630997776},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/archive.ejs","hash":"7cb70a7a54f8c7ae49b10d1f37c0a9b74eab8826","modified":1714630997788},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/article.ejs","hash":"56597e951203dd662a6d2c817c7c4f1c920d4a25","modified":1714630997852},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/footer.ejs","hash":"3656eb692254346671abc03cb3ba1459829e0dce","modified":1714630997888},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/gauges-analytics.ejs","hash":"21a1e2a3907d1a3dad1cd0ab855fe6735f233c74","modified":1714630997896},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/google-analytics.ejs","hash":"2ea7442ea1e1a8ab4e41e26c563f58413b59a3d0","modified":1714630997900},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/head.ejs","hash":"f05bced793b0314d4f2ef0c993b3a51d0b7d203a","modified":1714630997900},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/header.ejs","hash":"6a5033d189554c9a6d42e2ef7952ae5c9742648e","modified":1714630997904},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/mobile-nav.ejs","hash":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":1714630997912},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/sidebar.ejs","hash":"930da35cc2d447a92e5ee8f835735e6fd2232469","modified":1714630997936},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/archive.ejs","hash":"beb4a86fcc82a9bdda9289b59db5a1988918bec3","modified":1714630997824},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/category.ejs","hash":"dd1e5af3c6af3f5d6c85dfd5ca1766faed6a0b05","modified":1714630997872},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/recent_posts.ejs","hash":"60c4b012dcc656438ff59997e60367e5a21ab746","modified":1714630997924},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/tag.ejs","hash":"2de380865df9ab5f577f7d3bcadf44261eb5faae","modified":1714630997940},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/tagcloud.ejs","hash":"b4a2079101643f63993dcdb32925c9b071763b46","modified":1714630997948},{"_id":"node_modules/hexo-theme-landscape/source/css/_extend.styl","hash":"222fbe6d222531d61c1ef0f868c90f747b1c2ced","modified":1714630998060},{"_id":"node_modules/hexo-theme-landscape/source/css/_variables.styl","hash":"ca28281423ae57d76b6c1eb91cd845fd4e518bd6","modified":1714630998060},{"_id":"node_modules/hexo-theme-landscape/source/css/style.styl","hash":"e55a1d92954ed20f6887f92dc727bb995a010a43","modified":1714630998104},{"_id":"node_modules/hexo-theme-landscape/source/fancybox/jquery.fancybox.min.css","hash":"1be9b79be02a1cfc5d96c4a5e0feb8f472babd95","modified":1714630997656},{"_id":"node_modules/hexo-theme-landscape/source/js/script.js","hash":"49773efcb2221bbdf2d86f3f5c5ff2d841b528cc","modified":1714630998044},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/category.ejs","hash":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":1714630997868},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/date.ejs","hash":"f1458584b679545830b75bef2526e2f3eb931045","modified":1714630997884},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1714630997892},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/nav.ejs","hash":"16a904de7bceccbb36b4267565f2215704db2880","modified":1714630997916},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1714630997940},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/title.ejs","hash":"4d7e62574ddf46de9b41605fe3140d77b5ddb26d","modified":1714630997952},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/archive.styl","hash":"db15f5677dc68f1730e82190bab69c24611ca292","modified":1714630998068},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/article.styl","hash":"2d1f6f79ebf9cb55ebdb3865a2474437eb2b37c6","modified":1714630998072},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/comment.styl","hash":"79d280d8d203abb3bd933ca9b8e38c78ec684987","modified":1714630998076},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/footer.styl","hash":"e35a060b8512031048919709a8e7b1ec0e40bc1b","modified":1714630998076},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/header.styl","hash":"268d2989acb06e2ddd06cc36a6918c6cd865476b","modified":1714630998088},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/highlight.styl","hash":"9cc3b2927d814f2f6e8e188f9d3657b94f4c6ef3","modified":1714630998088},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/mobile.styl","hash":"a399cf9e1e1cec3e4269066e2948d7ae5854d745","modified":1714630998092},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/sidebar-aside.styl","hash":"890349df5145abf46ce7712010c89237900b3713","modified":1714630998092},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/sidebar-bottom.styl","hash":"8fd4f30d319542babfd31f087ddbac550f000a8a","modified":1714630998096},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/sidebar.styl","hash":"404ec059dc674a48b9ab89cd83f258dec4dcb24d","modified":1714630998100},{"_id":"node_modules/hexo-theme-landscape/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1714630998084},{"_id":"node_modules/hexo-theme-landscape/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1714630998092},{"_id":"node_modules/hexo-theme-landscape/source/fancybox/jquery.fancybox.min.js","hash":"6181412e73966696d08e1e5b1243a572d0f22ba6","modified":1714630998040},{"_id":"node_modules/hexo-theme-landscape/source/js/jquery-3.6.4.min.js","hash":"eda46747c71d38a880bee44f9a439c3858bb8f99","modified":1714630998028},{"_id":"node_modules/hexo-theme-landscape/source/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1714630998004},{"_id":"node_modules/hexo-theme-icarus/layout/comment/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1714631547864},{"_id":"node_modules/hexo-theme-icarus/layout/donate/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1714631547868},{"_id":"node_modules/hexo-theme-icarus/layout/misc/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1714631547872},{"_id":"node_modules/hexo-theme-icarus/layout/search/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1714631547880},{"_id":"node_modules/hexo-theme-icarus/layout/share/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1714631547884},{"_id":"node_modules/hexo-theme-icarus/include/schema/comment/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1714631547840},{"_id":"node_modules/hexo-theme-icarus/include/schema/donate/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1714631547844},{"_id":"node_modules/hexo-theme-icarus/include/schema/misc/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1714631547852},{"_id":"node_modules/hexo-theme-icarus/include/schema/search/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1714631547856},{"_id":"node_modules/hexo-theme-icarus/include/schema/share/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1714631547864},{"_id":"node_modules/hexo-theme-icarus/CONTRIBUTING.md","hash":"70254c6778c1e41bb2ff222bbf3a70b2239b9bc1","modified":1714631547944},{"_id":"node_modules/hexo-theme-icarus/LICENSE","hash":"86037e5335a49321fa73b7815cab542057fac944","modified":1714631547884},{"_id":"node_modules/hexo-theme-icarus/README.md","hash":"32f9f4fc8cd7ec60b30544bd2e558b593519ae5d","modified":1714631547948},{"_id":"node_modules/hexo-theme-icarus/package.json","hash":"cac87bcce0297386f25865a52a23023ff32334ef","modified":1715525638687},{"_id":"node_modules/hexo-theme-icarus/include/config.js","hash":"4b8a3096137e0d879fb17972a69630bde38d8212","modified":1714631547888},{"_id":"node_modules/hexo-theme-icarus/include/dependency.js","hash":"e02471f80db87db43aa7d527176e195b60dc4b99","modified":1714631547892},{"_id":"node_modules/hexo-theme-icarus/include/register.js","hash":"040fed1d0d7e4d8003446d1541bc15a2c4b4e500","modified":1714631547900},{"_id":"node_modules/hexo-theme-icarus/languages/de.yml","hash":"78421f09961ca0b24756a0688fb2cb2e2696e25f","modified":1714631548064},{"_id":"node_modules/hexo-theme-icarus/languages/en.yml","hash":"3d674204d9f723c829226da745afddd180c1131d","modified":1714631548064},{"_id":"node_modules/hexo-theme-icarus/languages/es.yml","hash":"38579b8fad4b6997362acc770615bcd85ff20f68","modified":1714631548068},{"_id":"node_modules/hexo-theme-icarus/languages/fr.yml","hash":"b992b68705f5050a99de926525b3cb40d95c4769","modified":1714631548068},{"_id":"node_modules/hexo-theme-icarus/languages/id.yml","hash":"5e48b1d62378cadeb64b88349477726a5c1bae47","modified":1714631548068},{"_id":"node_modules/hexo-theme-icarus/languages/it.yml","hash":"b76999994cda6b08b53d34c3dd67947f164de655","modified":1714631548068},{"_id":"node_modules/hexo-theme-icarus/languages/ja.yml","hash":"801d9930fef48d6a3f80470d5bed4f3eb78147e6","modified":1714631548068},{"_id":"node_modules/hexo-theme-icarus/languages/ko.yml","hash":"e3374265377809c1518114cf352b595840c0b416","modified":1714631548072},{"_id":"node_modules/hexo-theme-icarus/languages/pl.yml","hash":"2e7debb44cd91096f30efc87bf8d6b1d0d0214c9","modified":1714631548072},{"_id":"node_modules/hexo-theme-icarus/languages/pt-BR.yml","hash":"ee8f73350e4c6e2f63b7fc72b34472a6b1e21244","modified":1714631548072},{"_id":"node_modules/hexo-theme-icarus/languages/ru.yml","hash":"9d91358c2acbe7a0f2a25daf7f65b999ff32d068","modified":1714631548072},{"_id":"node_modules/hexo-theme-icarus/languages/sv.yml","hash":"b12eee168c52aac855ffce9f78fe5fd5d6e3970c","modified":1714631548072},{"_id":"node_modules/hexo-theme-icarus/languages/tk.yml","hash":"ca583168bd2025124a1cd0e977da475d7a7496fd","modified":1714631548072},{"_id":"node_modules/hexo-theme-icarus/languages/tr.yml","hash":"dd0a7bfe14848d6e1aa229198fe1db03e08e305e","modified":1714631548076},{"_id":"node_modules/hexo-theme-icarus/languages/vn.yml","hash":"5f2fffa642110c81d8f529949711c9d19ad6bbbe","modified":1714631548076},{"_id":"node_modules/hexo-theme-icarus/languages/zh-CN.yml","hash":"02475ba14afc70dfeaf5678467cee307835e4efa","modified":1714631548076},{"_id":"node_modules/hexo-theme-icarus/languages/zh-TW.yml","hash":"a6826e0c8cdb9ad286324b682b466a9e2ad78e6f","modified":1714631548076},{"_id":"node_modules/hexo-theme-icarus/layout/archive.jsx","hash":"daf8eca64197709a9dc4a4792c403a32d78bdfae","modified":1714631547924},{"_id":"node_modules/hexo-theme-icarus/layout/categories.jsx","hash":"b8ad43e28a4990d222bfbb95b032f88555492347","modified":1714631547932},{"_id":"node_modules/hexo-theme-icarus/layout/category.jsx","hash":"fd15e4eac32de9ac8687aeb3dbe179ab61375700","modified":1714631547932},{"_id":"node_modules/hexo-theme-icarus/layout/index.jsx","hash":"0a84a2348394fa9fc5080dd396bd28d357594f47","modified":1714631547940},{"_id":"node_modules/hexo-theme-icarus/layout/layout.jsx","hash":"ac7c4e3465a116c7f05f8c2e09ee6d6b9467abf1","modified":1714631547940},{"_id":"node_modules/hexo-theme-icarus/layout/page.jsx","hash":"d26c2db57e5a88d6483a03aeb51cda9d191d8cea","modified":1714631547940},{"_id":"node_modules/hexo-theme-icarus/layout/post.jsx","hash":"d26c2db57e5a88d6483a03aeb51cda9d191d8cea","modified":1714631547940},{"_id":"node_modules/hexo-theme-icarus/layout/tag.jsx","hash":"d2f18cac32ca2725d34ccff3f2051c623be6c892","modified":1714631547944},{"_id":"node_modules/hexo-theme-icarus/layout/tags.jsx","hash":"2c42cb64778235dd220c563a27a92108ddc50cc4","modified":1714631547944},{"_id":"node_modules/hexo-theme-icarus/scripts/index.js","hash":"93a79969c7eb47cfac097893cda36368db56902c","modified":1714631547896},{"_id":"node_modules/hexo-theme-icarus/include/migration/head.js","hash":"7189efe33d18927d3790e8afb06642fb293b8603","modified":1714631547892},{"_id":"node_modules/hexo-theme-icarus/include/migration/v2_v3.js","hash":"a46da71c20fa9d73c1bac26fda77717abae1b308","modified":1714631547900},{"_id":"node_modules/hexo-theme-icarus/include/migration/v3_v4.js","hash":"9faf2184d7fe87debfbe007f3fc9079dcbcafcfe","modified":1714631547900},{"_id":"node_modules/hexo-theme-icarus/include/migration/v4_v5.js","hash":"6342310892d113763b5544789b45d44c0ccf2854","modified":1714631547900},{"_id":"node_modules/hexo-theme-icarus/include/migration/v5_v5.1.js","hash":"073f22bd16e34b56f016633b1676dab2e7d8843d","modified":1714631547900},{"_id":"node_modules/hexo-theme-icarus/include/schema/config.json","hash":"f233678cd656c0e300181ca79dd30cb42fc213b3","modified":1714631547912},{"_id":"node_modules/hexo-theme-icarus/include/style/article.styl","hash":"105c983871b6c9148d97a0f756886e56411572bd","modified":1714631548028},{"_id":"node_modules/hexo-theme-icarus/include/style/base.styl","hash":"2bca6ad099949d52236c87db8db1002ffb99774c","modified":1714631548028},{"_id":"node_modules/hexo-theme-icarus/include/style/button.styl","hash":"0fb35b4786be1b387c751fa2849bc71523fcedd4","modified":1714631548032},{"_id":"node_modules/hexo-theme-icarus/include/style/card.styl","hash":"f78674422eb408cd17c17bbdc3ee1ebe4a453e05","modified":1714631548032},{"_id":"node_modules/hexo-theme-icarus/include/style/codeblock.styl","hash":"ec54dc24eb4d9802d8fefc44c210558bc1641109","modified":1714631548032},{"_id":"node_modules/hexo-theme-icarus/include/style/donate.styl","hash":"8d0af00628c13134b5f30a558608e7bebf18c2ec","modified":1714631548044},{"_id":"node_modules/hexo-theme-icarus/include/style/footer.styl","hash":"a4ad715dee38b249538ac6cce94efc9b355a904b","modified":1714631548044},{"_id":"node_modules/hexo-theme-icarus/include/style/helper.styl","hash":"9f3393e6122cc9f351091bfab960674e962da343","modified":1714631548048},{"_id":"node_modules/hexo-theme-icarus/include/style/navbar.styl","hash":"34f09b144cb46a25ec2cc7260a6c207dd34ff1fe","modified":1714631548048},{"_id":"node_modules/hexo-theme-icarus/include/style/pagination.styl","hash":"b81bcd7ff915b4e9299533addc01bc4575ec35e3","modified":1714631548052},{"_id":"node_modules/hexo-theme-icarus/include/style/plugin.styl","hash":"084843d5a522029e0f84a4fe791fbcb2cabd4c36","modified":1714631548052},{"_id":"node_modules/hexo-theme-icarus/include/style/responsive.styl","hash":"207083fe287612cddee6608b541861b14ac8de81","modified":1714631548052},{"_id":"node_modules/hexo-theme-icarus/include/style/search.styl","hash":"416737e1da4e7e907bd03609b0fee9e2aacfe56c","modified":1714631548056},{"_id":"node_modules/hexo-theme-icarus/include/style/timeline.styl","hash":"ea61798a09bffdda07efb93c2ff800b63bddc4c4","modified":1714631548060},{"_id":"node_modules/hexo-theme-icarus/include/style/widget.styl","hash":"c746902251136544eb3fe523235b3183f4189460","modified":1714631548060},{"_id":"node_modules/hexo-theme-icarus/include/util/console.js","hash":"59cf9d277d3ac85a496689bd811b1c316001641d","modified":1714631547892},{"_id":"node_modules/hexo-theme-icarus/layout/common/article.jsx","hash":"c4fc3c016de42c50614f70538a23359eee905ed3","modified":1714631547928},{"_id":"node_modules/hexo-theme-icarus/layout/common/comment.jsx","hash":"0610cadb3976954c6f299d30320a93a1bd2a151c","modified":1714631547932},{"_id":"node_modules/hexo-theme-icarus/layout/common/donates.jsx","hash":"fd52330d582fd122db7f55444c2f3368ff4bd8d7","modified":1714631547936},{"_id":"node_modules/hexo-theme-icarus/layout/common/footer.jsx","hash":"de966666f1e4ef80e0d15081b2709c3065b246dd","modified":1714631547936},{"_id":"node_modules/hexo-theme-icarus/layout/common/head.jsx","hash":"ff049c2837a111da775d1661b605dd417614b84c","modified":1714631547936},{"_id":"node_modules/hexo-theme-icarus/layout/common/navbar.jsx","hash":"d96e501e52861056474659f96ee0206588d8c93a","modified":1714631547940},{"_id":"node_modules/hexo-theme-icarus/layout/common/plugins.jsx","hash":"2e27800b2a8a87112c96778db858c3419d890b79","modified":1714631547940},{"_id":"node_modules/hexo-theme-icarus/layout/common/scripts.jsx","hash":"eaec7c7b936197247e5acd73a79ca951da4d82ec","modified":1714631547944},{"_id":"node_modules/hexo-theme-icarus/layout/common/search.jsx","hash":"1409627d98a92b4f5b2ab829f8e6b50b75d60e53","modified":1714631547944},{"_id":"node_modules/hexo-theme-icarus/layout/common/share.jsx","hash":"0fad6f8a91bb5cf678b9ff2d66d2162d61625074","modified":1714631547944},{"_id":"node_modules/hexo-theme-icarus/layout/common/widgets.jsx","hash":"7a89ac72a988d13b4714ab78a6dfd5cd8de85d47","modified":1714631547944},{"_id":"node_modules/hexo-theme-icarus/layout/plugin/animejs.jsx","hash":"e2aa27c3501a58ef1e91e511557b77395c2c02aa","modified":1714631547920},{"_id":"node_modules/hexo-theme-icarus/layout/plugin/back_to_top.jsx","hash":"7fc0c5aaabd7d0eaff04cb68ec139442dc3414e8","modified":1714631547932},{"_id":"node_modules/hexo-theme-icarus/layout/widget/profile.jsx","hash":"0d3a7fd922c12cc45d2c8d26a8f4d3a9a6ed0ae0","modified":1714631547940},{"_id":"node_modules/hexo-theme-icarus/source/css/cyberpunk.styl","hash":"ae17d3528df0c3f089df14a06b7bd82f1bc5fed9","modified":1714631548040},{"_id":"node_modules/hexo-theme-icarus/source/css/default.styl","hash":"b01da3028e5a1267a40aaae5c86a11187a2259e3","modified":1714631548044},{"_id":"node_modules/hexo-theme-icarus/source/css/style.styl","hash":"5b9815586e993a6ccbe8cdcfc0c65ea38fc315ac","modified":1714631548060},{"_id":"node_modules/hexo-theme-icarus/source/img/avatar.png","hash":"0d8236dcca871735500e9d06bbdbe0853ed6775b","modified":1714631548020},{"_id":"node_modules/hexo-theme-icarus/source/img/favicon.svg","hash":"16fd847265845063a16596761cddb32926073dd2","modified":1714631548060},{"_id":"node_modules/hexo-theme-icarus/source/img/logo.svg","hash":"e9b5c1438ddb576693a15d0713b2a1d9ceda4be9","modified":1714631548060},{"_id":"node_modules/hexo-theme-icarus/source/img/og_image.png","hash":"b03f163096ca9c350ec962feee9836277b5c2509","modified":1714631548028},{"_id":"node_modules/hexo-theme-icarus/source/img/razor-bottom-black.svg","hash":"a3eda07b1c605b456da9cdf335a1075db5e5d72c","modified":1714631548064},{"_id":"node_modules/hexo-theme-icarus/source/img/razor-top-black.svg","hash":"201f1171a43ce667a39091fe47c0f278857f18f0","modified":1714631548064},{"_id":"node_modules/hexo-theme-icarus/source/js/animation.js","hash":"0a8e361c353daa3194f4de3d646b96025d128e1a","modified":1714631547888},{"_id":"node_modules/hexo-theme-icarus/source/js/back_to_top.js","hash":"d91f10c08c726135a13dfa1f422c49d8764ef03f","modified":1714631547888},{"_id":"node_modules/hexo-theme-icarus/source/js/column.js","hash":"0baee024ab67474c073a4c41b495f3e7f0df4505","modified":1714631547888},{"_id":"node_modules/hexo-theme-icarus/source/js/main.js","hash":"37f3b16fbd9668b9496d5f2d9bd9fb22fc6cee27","modified":1714631547896},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/article.json","hash":"e2502c39045c6a26ccd8e880858f93e78c7bda35","modified":1714631547908},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/comment.json","hash":"f49270b619f5d2c3decde6b0b5a0c3bbab4b54a5","modified":1714631547908},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/donates.json","hash":"ae86e6f177bedf4afbe638502c12635027539305","modified":1714631547912},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/footer.json","hash":"e85c9d7f2579805beb252a1b6345d5a668a13baa","modified":1714631547912},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/head.json","hash":"98889f059c635e6bdbd51effd04cf1cf44968a66","modified":1714631547912},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/navbar.json","hash":"6691e587284c4cf450e0288680d5ff0f3565f090","modified":1714631547916},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/plugins.json","hash":"6036a805749816416850d944f7d64aaae62e5e75","modified":1714631547916},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/providers.json","hash":"97ec953d497fb53594227ae98acaef8a8baa91da","modified":1714631547916},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/search.json","hash":"985fbcbf47054af714ead1a124869d54f2a8b607","modified":1714631547916},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/share.json","hash":"cf4f9ff4fb27c3541b35f57db355c228fa6873e4","modified":1714631547916},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/sidebar.json","hash":"eb241beaec4c73e3085dfb3139ce72e827e20549","modified":1714631547920},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/widgets.json","hash":"cadd9dc942740ecd5037d3943e72f8b6a8399bbe","modified":1714631547920},{"_id":"node_modules/hexo-theme-icarus/include/schema/plugin/animejs.json","hash":"e62ab6e20bd8862efa1ed32e7c0db0f8acbcfdec","modified":1714631547904},{"_id":"node_modules/hexo-theme-icarus/include/schema/plugin/back_to_top.json","hash":"dc0febab7e7b67075d0ad3f80f5ec8b798b68dea","modified":1714631547908},{"_id":"node_modules/hexo-theme-icarus/include/schema/widget/profile.json","hash":"690ee1b0791cab47ea03cf42b5b4932ed2aa5675","modified":1714631547916},{"_id":"source/_drafts/草稿.md","hash":"d127342774c0a82b5c77ee14d359047a0405e974","modified":1714632430012},{"_id":"source/页面/index.md","hash":"1e5708189d23040ea5b0986bd7959c70851a2b6f","modified":1714632459373},{"_id":"source/_posts/rpm.spec/image-20230701171040194.png","hash":"05c7468abc53237f3086cec43581b2c83665722a","modified":1714634215209},{"_id":"source/_posts/rpm.spec/image-20230701173341798.png","hash":"009248d65ee6d3b30a9b4c432a96a6096dd42a1d","modified":1714634215209},{"_id":"source/_posts/rpm.spec/image-20230701173925324.png","hash":"ce52cee7b28f2b22a0eaff8268b4c8f587f3f63f","modified":1714634215209},{"_id":"source/_posts/rpm.spec/image-20230701174018570.png","hash":"90c26441a14b81bad773129e8b1f98122f1ee085","modified":1714634215209},{"_id":"source/_posts/rpm.spec/image-20230701175121884.png","hash":"84b0b9823f256d65e43133d857bc62bc1fc66c6c","modified":1714634215209},{"_id":"source/_posts/编程语言兼容性/image-20230611121349952.png","hash":"bd0d16f58244f11a5da3c219831eacd0dbc15abd","modified":1714634215213},{"_id":"source/_posts/rpm.spec/image-20230701170955227.png","hash":"4e0d04198b2928f1a5a74448bbf56b31c4f08233","modified":1714634215209},{"_id":"source/_posts/编程语言兼容性/image-20230611113916798.png","hash":"e46524dd9184de348df1cf60188e0626253e2daa","modified":1714634215213},{"_id":"source/_posts/编程语言源/image-20230930004122812.png","hash":"e09d3600de5f86a0b10fad7ea5d2fb782947bfc5","modified":1714634215213},{"_id":"source/_posts/编程语言源/image-20230929220230437.png","hash":"5e7aecc5f4662c497abada2c4cd19a3cf1c373f1","modified":1714634215213},{"_id":"source/_posts/编程语言源/image-20230929231952522.png","hash":"53bba0df2275b2c1b801c9b193f09fc77a8757c5","modified":1714634215213},{"_id":"source/_posts/spec依赖检查机制/image-20230701171040194.png","hash":"05c7468abc53237f3086cec43581b2c83665722a","modified":1714634215209},{"_id":"source/_posts/spec依赖检查机制/image-20230701173341798.png","hash":"009248d65ee6d3b30a9b4c432a96a6096dd42a1d","modified":1714634215209},{"_id":"source/_posts/spec依赖检查机制/image-20230701173925324.png","hash":"ce52cee7b28f2b22a0eaff8268b4c8f587f3f63f","modified":1714634215209},{"_id":"source/_posts/spec依赖检查机制/image-20230701174018570.png","hash":"90c26441a14b81bad773129e8b1f98122f1ee085","modified":1714634215209},{"_id":"source/_posts/spec依赖检查机制/image-20230701175121884.png","hash":"84b0b9823f256d65e43133d857bc62bc1fc66c6c","modified":1714634215209},{"_id":"source/_posts/spec依赖检查机制/image-20230701170955227.png","hash":"4e0d04198b2928f1a5a74448bbf56b31c4f08233","modified":1714634215209},{"_id":"source/images/spec依赖检查机制/image-20230701171040194.png","hash":"05c7468abc53237f3086cec43581b2c83665722a","modified":1714634215209},{"_id":"source/images/spec依赖检查机制/image-20230701173341798.png","hash":"009248d65ee6d3b30a9b4c432a96a6096dd42a1d","modified":1714634215209},{"_id":"source/images/spec依赖检查机制/image-20230701173925324.png","hash":"ce52cee7b28f2b22a0eaff8268b4c8f587f3f63f","modified":1714634215209},{"_id":"source/images/spec依赖检查机制/image-20230701174018570.png","hash":"90c26441a14b81bad773129e8b1f98122f1ee085","modified":1714634215209},{"_id":"source/images/spec依赖检查机制/image-20230701175121884.png","hash":"84b0b9823f256d65e43133d857bc62bc1fc66c6c","modified":1714634215209},{"_id":"source/images/spec依赖检查机制/image-20230701170955227.png","hash":"4e0d04198b2928f1a5a74448bbf56b31c4f08233","modified":1714634215209},{"_id":"source/images/编程语言兼容性/image-20230611121349952.png","hash":"bd0d16f58244f11a5da3c219831eacd0dbc15abd","modified":1714634215213},{"_id":"source/images/编程语言源/image-20230930004122812.png","hash":"e09d3600de5f86a0b10fad7ea5d2fb782947bfc5","modified":1714634215213},{"_id":"source/images/编程语言兼容性/image-20230611113916798.png","hash":"e46524dd9184de348df1cf60188e0626253e2daa","modified":1714634215213},{"_id":"source/images/编程语言源/image-20230929220230437.png","hash":"5e7aecc5f4662c497abada2c4cd19a3cf1c373f1","modified":1714634215213},{"_id":"source/images/编程语言源/image-20230929231952522.png","hash":"53bba0df2275b2c1b801c9b193f09fc77a8757c5","modified":1714634215213},{"_id":"source/_posts/spec依赖检查机制.md","hash":"174da0d31a3c093b27656dc34a910c0b4d4d2fa3","modified":1723970022605},{"_id":"source/_posts/编程语言兼容性.md","hash":"dc3729880df5f48f4e109b460c889a9747915467","modified":1723971022844},{"_id":"source/_posts/编程语言源.md","hash":"e69e366bf4c6af4503d145bb26454a4bd4baa426","modified":1718038092916},{"_id":"source/about/index.md","hash":"3d6f0df3321e33f288def53642461e5b0c439ddd","modified":1715618292243},{"_id":"source/_posts/链接.md","hash":"c670348cb7ad3a739a9e9e04ccd155971279802d","modified":1718038186556},{"_id":"source/images/链接/image-20240610231929156.png","hash":"28f798842ee5b1908a044ab02f4eab0ea0831847","modified":1718037641326},{"_id":"source/images/链接/image-20240610184504549.png","hash":"6bdbe9956a3439c4889fb4b9a1b798a40a94f797","modified":1718037641196},{"_id":"source/images/链接/image-20240611001854930.png","hash":"c6f55f3754b805c2073131d7baa4cc67b3817177","modified":1718037641406},{"_id":"source/images/链接/image-20240611002011827.png","hash":"8055cdf1e4f94882706e205909d1f11921d0fd7c","modified":1718037641066},{"_id":"source/images/链接/image-20240611001920437.png","hash":"87c4078a2125953fc821ecf6cbdcd8449f4c5fc0","modified":1718037641536},{"_id":"source/_posts/程序链接.md","hash":"c62823421ffd31a66ba90bae07e058dbc66531bf","modified":1723971241304},{"_id":"source/_posts/编程语言镜像源.md","hash":"a358082af58b4fa179a135cb7b7c4af62d23cba8","modified":1723971051504},{"_id":"source/_posts/leetcode刷题随记.md","hash":"99e515ce051fb2e97a8cb786c06dfb494e31baf2","modified":1725115571772},{"_id":"source/_posts/kubernetes.md","hash":"230775c326d2b0f0fbfa6fbb6fa6a3512e0b89d2","modified":1725115617012}],"Category":[{"name":"指导书","_id":"clvow0nat0005adpv62w14f2j"},{"name":"生态","_id":"clvow0naz000badpv173d2a7h"},{"name":"计算机系统","_id":"clx9771450003h1p72ql85n97"},{"name":"计算生态","_id":"clxhoiubg0000ktp74dn0cqyo"},{"name":"操作系统","_id":"clzzb0ro10006lnp7d4vk14y1"},{"name":"计算机组成","_id":"clzzb110b0008lnp7494me4g2"},{"name":"编程语言","_id":"clzzb1pvj000alnp781ct728p"},{"name":"编程语言管理","_id":"clzzb25kg000clnp77mgy5yd7"},{"name":"云组件","_id":"cm0i910800004cfp7evcb928w"},{"name":"编程基础","_id":"cm0i9awlu0001a4p727wj82ku"}],"Data":[],"Page":[{"title":"about","date":"2024-05-02T09:26:36.000Z","_content":"\n这是一个哲学问题。\n","source":"about/index.md","raw":"---\ntitle: about\ndate: 2024-05-02 17:26:36\n---\n\n这是一个哲学问题。\n","updated":"2024-05-13T16:38:12.243Z","path":"about/index.html","_id":"clvp3gte900090cpv9o1j9b4g","comments":1,"layout":"page","content":"<p>这是一个哲学问题。</p>\n","excerpt":"","more":"<p>这是一个哲学问题。</p>\n"}],"Post":[{"title":"spec依赖检查机制","date":"2023-07-01T15:00:02.000Z","toc":true,"_content":"\nrpm包通过spec脚本来控制rpm包的安装过程，如果有依赖不满足，将通过yum/dnf工具提示到用户。那么spec文件的依赖是怎么检查的？\n\n<!-- more -->\n\n编译阶段：通过BuildRequires；运行阶段：通过Requires\n\n```bash\nBuildRequires:  python\nRequires:       python\n```\n\n具体检查方式：\n\n查看rpmbuild源码：[Ftp - /releases/rpm-4.15.x/ :: Oregon State University Open Source Lab](http://ftp.rpm.org/releases/rpm-4.15.x/)\n\nBuildRequires被解释为使用宏__spec_buildrequires_template：\n\n![image-20230701170955227](/images/spec依赖检查机制/image-20230701170955227.png)\n\n该宏具体内容可以通过rpm --eval展开：\n\n```bash\nrpm --eval %{__spec_buildrequires_template}\n```\n\n![image-20230701171040194](/images/spec依赖检查机制/image-20230701171040194.png)\n\n这里涉及到一个环境变量PKG_CONFIG_PATH，使用了pkg-config工具，关于该工具介绍查看：[Guide to pkg-config (people.freedesktop.org)](https://people.freedesktop.org/~dbn/pkg-config-guide.html)\n\n该工具的作用：\n\n- 避免硬编码lib库路径：\n\n```bash\ngcc test.c `pkg-config --libs --cflags glib-2.0`\n\n[root@openEuler2003SP1 SPECS]# pkg-config --libs --cflags glib-2.0\n-I/usr/include/glib-2.0 -I/usr/lib64/glib-2.0/include -lglib-2.0\n```\n\n- 依赖版本检查\n\n```bash\n$ pkg-config --libs \"bar >= 2.7\"\nRequested 'bar >= 2.7' but version of bar is 2.1.2\n```\n\n如果bar依赖foo，则使用以下命令将连带出完整的依赖链：\n\n```bash\n[root@openEuler2003SP1 test]# pkg-config --libs --static foo\n-L/usr/lib -lfoo\n[root@openEuler2003SP1 test]# pkg-config --libs --static bar\n-L/usr/lib -lbar -L/usr/lib -lfoo\n```\n\n我们常见的configure输出的package not found错误，其实就是来自pkg-config的判断：\n\n```bash\n[root@openEuler2003SP1 test]# pkg-config --exists --print-errors xoxo\nPackage xoxo was not found in the pkg-config search path.\nPerhaps you should add the directory containing `xoxo.pc'\nto the PKG_CONFIG_PATH environment variable\nPackage 'xoxo', required by 'virtual:world', not found\n```\n\n\n\n我们再看下平时build阶段经常依赖的devel包，里面都有什么：\n\n![image-20230701173341798](/images/spec依赖检查机制/image-20230701173341798.png)\n\n可以看到有三部分，header、so、pc\n\nheader对应到头文件函数声明，so对应的函数具体实现，pc就是pkg-config的元数据文件了，这三元组最终组合形成完整的依赖编译命令：\n\n```bash\ngcc test.c -I/usr/include/foo -L/usr/lib -lbar -L/usr/lib -lfoo\n```\n\n现在回到spec，BuildRequires不满足打印示例：\n\n```bash\n[root@openEuler2003SP1 SPECS]# rpmbuild -ba daos.spec\nerror: Failed build dependencies:\n        daos-raft-devel = 0.9.1-1401.gc18bcb8 is needed by daos-2.2.0-4.aarch64\n        go >= 1.14 is needed by daos-2.2.0-4.aarch64\n```\n\n这些error依赖检查来自：\n\n![image-20230701173925324](/images/spec依赖检查机制/image-20230701173925324.png)\n\n![image-20230701174018570](/images/spec依赖检查机制/image-20230701174018570.png)\n\nts变量：transaction set，在rpmts.h中定义了一系列关于该变量的使用方法：\n\n![image-20230701175121884](/images/spec依赖检查机制/image-20230701175121884.png)\n\n所以rpm检查依赖的底层逻辑是通过查询数据库，数据库路径可以通过宏查看：\n\n```bash\n[root@openEuler2003SP1 SPECS]# rpm --eval \"%{_db_backend}\"\nbdb\n[root@openEuler2003SP1 SPECS]# rpm --eval %{_dbpath}\n/var/lib/rpm\n[root@openEuler2003SP1 SPECS]# ls /var/lib/rpm\nBasenames     __db.001  __db.003  Enhancename      Group       Name          Packages     Recommendname  Sha1header  Suggestname     Transfiletriggername\nConflictname  __db.002  Dirnames  Filetriggername  Installtid  Obsoletename  Providename  Requirename    Sigmd5      Supplementname  Triggername\n```\n\n它是一个bdb数据库（旧的也有使用sqlite：[rpm.org - RPM Database Recovery](https://rpm.org/user_doc/db_recovery.html)）\n\n\n\ndevel包如何构建：[linux - Building both devel and normal version of a RPM package - Stack Overflow](https://stackoverflow.com/questions/2913130/building-both-devel-and-normal-version-of-a-rpm-package)\n\n一般不会单独写一个devel的spec，而是和binary rpm的spec共用，通过在各个章节后面带devel标记区分：\n\n```bash\n%package devel\n%description devel\n%files devel\n```\n\n","source":"_posts/spec依赖检查机制.md","raw":"---\ntitle: spec依赖检查机制\ndate: 2023/07/01 23:00:02\ntoc: true\ncategories: \n - 操作系统\ntags: \n - 软件生态\n---\n\nrpm包通过spec脚本来控制rpm包的安装过程，如果有依赖不满足，将通过yum/dnf工具提示到用户。那么spec文件的依赖是怎么检查的？\n\n<!-- more -->\n\n编译阶段：通过BuildRequires；运行阶段：通过Requires\n\n```bash\nBuildRequires:  python\nRequires:       python\n```\n\n具体检查方式：\n\n查看rpmbuild源码：[Ftp - /releases/rpm-4.15.x/ :: Oregon State University Open Source Lab](http://ftp.rpm.org/releases/rpm-4.15.x/)\n\nBuildRequires被解释为使用宏__spec_buildrequires_template：\n\n![image-20230701170955227](/images/spec依赖检查机制/image-20230701170955227.png)\n\n该宏具体内容可以通过rpm --eval展开：\n\n```bash\nrpm --eval %{__spec_buildrequires_template}\n```\n\n![image-20230701171040194](/images/spec依赖检查机制/image-20230701171040194.png)\n\n这里涉及到一个环境变量PKG_CONFIG_PATH，使用了pkg-config工具，关于该工具介绍查看：[Guide to pkg-config (people.freedesktop.org)](https://people.freedesktop.org/~dbn/pkg-config-guide.html)\n\n该工具的作用：\n\n- 避免硬编码lib库路径：\n\n```bash\ngcc test.c `pkg-config --libs --cflags glib-2.0`\n\n[root@openEuler2003SP1 SPECS]# pkg-config --libs --cflags glib-2.0\n-I/usr/include/glib-2.0 -I/usr/lib64/glib-2.0/include -lglib-2.0\n```\n\n- 依赖版本检查\n\n```bash\n$ pkg-config --libs \"bar >= 2.7\"\nRequested 'bar >= 2.7' but version of bar is 2.1.2\n```\n\n如果bar依赖foo，则使用以下命令将连带出完整的依赖链：\n\n```bash\n[root@openEuler2003SP1 test]# pkg-config --libs --static foo\n-L/usr/lib -lfoo\n[root@openEuler2003SP1 test]# pkg-config --libs --static bar\n-L/usr/lib -lbar -L/usr/lib -lfoo\n```\n\n我们常见的configure输出的package not found错误，其实就是来自pkg-config的判断：\n\n```bash\n[root@openEuler2003SP1 test]# pkg-config --exists --print-errors xoxo\nPackage xoxo was not found in the pkg-config search path.\nPerhaps you should add the directory containing `xoxo.pc'\nto the PKG_CONFIG_PATH environment variable\nPackage 'xoxo', required by 'virtual:world', not found\n```\n\n\n\n我们再看下平时build阶段经常依赖的devel包，里面都有什么：\n\n![image-20230701173341798](/images/spec依赖检查机制/image-20230701173341798.png)\n\n可以看到有三部分，header、so、pc\n\nheader对应到头文件函数声明，so对应的函数具体实现，pc就是pkg-config的元数据文件了，这三元组最终组合形成完整的依赖编译命令：\n\n```bash\ngcc test.c -I/usr/include/foo -L/usr/lib -lbar -L/usr/lib -lfoo\n```\n\n现在回到spec，BuildRequires不满足打印示例：\n\n```bash\n[root@openEuler2003SP1 SPECS]# rpmbuild -ba daos.spec\nerror: Failed build dependencies:\n        daos-raft-devel = 0.9.1-1401.gc18bcb8 is needed by daos-2.2.0-4.aarch64\n        go >= 1.14 is needed by daos-2.2.0-4.aarch64\n```\n\n这些error依赖检查来自：\n\n![image-20230701173925324](/images/spec依赖检查机制/image-20230701173925324.png)\n\n![image-20230701174018570](/images/spec依赖检查机制/image-20230701174018570.png)\n\nts变量：transaction set，在rpmts.h中定义了一系列关于该变量的使用方法：\n\n![image-20230701175121884](/images/spec依赖检查机制/image-20230701175121884.png)\n\n所以rpm检查依赖的底层逻辑是通过查询数据库，数据库路径可以通过宏查看：\n\n```bash\n[root@openEuler2003SP1 SPECS]# rpm --eval \"%{_db_backend}\"\nbdb\n[root@openEuler2003SP1 SPECS]# rpm --eval %{_dbpath}\n/var/lib/rpm\n[root@openEuler2003SP1 SPECS]# ls /var/lib/rpm\nBasenames     __db.001  __db.003  Enhancename      Group       Name          Packages     Recommendname  Sha1header  Suggestname     Transfiletriggername\nConflictname  __db.002  Dirnames  Filetriggername  Installtid  Obsoletename  Providename  Requirename    Sigmd5      Supplementname  Triggername\n```\n\n它是一个bdb数据库（旧的也有使用sqlite：[rpm.org - RPM Database Recovery](https://rpm.org/user_doc/db_recovery.html)）\n\n\n\ndevel包如何构建：[linux - Building both devel and normal version of a RPM package - Stack Overflow](https://stackoverflow.com/questions/2913130/building-both-devel-and-normal-version-of-a-rpm-package)\n\n一般不会单独写一个devel的spec，而是和binary rpm的spec共用，通过在各个章节后面带devel标记区分：\n\n```bash\n%package devel\n%description devel\n%files devel\n```\n\n","slug":"spec依赖检查机制","published":1,"updated":"2024-08-18T08:33:42.605Z","_id":"clvp3gtdz00000cpvdnfwfgc0","comments":1,"layout":"post","photos":[],"content":"<p>rpm包通过spec脚本来控制rpm包的安装过程，如果有依赖不满足，将通过yum&#x2F;dnf工具提示到用户。那么spec文件的依赖是怎么检查的？</p>\n<span id=\"more\"></span>\n\n<p>编译阶段：通过BuildRequires；运行阶段：通过Requires</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BuildRequires:  python</span><br><span class=\"line\">Requires:       python</span><br></pre></td></tr></table></figure>\n\n<p>具体检查方式：</p>\n<p>查看rpmbuild源码：<a href=\"http://ftp.rpm.org/releases/rpm-4.15.x/\">Ftp - &#x2F;releases&#x2F;rpm-4.15.x&#x2F; :: Oregon State University Open Source Lab</a></p>\n<p>BuildRequires被解释为使用宏__spec_buildrequires_template：</p>\n<p><img src=\"/images/spec%E4%BE%9D%E8%B5%96%E6%A3%80%E6%9F%A5%E6%9C%BA%E5%88%B6/image-20230701170955227.png\" alt=\"image-20230701170955227\"></p>\n<p>该宏具体内容可以通过rpm –eval展开：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rpm --<span class=\"built_in\">eval</span> %&#123;__spec_buildrequires_template&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/images/spec%E4%BE%9D%E8%B5%96%E6%A3%80%E6%9F%A5%E6%9C%BA%E5%88%B6/image-20230701171040194.png\" alt=\"image-20230701171040194\"></p>\n<p>这里涉及到一个环境变量PKG_CONFIG_PATH，使用了pkg-config工具，关于该工具介绍查看：<a href=\"https://people.freedesktop.org/~dbn/pkg-config-guide.html\">Guide to pkg-config (people.freedesktop.org)</a></p>\n<p>该工具的作用：</p>\n<ul>\n<li>避免硬编码lib库路径：</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gcc test.c `pkg-config --libs --cflags glib-2.0`</span><br><span class=\"line\"></span><br><span class=\"line\">[root@openEuler2003SP1 SPECS]<span class=\"comment\"># pkg-config --libs --cflags glib-2.0</span></span><br><span class=\"line\">-I/usr/include/glib-2.0 -I/usr/lib64/glib-2.0/include -lglib-2.0</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>依赖版本检查</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ pkg-config --libs <span class=\"string\">&quot;bar &gt;= 2.7&quot;</span></span><br><span class=\"line\">Requested <span class=\"string\">&#x27;bar &gt;= 2.7&#x27;</span> but version of bar is 2.1.2</span><br></pre></td></tr></table></figure>\n\n<p>如果bar依赖foo，则使用以下命令将连带出完整的依赖链：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@openEuler2003SP1 <span class=\"built_in\">test</span>]<span class=\"comment\"># pkg-config --libs --static foo</span></span><br><span class=\"line\">-L/usr/lib -lfoo</span><br><span class=\"line\">[root@openEuler2003SP1 <span class=\"built_in\">test</span>]<span class=\"comment\"># pkg-config --libs --static bar</span></span><br><span class=\"line\">-L/usr/lib -lbar -L/usr/lib -lfoo</span><br></pre></td></tr></table></figure>\n\n<p>我们常见的configure输出的package not found错误，其实就是来自pkg-config的判断：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@openEuler2003SP1 <span class=\"built_in\">test</span>]<span class=\"comment\"># pkg-config --exists --print-errors xoxo</span></span><br><span class=\"line\">Package xoxo was not found <span class=\"keyword\">in</span> the pkg-config search path.</span><br><span class=\"line\">Perhaps you should add the directory containing `xoxo.pc<span class=\"string\">&#x27;</span></span><br><span class=\"line\"><span class=\"string\">to the PKG_CONFIG_PATH environment variable</span></span><br><span class=\"line\"><span class=\"string\">Package &#x27;</span>xoxo<span class=\"string\">&#x27;, required by &#x27;</span>virtual:world<span class=\"string\">&#x27;, not found</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>我们再看下平时build阶段经常依赖的devel包，里面都有什么：</p>\n<p><img src=\"/images/spec%E4%BE%9D%E8%B5%96%E6%A3%80%E6%9F%A5%E6%9C%BA%E5%88%B6/image-20230701173341798.png\" alt=\"image-20230701173341798\"></p>\n<p>可以看到有三部分，header、so、pc</p>\n<p>header对应到头文件函数声明，so对应的函数具体实现，pc就是pkg-config的元数据文件了，这三元组最终组合形成完整的依赖编译命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gcc test.c -I/usr/include/foo -L/usr/lib -lbar -L/usr/lib -lfoo</span><br></pre></td></tr></table></figure>\n\n<p>现在回到spec，BuildRequires不满足打印示例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@openEuler2003SP1 SPECS]<span class=\"comment\"># rpmbuild -ba daos.spec</span></span><br><span class=\"line\">error: Failed build dependencies:</span><br><span class=\"line\">        daos-raft-devel = 0.9.1-1401.gc18bcb8 is needed by daos-2.2.0-4.aarch64</span><br><span class=\"line\">        go &gt;= 1.14 is needed by daos-2.2.0-4.aarch64</span><br></pre></td></tr></table></figure>\n\n<p>这些error依赖检查来自：</p>\n<p><img src=\"/images/spec%E4%BE%9D%E8%B5%96%E6%A3%80%E6%9F%A5%E6%9C%BA%E5%88%B6/image-20230701173925324.png\" alt=\"image-20230701173925324\"></p>\n<p><img src=\"/images/spec%E4%BE%9D%E8%B5%96%E6%A3%80%E6%9F%A5%E6%9C%BA%E5%88%B6/image-20230701174018570.png\" alt=\"image-20230701174018570\"></p>\n<p>ts变量：transaction set，在rpmts.h中定义了一系列关于该变量的使用方法：</p>\n<p><img src=\"/images/spec%E4%BE%9D%E8%B5%96%E6%A3%80%E6%9F%A5%E6%9C%BA%E5%88%B6/image-20230701175121884.png\" alt=\"image-20230701175121884\"></p>\n<p>所以rpm检查依赖的底层逻辑是通过查询数据库，数据库路径可以通过宏查看：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@openEuler2003SP1 SPECS]<span class=\"comment\"># rpm --eval &quot;%&#123;_db_backend&#125;&quot;</span></span><br><span class=\"line\">bdb</span><br><span class=\"line\">[root@openEuler2003SP1 SPECS]<span class=\"comment\"># rpm --eval %&#123;_dbpath&#125;</span></span><br><span class=\"line\">/var/lib/rpm</span><br><span class=\"line\">[root@openEuler2003SP1 SPECS]<span class=\"comment\"># ls /var/lib/rpm</span></span><br><span class=\"line\">Basenames     __db.001  __db.003  Enhancename      Group       Name          Packages     Recommendname  Sha1header  Suggestname     Transfiletriggername</span><br><span class=\"line\">Conflictname  __db.002  Dirnames  Filetriggername  Installtid  Obsoletename  Providename  Requirename    Sigmd5      Supplementname  Triggername</span><br></pre></td></tr></table></figure>\n\n<p>它是一个bdb数据库（旧的也有使用sqlite：<a href=\"https://rpm.org/user_doc/db_recovery.html\">rpm.org - RPM Database Recovery</a>）</p>\n<p>devel包如何构建：<a href=\"https://stackoverflow.com/questions/2913130/building-both-devel-and-normal-version-of-a-rpm-package\">linux - Building both devel and normal version of a RPM package - Stack Overflow</a></p>\n<p>一般不会单独写一个devel的spec，而是和binary rpm的spec共用，通过在各个章节后面带devel标记区分：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">%package devel</span><br><span class=\"line\">%description devel</span><br><span class=\"line\">%files devel</span><br></pre></td></tr></table></figure>\n\n","excerpt":"<p>rpm包通过spec脚本来控制rpm包的安装过程，如果有依赖不满足，将通过yum&#x2F;dnf工具提示到用户。那么spec文件的依赖是怎么检查的？</p>","more":"<p>编译阶段：通过BuildRequires；运行阶段：通过Requires</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BuildRequires:  python</span><br><span class=\"line\">Requires:       python</span><br></pre></td></tr></table></figure>\n\n<p>具体检查方式：</p>\n<p>查看rpmbuild源码：<a href=\"http://ftp.rpm.org/releases/rpm-4.15.x/\">Ftp - &#x2F;releases&#x2F;rpm-4.15.x&#x2F; :: Oregon State University Open Source Lab</a></p>\n<p>BuildRequires被解释为使用宏__spec_buildrequires_template：</p>\n<p><img src=\"/images/spec%E4%BE%9D%E8%B5%96%E6%A3%80%E6%9F%A5%E6%9C%BA%E5%88%B6/image-20230701170955227.png\" alt=\"image-20230701170955227\"></p>\n<p>该宏具体内容可以通过rpm –eval展开：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rpm --<span class=\"built_in\">eval</span> %&#123;__spec_buildrequires_template&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/images/spec%E4%BE%9D%E8%B5%96%E6%A3%80%E6%9F%A5%E6%9C%BA%E5%88%B6/image-20230701171040194.png\" alt=\"image-20230701171040194\"></p>\n<p>这里涉及到一个环境变量PKG_CONFIG_PATH，使用了pkg-config工具，关于该工具介绍查看：<a href=\"https://people.freedesktop.org/~dbn/pkg-config-guide.html\">Guide to pkg-config (people.freedesktop.org)</a></p>\n<p>该工具的作用：</p>\n<ul>\n<li>避免硬编码lib库路径：</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gcc test.c `pkg-config --libs --cflags glib-2.0`</span><br><span class=\"line\"></span><br><span class=\"line\">[root@openEuler2003SP1 SPECS]<span class=\"comment\"># pkg-config --libs --cflags glib-2.0</span></span><br><span class=\"line\">-I/usr/include/glib-2.0 -I/usr/lib64/glib-2.0/include -lglib-2.0</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>依赖版本检查</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ pkg-config --libs <span class=\"string\">&quot;bar &gt;= 2.7&quot;</span></span><br><span class=\"line\">Requested <span class=\"string\">&#x27;bar &gt;= 2.7&#x27;</span> but version of bar is 2.1.2</span><br></pre></td></tr></table></figure>\n\n<p>如果bar依赖foo，则使用以下命令将连带出完整的依赖链：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@openEuler2003SP1 <span class=\"built_in\">test</span>]<span class=\"comment\"># pkg-config --libs --static foo</span></span><br><span class=\"line\">-L/usr/lib -lfoo</span><br><span class=\"line\">[root@openEuler2003SP1 <span class=\"built_in\">test</span>]<span class=\"comment\"># pkg-config --libs --static bar</span></span><br><span class=\"line\">-L/usr/lib -lbar -L/usr/lib -lfoo</span><br></pre></td></tr></table></figure>\n\n<p>我们常见的configure输出的package not found错误，其实就是来自pkg-config的判断：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@openEuler2003SP1 <span class=\"built_in\">test</span>]<span class=\"comment\"># pkg-config --exists --print-errors xoxo</span></span><br><span class=\"line\">Package xoxo was not found <span class=\"keyword\">in</span> the pkg-config search path.</span><br><span class=\"line\">Perhaps you should add the directory containing `xoxo.pc<span class=\"string\">&#x27;</span></span><br><span class=\"line\"><span class=\"string\">to the PKG_CONFIG_PATH environment variable</span></span><br><span class=\"line\"><span class=\"string\">Package &#x27;</span>xoxo<span class=\"string\">&#x27;, required by &#x27;</span>virtual:world<span class=\"string\">&#x27;, not found</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>我们再看下平时build阶段经常依赖的devel包，里面都有什么：</p>\n<p><img src=\"/images/spec%E4%BE%9D%E8%B5%96%E6%A3%80%E6%9F%A5%E6%9C%BA%E5%88%B6/image-20230701173341798.png\" alt=\"image-20230701173341798\"></p>\n<p>可以看到有三部分，header、so、pc</p>\n<p>header对应到头文件函数声明，so对应的函数具体实现，pc就是pkg-config的元数据文件了，这三元组最终组合形成完整的依赖编译命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gcc test.c -I/usr/include/foo -L/usr/lib -lbar -L/usr/lib -lfoo</span><br></pre></td></tr></table></figure>\n\n<p>现在回到spec，BuildRequires不满足打印示例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@openEuler2003SP1 SPECS]<span class=\"comment\"># rpmbuild -ba daos.spec</span></span><br><span class=\"line\">error: Failed build dependencies:</span><br><span class=\"line\">        daos-raft-devel = 0.9.1-1401.gc18bcb8 is needed by daos-2.2.0-4.aarch64</span><br><span class=\"line\">        go &gt;= 1.14 is needed by daos-2.2.0-4.aarch64</span><br></pre></td></tr></table></figure>\n\n<p>这些error依赖检查来自：</p>\n<p><img src=\"/images/spec%E4%BE%9D%E8%B5%96%E6%A3%80%E6%9F%A5%E6%9C%BA%E5%88%B6/image-20230701173925324.png\" alt=\"image-20230701173925324\"></p>\n<p><img src=\"/images/spec%E4%BE%9D%E8%B5%96%E6%A3%80%E6%9F%A5%E6%9C%BA%E5%88%B6/image-20230701174018570.png\" alt=\"image-20230701174018570\"></p>\n<p>ts变量：transaction set，在rpmts.h中定义了一系列关于该变量的使用方法：</p>\n<p><img src=\"/images/spec%E4%BE%9D%E8%B5%96%E6%A3%80%E6%9F%A5%E6%9C%BA%E5%88%B6/image-20230701175121884.png\" alt=\"image-20230701175121884\"></p>\n<p>所以rpm检查依赖的底层逻辑是通过查询数据库，数据库路径可以通过宏查看：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@openEuler2003SP1 SPECS]<span class=\"comment\"># rpm --eval &quot;%&#123;_db_backend&#125;&quot;</span></span><br><span class=\"line\">bdb</span><br><span class=\"line\">[root@openEuler2003SP1 SPECS]<span class=\"comment\"># rpm --eval %&#123;_dbpath&#125;</span></span><br><span class=\"line\">/var/lib/rpm</span><br><span class=\"line\">[root@openEuler2003SP1 SPECS]<span class=\"comment\"># ls /var/lib/rpm</span></span><br><span class=\"line\">Basenames     __db.001  __db.003  Enhancename      Group       Name          Packages     Recommendname  Sha1header  Suggestname     Transfiletriggername</span><br><span class=\"line\">Conflictname  __db.002  Dirnames  Filetriggername  Installtid  Obsoletename  Providename  Requirename    Sigmd5      Supplementname  Triggername</span><br></pre></td></tr></table></figure>\n\n<p>它是一个bdb数据库（旧的也有使用sqlite：<a href=\"https://rpm.org/user_doc/db_recovery.html\">rpm.org - RPM Database Recovery</a>）</p>\n<p>devel包如何构建：<a href=\"https://stackoverflow.com/questions/2913130/building-both-devel-and-normal-version-of-a-rpm-package\">linux - Building both devel and normal version of a RPM package - Stack Overflow</a></p>\n<p>一般不会单独写一个devel的spec，而是和binary rpm的spec共用，通过在各个章节后面带devel标记区分：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">%package devel</span><br><span class=\"line\">%description devel</span><br><span class=\"line\">%files devel</span><br></pre></td></tr></table></figure>"},{"title":"编程语言兼容性","date":"2023-06-05T15:00:02.000Z","toc":true,"_content":"\n本文要讨论的兼容性是指上层应用软件对不同架构芯片及各类板卡硬件的兼容性。本文将聚焦于各类编程语言的兼容性都是怎么引入的，以便于为后续对拓展平台软件生态需要做哪些工作提供一些指导。\n\n<!-- more -->\n\n**什么样的软件具有好的兼容性？**\n\n对于一款软件，如果能够提供不同平台的二进制、或者仅提供一个二进制就能够在不同平台上跑，那么说明这款软件的兼容性很完备。但实际上受限于编程语言本身的能力、性能等约束，想达到这种目标往往比较困难。\n\n\n**什么时候会出现兼容性问题？**\n\n- 当代码中硬编码了汇编语言\n- 当代码中调用了so库，而该so库还被打包到最终的可运行包里\n- 当代码中调用了so库，且该so库是由软件源码包中的c/c++等待编译文件编译出来的\n\n以上这些情况均会导致软件与平台相关，进而导致软件必须提供不同平台编译版本才能满足软件在指定平台的可运行。\n\n只要软件和平台相关，那么当指定平台缺少该软件的预编译包时，整个上层应用在该平台上的安装就会失败，从而带来不好的兼容性体验。\n\n\n**那么，如何评价一款软件在给定平台的兼容性情况？**\n\n首先需要明确的是，兼容性达成情况是一个bool类型。软件是否兼容与软件有多么不兼容，后者会影响到你去做迁移适配的动作吗？难道软件严重不兼容就不做平台适配了？并不是的，对于给定的平台，我们想让软件跑起来，无论它具有多少不兼容代码，都得一一解决。唯有此，才能达成软件运行的目的。所以，评价软件兼容性是一个非黑即白的结论。\n\n**如何识别软件是否需要做兼容性？**\n\n- 分析源码\n- 直接在指定平台上编译运行\n\n针对第一点，以下挑选了top流行语言来列举各种可能存在的硬件兼容性情况。\n\n## javascript\n\n### 代码调用so\n\njavascript调用so，使用node-ffi包：[node-ffi/node-ffi: Node.js Foreign Function Interface (github.com)](https://github.com/node-ffi/node-ffi)\n\n```javascript\nvar ffi = require('ffi');\n\nvar libm = ffi.Library('libm', {\n  'ceil': [ 'double', [ 'double' ] ]\n});\nlibm.ceil(1.5); // 2\n\n// You can also access just functions in the current process by passing a null\nvar current = ffi.Library(null, {\n  'atoi': [ 'int', [ 'string' ] ]\n});\ncurrent.atoi('1234'); // 1234\n```\n\n**兼容性识别关键点：检查编译后的包是否包含so。**\n\n### 代码包含c/c++\n\n有些javascript包中带有其他编程语言，比如node-ffi：https://api.github.com/repos/node-ffi/node-ffi/languages\n\n```json\n{\n    \"JavaScript\": 65311,\n    \"C++\": 35850,\n    \"C\": 1364,\n    \"Python\": 921\n}\n```\n\n可以看到，js包里面具有c/c++编译型语言，这种包自然会导致平台兼容性问题。\n\n**兼容性识别关键点：检查源码中是否包含编译型语言。**\n\n### assembly技术\n\njavascript运行会被浏览器翻译为assembly中间机器语言，这里的机器语言并非CPU相关，真正运行还要再转义一次。\n\n这篇文章以一种自定义的JS-ASM来描绘java assembly是怎么工作的：[JavaScript Assembler Language Specification (JS-ASM) - CodeProject](https://www.codeproject.com/Articles/417071/JavaScript-Assembler-Language-Specification-JS-ASM)\n\n### npm包\n\n**npm包背景知识**\n\nnpm包制作和发布参考：[How to Create and Publish an NPM Package – a Step-by-Step Guide (freecodecamp.org)](https://www.freecodecamp.org/news/how-to-create-and-publish-your-first-npm-package/)\n\n制作npm包有两种方式：\n\n```bash\n# 方式1：link形式\nnpm link  # 将当前npm工程本地全局发布\nnpm link <package-name>  # 在其他工程目录下通过该命令引用\n\n# 方式2：离线包形式\nnpm pack  # 将当前npm工程打包为一个tgz\ncp /path/to/<package>.tgz .  # 在其他工程目录下通过该命令集成\n# 修改package.json，指定<package-name>: <package>.tgz\n```\n\nnpm包安装过程解读：[How npm install Works Internally? - DEV Community](https://dev.to/shree_j/how-npm-works-internally-4012)\n\nnpm包工作的核心文件是package.json，该文件内定义了npm如何对该包进行操作，包括install、serve、test等。\n\n如果没有特别说明，包内index.js为npm包的入口（entrypoint），新包发布所能使用的功能函数统一从这里出口（export）\n\n**了解这些背景知识后，我们看下有哪些情况npm包在安装时会触发兼容性问题**\n\n**案例1：**[Npm install 2.8.2 fails on ARM64, asks to upgrade to 2.5.1 or later - core - Meteor.js forums](https://forums.meteor.com/t/npm-install-2-8-2-fails-on-arm64-asks-to-upgrade-to-2-5-1-or-later/59177/4)\n\n该案例里npm包内具有平台检测硬编码，之所以做这类平台限制，是因为该包依赖了mongodb，而mongodb是平台相关，为适配arm，做了如下修复：\n\n[Support ARM on Linux by aquinoit · Pull Request #12160 · meteor/meteor (github.com)](https://github.com/meteor/meteor/pull/12160/files#diff-e139871b4a22b32fdb9a795e1ac8ee683d848695e01d8b170e168534ef63d6c8)\n\n![image-20230611113916798](/images/编程语言兼容性/image-20230611113916798.png)\n\n**案例2：**[Unable to `npm install` on M1 · Issue #668 · twilio/twilio-video-app-react (github.com)](https://github.com/twilio/twilio-video-app-react/issues/668)\n\n该报错是因为npm安装过程中apt install chromium-browser命令执行失败导致，最后通过手动补全chromium依赖解决。\n\n结合以上案例可以得出，npm包在安装过程中体现的兼容性问题，取决于npm包安装脚本是否有外界依赖引入。\n\n**兼容性识别关键点：直接跑一遍npm install来检验**\n\n\n\n### python\n\n#### 代码调用c\n\n这篇文章介绍了各种python调用c的方法，并给出了优劣势对比：[Python Bindings: Calling C or C++ From Python – Real Python](https://realpython.com/python-bindings-overview/)\n\nctypes内置包会处理所有跟c、so的交互：\n\n```python\nfrom ctypes import *\n# either\nlibc = cdll.LoadLibrary(\"libc.so.6\")\n# or\nlibc = CDLL(\"libc.so.6\")\n```\n\n**兼容性识别关键点：识别源码中是否带有so名称，编译好的包是否具有so。**\n\n### wheel包\n\n**wheel包背景知识**\n\n和npm包一样，wheel包也有一个类似package.json的核心文件来承载包的元数据信息，该核心文件有一个演进史：\n\n[What's the difference between setup.py and setup.cfg in python projects - Stack Overflow](https://stackoverflow.com/questions/39484863/whats-the-difference-between-setup-py-and-setup-cfg-in-python-projects)\n\n最开始是setup.py，然后是setup.cfg，再到现在则为pyproject.toml\n\n打包wheel的命令也有很多种，如build、wheel工具等，示例参考：[How to Create Python Packages | Towards Data Science](https://towardsdatascience.com/how-to-package-your-python-code-df5a7739ab2e)\n\n**wheel包安装兼容性问题**\n\n安装过程触发本地编译，通过setup.py：\n\n![image-20230611121349952](/images/编程语言兼容性/image-20230611121349952.png)\n\n此时如果setup.py过程对平台有依赖，就会报错。\n\n同npm包，wheel包安装失败的原因仅有可能是引入了外部依赖。\n\n**兼容性识别关键点：直接跑一遍pip install来检验**\n\n\n\n## java\n\njava调用so的方式是通过JNI或JNA。\n\n### jni\n\nJNI用法：[Call c function from Java - Stack Overflow](https://stackoverflow.com/questions/5963266/call-c-function-from-java)\n\n```java\nclass HelloWorld {\n    private native void print();  // 声明c方法\n\n    public static void main(String[] args) {\n        new HelloWorld().print();\n    }\n\n    static {\n        System.loadLibrary(\"HelloWorld\");  // 加载HelloWorld.so库\n    }\n}\n```\n\n这里还包含怎么编译so库出来的问题，详细见上述链接。\n\n**兼容性识别关键点：native、System.loadLibrary关键字**\n\n### jna\n\nJNA方法：[jna/GettingStarted.md at master · java-native-access/jna · GitHub](https://github.com/java-native-access/jna/blob/master/www/GettingStarted.md)\n\n```java\npackage com.sun.jna.examples;\n\nimport com.sun.jna.Library;\nimport com.sun.jna.Native;\nimport com.sun.jna.Platform;\n\n/** Simple example of JNA interface mapping and usage. */\npublic class HelloWorld {\n\n    // This is the standard, stable way of mapping, which supports extensive\n    // customization and mapping of Java to native types.\n\n    public interface CLibrary extends Library {\n        CLibrary INSTANCE = (CLibrary)\n            Native.load((Platform.isWindows() ? \"msvcrt\" : \"c\"),\n                                CLibrary.class);\n\n        void printf(String format, Object... args);\n    }\n\n    public static void main(String[] args) {\n        CLibrary.INSTANCE.printf(\"Hello, World\\n\");\n        for (int i=0;i < args.length;i++) {\n            CLibrary.INSTANCE.printf(\"Argument %d: %s\\n\", i, args[i]);\n        }\n    }\n```\n\n**兼容性识别关键点：是否引用了jna依赖。**\n\n### 其他jvm系语言\n\n其他基于java虚拟机开发的语言调用so方法和上述类似，均通过java官方的JNI或JNA方法：\n\n- scala：[scala c integration - Stack Overflow](https://stackoverflow.com/questions/6286044/scala-c-integration)\n- kotlin：[Calling C function from Kotlin using JNI - Stack Overflow](https://stackoverflow.com/questions/72646387/calling-c-function-from-kotlin-using-jni)\n- groovy：[java - Call C API from Groovy - Stack Overflow](https://stackoverflow.com/questions/1105211/call-c-api-from-groovy?rq=4)\n- clojure：[Calling C++ from clojure - Stack Overflow](https://stackoverflow.com/questions/53359255/calling-c-from-clojure)\n\n\n\n## perl\n\nperl语言的特点跟python类似，也是一种脚本解释语言。\n\n### 代码调用c\n\nperl调用c的方法如下：[How do I call a C function from a Perl program? - Stack Overflow](https://stackoverflow.com/questions/15136890/how-do-i-call-a-c-function-from-a-perl-program)\n\n```perl\nuse Inline C => <<'__END_OF_C__';\n\n    int sum(int a, int b)\n    {\n        return (a+b);\n    }\n\n__END_OF_C__\n\nsay sum($x,$y);\n```\n\n\n\n## ruby\n\nruby也是一种解释型语言。\n\n### 代码调用c\n\nruby调用c的方式是通过`rb_define_method`方法：[How to create a Ruby extension in C in under 5 minutes (rubyinside.com)](http://www.rubyinside.com/how-to-create-a-ruby-extension-in-c-in-under-5-minutes-100.html)\n\n```ruby\n// Include the Ruby headers and goodies\n#include \"ruby.h\"\n\n// Defining a space for information and references about the module to be stored internally\nVALUE MyTest = Qnil;\n\n// Prototype for the initialization method - Ruby calls this, not you\nvoid Init_mytest();\n\n// Prototype for our method 'test1' - methods are prefixed by 'method_' here\nVALUE method_test1(VALUE self);\n\n// The initialization method for this module\nvoid Init_mytest() {\n\tMyTest = rb_define_module(\"MyTest\");  // 定义c模块\n\trb_define_method(MyTest, \"test1\", method_test1, 0);  // 定义c方法\n}\n\n// Our 'test1' method.. it simply returns a value of '10' for now.\nVALUE method_test1(VALUE self) {\n\tint x = 10;\n\treturn INT2NUM(x);\n}\n```\n\n\n\n### 代码调用so\n\nruby调用so的方式通过借助ffi：[Calling C shared libraries with ruby FFI (jertype.com)](https://www.jertype.com/calling-c-shared-library/)\n\n```ruby\nrequire 'ffi'\n\nmodule ConcatInterop\n  extend FFI::Library\n\n  ffi_lib './concat.so'\n  attach_function :concat, [:string, :string, :pointer], :void\nend\n```\n\n\n\n## lua\n\nlua也是一种解释型语言。\n\n### 代码调用c\n\nlua调用c的方式是通过`lua_CFunction`方法：[How would I make a C-function that I can call from Lua? - Stack Overflow](https://stackoverflow.com/questions/4190697/how-would-i-make-a-c-function-that-i-can-call-from-lua)\n\n### 代码调用so\n\nlua调用so的方式是通过ffi：[ffi - How to call a function in shared library using Lua - Stack Overflow](https://stackoverflow.com/questions/37876215/how-to-call-a-function-in-shared-library-using-lua)\n\n```lua\nlocal lib = ffi.load('some.dll')\nffi.cdef[[\n  void hello (void);\n]]\nlib.hello()\n```\n\n\n\n## php\n\nphp想要调用c或so的话，就不是在php内声明c函数签名的方式了，而是通过编写php extension：[Is it possible to call C code from php - Stack Overflow](https://stackoverflow.com/questions/3125388/is-it-possible-to-call-c-code-from-php)\n\n\n\n## c/c++/fortran/rust/go\n\n这些语言就都是编译型语言了，编译型语言一定是平台相关，意味着不存在出一个包就能达成跨平台的效果，故此类软件一定要做迁移。\n\n对于编译型语言，兼容性主要体现在编译过程，如：\n\n- 按照默认的readme、官方文档编译步骤，编译过程是否顺畅？\n- 是否存在某个平台相关选项导致编译失败？\n\n","source":"_posts/编程语言兼容性.md","raw":"---\ntitle: 编程语言兼容性\ndate: 2023/06/05 23:00:02\ntoc: true\ncategories: \n - 编程语言\ntags: \n - 软件生态\n---\n\n本文要讨论的兼容性是指上层应用软件对不同架构芯片及各类板卡硬件的兼容性。本文将聚焦于各类编程语言的兼容性都是怎么引入的，以便于为后续对拓展平台软件生态需要做哪些工作提供一些指导。\n\n<!-- more -->\n\n**什么样的软件具有好的兼容性？**\n\n对于一款软件，如果能够提供不同平台的二进制、或者仅提供一个二进制就能够在不同平台上跑，那么说明这款软件的兼容性很完备。但实际上受限于编程语言本身的能力、性能等约束，想达到这种目标往往比较困难。\n\n\n**什么时候会出现兼容性问题？**\n\n- 当代码中硬编码了汇编语言\n- 当代码中调用了so库，而该so库还被打包到最终的可运行包里\n- 当代码中调用了so库，且该so库是由软件源码包中的c/c++等待编译文件编译出来的\n\n以上这些情况均会导致软件与平台相关，进而导致软件必须提供不同平台编译版本才能满足软件在指定平台的可运行。\n\n只要软件和平台相关，那么当指定平台缺少该软件的预编译包时，整个上层应用在该平台上的安装就会失败，从而带来不好的兼容性体验。\n\n\n**那么，如何评价一款软件在给定平台的兼容性情况？**\n\n首先需要明确的是，兼容性达成情况是一个bool类型。软件是否兼容与软件有多么不兼容，后者会影响到你去做迁移适配的动作吗？难道软件严重不兼容就不做平台适配了？并不是的，对于给定的平台，我们想让软件跑起来，无论它具有多少不兼容代码，都得一一解决。唯有此，才能达成软件运行的目的。所以，评价软件兼容性是一个非黑即白的结论。\n\n**如何识别软件是否需要做兼容性？**\n\n- 分析源码\n- 直接在指定平台上编译运行\n\n针对第一点，以下挑选了top流行语言来列举各种可能存在的硬件兼容性情况。\n\n## javascript\n\n### 代码调用so\n\njavascript调用so，使用node-ffi包：[node-ffi/node-ffi: Node.js Foreign Function Interface (github.com)](https://github.com/node-ffi/node-ffi)\n\n```javascript\nvar ffi = require('ffi');\n\nvar libm = ffi.Library('libm', {\n  'ceil': [ 'double', [ 'double' ] ]\n});\nlibm.ceil(1.5); // 2\n\n// You can also access just functions in the current process by passing a null\nvar current = ffi.Library(null, {\n  'atoi': [ 'int', [ 'string' ] ]\n});\ncurrent.atoi('1234'); // 1234\n```\n\n**兼容性识别关键点：检查编译后的包是否包含so。**\n\n### 代码包含c/c++\n\n有些javascript包中带有其他编程语言，比如node-ffi：https://api.github.com/repos/node-ffi/node-ffi/languages\n\n```json\n{\n    \"JavaScript\": 65311,\n    \"C++\": 35850,\n    \"C\": 1364,\n    \"Python\": 921\n}\n```\n\n可以看到，js包里面具有c/c++编译型语言，这种包自然会导致平台兼容性问题。\n\n**兼容性识别关键点：检查源码中是否包含编译型语言。**\n\n### assembly技术\n\njavascript运行会被浏览器翻译为assembly中间机器语言，这里的机器语言并非CPU相关，真正运行还要再转义一次。\n\n这篇文章以一种自定义的JS-ASM来描绘java assembly是怎么工作的：[JavaScript Assembler Language Specification (JS-ASM) - CodeProject](https://www.codeproject.com/Articles/417071/JavaScript-Assembler-Language-Specification-JS-ASM)\n\n### npm包\n\n**npm包背景知识**\n\nnpm包制作和发布参考：[How to Create and Publish an NPM Package – a Step-by-Step Guide (freecodecamp.org)](https://www.freecodecamp.org/news/how-to-create-and-publish-your-first-npm-package/)\n\n制作npm包有两种方式：\n\n```bash\n# 方式1：link形式\nnpm link  # 将当前npm工程本地全局发布\nnpm link <package-name>  # 在其他工程目录下通过该命令引用\n\n# 方式2：离线包形式\nnpm pack  # 将当前npm工程打包为一个tgz\ncp /path/to/<package>.tgz .  # 在其他工程目录下通过该命令集成\n# 修改package.json，指定<package-name>: <package>.tgz\n```\n\nnpm包安装过程解读：[How npm install Works Internally? - DEV Community](https://dev.to/shree_j/how-npm-works-internally-4012)\n\nnpm包工作的核心文件是package.json，该文件内定义了npm如何对该包进行操作，包括install、serve、test等。\n\n如果没有特别说明，包内index.js为npm包的入口（entrypoint），新包发布所能使用的功能函数统一从这里出口（export）\n\n**了解这些背景知识后，我们看下有哪些情况npm包在安装时会触发兼容性问题**\n\n**案例1：**[Npm install 2.8.2 fails on ARM64, asks to upgrade to 2.5.1 or later - core - Meteor.js forums](https://forums.meteor.com/t/npm-install-2-8-2-fails-on-arm64-asks-to-upgrade-to-2-5-1-or-later/59177/4)\n\n该案例里npm包内具有平台检测硬编码，之所以做这类平台限制，是因为该包依赖了mongodb，而mongodb是平台相关，为适配arm，做了如下修复：\n\n[Support ARM on Linux by aquinoit · Pull Request #12160 · meteor/meteor (github.com)](https://github.com/meteor/meteor/pull/12160/files#diff-e139871b4a22b32fdb9a795e1ac8ee683d848695e01d8b170e168534ef63d6c8)\n\n![image-20230611113916798](/images/编程语言兼容性/image-20230611113916798.png)\n\n**案例2：**[Unable to `npm install` on M1 · Issue #668 · twilio/twilio-video-app-react (github.com)](https://github.com/twilio/twilio-video-app-react/issues/668)\n\n该报错是因为npm安装过程中apt install chromium-browser命令执行失败导致，最后通过手动补全chromium依赖解决。\n\n结合以上案例可以得出，npm包在安装过程中体现的兼容性问题，取决于npm包安装脚本是否有外界依赖引入。\n\n**兼容性识别关键点：直接跑一遍npm install来检验**\n\n\n\n### python\n\n#### 代码调用c\n\n这篇文章介绍了各种python调用c的方法，并给出了优劣势对比：[Python Bindings: Calling C or C++ From Python – Real Python](https://realpython.com/python-bindings-overview/)\n\nctypes内置包会处理所有跟c、so的交互：\n\n```python\nfrom ctypes import *\n# either\nlibc = cdll.LoadLibrary(\"libc.so.6\")\n# or\nlibc = CDLL(\"libc.so.6\")\n```\n\n**兼容性识别关键点：识别源码中是否带有so名称，编译好的包是否具有so。**\n\n### wheel包\n\n**wheel包背景知识**\n\n和npm包一样，wheel包也有一个类似package.json的核心文件来承载包的元数据信息，该核心文件有一个演进史：\n\n[What's the difference between setup.py and setup.cfg in python projects - Stack Overflow](https://stackoverflow.com/questions/39484863/whats-the-difference-between-setup-py-and-setup-cfg-in-python-projects)\n\n最开始是setup.py，然后是setup.cfg，再到现在则为pyproject.toml\n\n打包wheel的命令也有很多种，如build、wheel工具等，示例参考：[How to Create Python Packages | Towards Data Science](https://towardsdatascience.com/how-to-package-your-python-code-df5a7739ab2e)\n\n**wheel包安装兼容性问题**\n\n安装过程触发本地编译，通过setup.py：\n\n![image-20230611121349952](/images/编程语言兼容性/image-20230611121349952.png)\n\n此时如果setup.py过程对平台有依赖，就会报错。\n\n同npm包，wheel包安装失败的原因仅有可能是引入了外部依赖。\n\n**兼容性识别关键点：直接跑一遍pip install来检验**\n\n\n\n## java\n\njava调用so的方式是通过JNI或JNA。\n\n### jni\n\nJNI用法：[Call c function from Java - Stack Overflow](https://stackoverflow.com/questions/5963266/call-c-function-from-java)\n\n```java\nclass HelloWorld {\n    private native void print();  // 声明c方法\n\n    public static void main(String[] args) {\n        new HelloWorld().print();\n    }\n\n    static {\n        System.loadLibrary(\"HelloWorld\");  // 加载HelloWorld.so库\n    }\n}\n```\n\n这里还包含怎么编译so库出来的问题，详细见上述链接。\n\n**兼容性识别关键点：native、System.loadLibrary关键字**\n\n### jna\n\nJNA方法：[jna/GettingStarted.md at master · java-native-access/jna · GitHub](https://github.com/java-native-access/jna/blob/master/www/GettingStarted.md)\n\n```java\npackage com.sun.jna.examples;\n\nimport com.sun.jna.Library;\nimport com.sun.jna.Native;\nimport com.sun.jna.Platform;\n\n/** Simple example of JNA interface mapping and usage. */\npublic class HelloWorld {\n\n    // This is the standard, stable way of mapping, which supports extensive\n    // customization and mapping of Java to native types.\n\n    public interface CLibrary extends Library {\n        CLibrary INSTANCE = (CLibrary)\n            Native.load((Platform.isWindows() ? \"msvcrt\" : \"c\"),\n                                CLibrary.class);\n\n        void printf(String format, Object... args);\n    }\n\n    public static void main(String[] args) {\n        CLibrary.INSTANCE.printf(\"Hello, World\\n\");\n        for (int i=0;i < args.length;i++) {\n            CLibrary.INSTANCE.printf(\"Argument %d: %s\\n\", i, args[i]);\n        }\n    }\n```\n\n**兼容性识别关键点：是否引用了jna依赖。**\n\n### 其他jvm系语言\n\n其他基于java虚拟机开发的语言调用so方法和上述类似，均通过java官方的JNI或JNA方法：\n\n- scala：[scala c integration - Stack Overflow](https://stackoverflow.com/questions/6286044/scala-c-integration)\n- kotlin：[Calling C function from Kotlin using JNI - Stack Overflow](https://stackoverflow.com/questions/72646387/calling-c-function-from-kotlin-using-jni)\n- groovy：[java - Call C API from Groovy - Stack Overflow](https://stackoverflow.com/questions/1105211/call-c-api-from-groovy?rq=4)\n- clojure：[Calling C++ from clojure - Stack Overflow](https://stackoverflow.com/questions/53359255/calling-c-from-clojure)\n\n\n\n## perl\n\nperl语言的特点跟python类似，也是一种脚本解释语言。\n\n### 代码调用c\n\nperl调用c的方法如下：[How do I call a C function from a Perl program? - Stack Overflow](https://stackoverflow.com/questions/15136890/how-do-i-call-a-c-function-from-a-perl-program)\n\n```perl\nuse Inline C => <<'__END_OF_C__';\n\n    int sum(int a, int b)\n    {\n        return (a+b);\n    }\n\n__END_OF_C__\n\nsay sum($x,$y);\n```\n\n\n\n## ruby\n\nruby也是一种解释型语言。\n\n### 代码调用c\n\nruby调用c的方式是通过`rb_define_method`方法：[How to create a Ruby extension in C in under 5 minutes (rubyinside.com)](http://www.rubyinside.com/how-to-create-a-ruby-extension-in-c-in-under-5-minutes-100.html)\n\n```ruby\n// Include the Ruby headers and goodies\n#include \"ruby.h\"\n\n// Defining a space for information and references about the module to be stored internally\nVALUE MyTest = Qnil;\n\n// Prototype for the initialization method - Ruby calls this, not you\nvoid Init_mytest();\n\n// Prototype for our method 'test1' - methods are prefixed by 'method_' here\nVALUE method_test1(VALUE self);\n\n// The initialization method for this module\nvoid Init_mytest() {\n\tMyTest = rb_define_module(\"MyTest\");  // 定义c模块\n\trb_define_method(MyTest, \"test1\", method_test1, 0);  // 定义c方法\n}\n\n// Our 'test1' method.. it simply returns a value of '10' for now.\nVALUE method_test1(VALUE self) {\n\tint x = 10;\n\treturn INT2NUM(x);\n}\n```\n\n\n\n### 代码调用so\n\nruby调用so的方式通过借助ffi：[Calling C shared libraries with ruby FFI (jertype.com)](https://www.jertype.com/calling-c-shared-library/)\n\n```ruby\nrequire 'ffi'\n\nmodule ConcatInterop\n  extend FFI::Library\n\n  ffi_lib './concat.so'\n  attach_function :concat, [:string, :string, :pointer], :void\nend\n```\n\n\n\n## lua\n\nlua也是一种解释型语言。\n\n### 代码调用c\n\nlua调用c的方式是通过`lua_CFunction`方法：[How would I make a C-function that I can call from Lua? - Stack Overflow](https://stackoverflow.com/questions/4190697/how-would-i-make-a-c-function-that-i-can-call-from-lua)\n\n### 代码调用so\n\nlua调用so的方式是通过ffi：[ffi - How to call a function in shared library using Lua - Stack Overflow](https://stackoverflow.com/questions/37876215/how-to-call-a-function-in-shared-library-using-lua)\n\n```lua\nlocal lib = ffi.load('some.dll')\nffi.cdef[[\n  void hello (void);\n]]\nlib.hello()\n```\n\n\n\n## php\n\nphp想要调用c或so的话，就不是在php内声明c函数签名的方式了，而是通过编写php extension：[Is it possible to call C code from php - Stack Overflow](https://stackoverflow.com/questions/3125388/is-it-possible-to-call-c-code-from-php)\n\n\n\n## c/c++/fortran/rust/go\n\n这些语言就都是编译型语言了，编译型语言一定是平台相关，意味着不存在出一个包就能达成跨平台的效果，故此类软件一定要做迁移。\n\n对于编译型语言，兼容性主要体现在编译过程，如：\n\n- 按照默认的readme、官方文档编译步骤，编译过程是否顺畅？\n- 是否存在某个平台相关选项导致编译失败？\n\n","slug":"编程语言兼容性","published":1,"updated":"2024-08-18T08:50:22.844Z","_id":"clvp3gte100010cpv9w2j4864","comments":1,"layout":"post","photos":[],"content":"<p>本文要讨论的兼容性是指上层应用软件对不同架构芯片及各类板卡硬件的兼容性。本文将聚焦于各类编程语言的兼容性都是怎么引入的，以便于为后续对拓展平台软件生态需要做哪些工作提供一些指导。</p>\n<span id=\"more\"></span>\n\n<p><strong>什么样的软件具有好的兼容性？</strong></p>\n<p>对于一款软件，如果能够提供不同平台的二进制、或者仅提供一个二进制就能够在不同平台上跑，那么说明这款软件的兼容性很完备。但实际上受限于编程语言本身的能力、性能等约束，想达到这种目标往往比较困难。</p>\n<p><strong>什么时候会出现兼容性问题？</strong></p>\n<ul>\n<li>当代码中硬编码了汇编语言</li>\n<li>当代码中调用了so库，而该so库还被打包到最终的可运行包里</li>\n<li>当代码中调用了so库，且该so库是由软件源码包中的c&#x2F;c++等待编译文件编译出来的</li>\n</ul>\n<p>以上这些情况均会导致软件与平台相关，进而导致软件必须提供不同平台编译版本才能满足软件在指定平台的可运行。</p>\n<p>只要软件和平台相关，那么当指定平台缺少该软件的预编译包时，整个上层应用在该平台上的安装就会失败，从而带来不好的兼容性体验。</p>\n<p><strong>那么，如何评价一款软件在给定平台的兼容性情况？</strong></p>\n<p>首先需要明确的是，兼容性达成情况是一个bool类型。软件是否兼容与软件有多么不兼容，后者会影响到你去做迁移适配的动作吗？难道软件严重不兼容就不做平台适配了？并不是的，对于给定的平台，我们想让软件跑起来，无论它具有多少不兼容代码，都得一一解决。唯有此，才能达成软件运行的目的。所以，评价软件兼容性是一个非黑即白的结论。</p>\n<p><strong>如何识别软件是否需要做兼容性？</strong></p>\n<ul>\n<li>分析源码</li>\n<li>直接在指定平台上编译运行</li>\n</ul>\n<p>针对第一点，以下挑选了top流行语言来列举各种可能存在的硬件兼容性情况。</p>\n<h2 id=\"javascript\"><a href=\"#javascript\" class=\"headerlink\" title=\"javascript\"></a>javascript</h2><h3 id=\"代码调用so\"><a href=\"#代码调用so\" class=\"headerlink\" title=\"代码调用so\"></a>代码调用so</h3><p>javascript调用so，使用node-ffi包：<a href=\"https://github.com/node-ffi/node-ffi\">node-ffi&#x2F;node-ffi: Node.js Foreign Function Interface (github.com)</a></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> ffi = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;ffi&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> libm = ffi.<span class=\"title class_\">Library</span>(<span class=\"string\">&#x27;libm&#x27;</span>, &#123;</span><br><span class=\"line\">  <span class=\"string\">&#x27;ceil&#x27;</span>: [ <span class=\"string\">&#x27;double&#x27;</span>, [ <span class=\"string\">&#x27;double&#x27;</span> ] ]</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">libm.<span class=\"title function_\">ceil</span>(<span class=\"number\">1.5</span>); <span class=\"comment\">// 2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// You can also access just functions in the current process by passing a null</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> current = ffi.<span class=\"title class_\">Library</span>(<span class=\"literal\">null</span>, &#123;</span><br><span class=\"line\">  <span class=\"string\">&#x27;atoi&#x27;</span>: [ <span class=\"string\">&#x27;int&#x27;</span>, [ <span class=\"string\">&#x27;string&#x27;</span> ] ]</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">current.<span class=\"title function_\">atoi</span>(<span class=\"string\">&#x27;1234&#x27;</span>); <span class=\"comment\">// 1234</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>兼容性识别关键点：检查编译后的包是否包含so。</strong></p>\n<h3 id=\"代码包含c-c\"><a href=\"#代码包含c-c\" class=\"headerlink\" title=\"代码包含c&#x2F;c++\"></a>代码包含c&#x2F;c++</h3><p>有些javascript包中带有其他编程语言，比如node-ffi：<a href=\"https://api.github.com/repos/node-ffi/node-ffi/languages\">https://api.github.com/repos/node-ffi/node-ffi/languages</a></p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;JavaScript&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">65311</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;C++&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">35850</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;C&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">1364</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;Python&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">921</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>可以看到，js包里面具有c&#x2F;c++编译型语言，这种包自然会导致平台兼容性问题。</p>\n<p><strong>兼容性识别关键点：检查源码中是否包含编译型语言。</strong></p>\n<h3 id=\"assembly技术\"><a href=\"#assembly技术\" class=\"headerlink\" title=\"assembly技术\"></a>assembly技术</h3><p>javascript运行会被浏览器翻译为assembly中间机器语言，这里的机器语言并非CPU相关，真正运行还要再转义一次。</p>\n<p>这篇文章以一种自定义的JS-ASM来描绘java assembly是怎么工作的：<a href=\"https://www.codeproject.com/Articles/417071/JavaScript-Assembler-Language-Specification-JS-ASM\">JavaScript Assembler Language Specification (JS-ASM) - CodeProject</a></p>\n<h3 id=\"npm包\"><a href=\"#npm包\" class=\"headerlink\" title=\"npm包\"></a>npm包</h3><p><strong>npm包背景知识</strong></p>\n<p>npm包制作和发布参考：<a href=\"https://www.freecodecamp.org/news/how-to-create-and-publish-your-first-npm-package/\">How to Create and Publish an NPM Package – a Step-by-Step Guide (freecodecamp.org)</a></p>\n<p>制作npm包有两种方式：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 方式1：link形式</span></span><br><span class=\"line\">npm <span class=\"built_in\">link</span>  <span class=\"comment\"># 将当前npm工程本地全局发布</span></span><br><span class=\"line\">npm <span class=\"built_in\">link</span> &lt;package-name&gt;  <span class=\"comment\"># 在其他工程目录下通过该命令引用</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 方式2：离线包形式</span></span><br><span class=\"line\">npm pack  <span class=\"comment\"># 将当前npm工程打包为一个tgz</span></span><br><span class=\"line\"><span class=\"built_in\">cp</span> /path/to/&lt;package&gt;.tgz .  <span class=\"comment\"># 在其他工程目录下通过该命令集成</span></span><br><span class=\"line\"><span class=\"comment\"># 修改package.json，指定&lt;package-name&gt;: &lt;package&gt;.tgz</span></span><br></pre></td></tr></table></figure>\n\n<p>npm包安装过程解读：<a href=\"https://dev.to/shree_j/how-npm-works-internally-4012\">How npm install Works Internally? - DEV Community</a></p>\n<p>npm包工作的核心文件是package.json，该文件内定义了npm如何对该包进行操作，包括install、serve、test等。</p>\n<p>如果没有特别说明，包内index.js为npm包的入口（entrypoint），新包发布所能使用的功能函数统一从这里出口（export）</p>\n<p><strong>了解这些背景知识后，我们看下有哪些情况npm包在安装时会触发兼容性问题</strong></p>\n<p><strong>案例1：</strong><a href=\"https://forums.meteor.com/t/npm-install-2-8-2-fails-on-arm64-asks-to-upgrade-to-2-5-1-or-later/59177/4\">Npm install 2.8.2 fails on ARM64, asks to upgrade to 2.5.1 or later - core - Meteor.js forums</a></p>\n<p>该案例里npm包内具有平台检测硬编码，之所以做这类平台限制，是因为该包依赖了mongodb，而mongodb是平台相关，为适配arm，做了如下修复：</p>\n<p><a href=\"https://github.com/meteor/meteor/pull/12160/files#diff-e139871b4a22b32fdb9a795e1ac8ee683d848695e01d8b170e168534ef63d6c8\">Support ARM on Linux by aquinoit · Pull Request #12160 · meteor&#x2F;meteor (github.com)</a></p>\n<p><img src=\"/images/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%85%BC%E5%AE%B9%E6%80%A7/image-20230611113916798.png\" alt=\"image-20230611113916798\"></p>\n<p><strong>案例2：</strong><a href=\"https://github.com/twilio/twilio-video-app-react/issues/668\">Unable to <code>npm install</code> on M1 · Issue #668 · twilio&#x2F;twilio-video-app-react (github.com)</a></p>\n<p>该报错是因为npm安装过程中apt install chromium-browser命令执行失败导致，最后通过手动补全chromium依赖解决。</p>\n<p>结合以上案例可以得出，npm包在安装过程中体现的兼容性问题，取决于npm包安装脚本是否有外界依赖引入。</p>\n<p><strong>兼容性识别关键点：直接跑一遍npm install来检验</strong></p>\n<h3 id=\"python\"><a href=\"#python\" class=\"headerlink\" title=\"python\"></a>python</h3><h4 id=\"代码调用c\"><a href=\"#代码调用c\" class=\"headerlink\" title=\"代码调用c\"></a>代码调用c</h4><p>这篇文章介绍了各种python调用c的方法，并给出了优劣势对比：<a href=\"https://realpython.com/python-bindings-overview/\">Python Bindings: Calling C or C++ From Python – Real Python</a></p>\n<p>ctypes内置包会处理所有跟c、so的交互：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> ctypes <span class=\"keyword\">import</span> *</span><br><span class=\"line\"><span class=\"comment\"># either</span></span><br><span class=\"line\">libc = cdll.LoadLibrary(<span class=\"string\">&quot;libc.so.6&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\"># or</span></span><br><span class=\"line\">libc = CDLL(<span class=\"string\">&quot;libc.so.6&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<p><strong>兼容性识别关键点：识别源码中是否带有so名称，编译好的包是否具有so。</strong></p>\n<h3 id=\"wheel包\"><a href=\"#wheel包\" class=\"headerlink\" title=\"wheel包\"></a>wheel包</h3><p><strong>wheel包背景知识</strong></p>\n<p>和npm包一样，wheel包也有一个类似package.json的核心文件来承载包的元数据信息，该核心文件有一个演进史：</p>\n<p><a href=\"https://stackoverflow.com/questions/39484863/whats-the-difference-between-setup-py-and-setup-cfg-in-python-projects\">What’s the difference between setup.py and setup.cfg in python projects - Stack Overflow</a></p>\n<p>最开始是setup.py，然后是setup.cfg，再到现在则为pyproject.toml</p>\n<p>打包wheel的命令也有很多种，如build、wheel工具等，示例参考：<a href=\"https://towardsdatascience.com/how-to-package-your-python-code-df5a7739ab2e\">How to Create Python Packages | Towards Data Science</a></p>\n<p><strong>wheel包安装兼容性问题</strong></p>\n<p>安装过程触发本地编译，通过setup.py：</p>\n<p><img src=\"/images/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%85%BC%E5%AE%B9%E6%80%A7/image-20230611121349952.png\" alt=\"image-20230611121349952\"></p>\n<p>此时如果setup.py过程对平台有依赖，就会报错。</p>\n<p>同npm包，wheel包安装失败的原因仅有可能是引入了外部依赖。</p>\n<p><strong>兼容性识别关键点：直接跑一遍pip install来检验</strong></p>\n<h2 id=\"java\"><a href=\"#java\" class=\"headerlink\" title=\"java\"></a>java</h2><p>java调用so的方式是通过JNI或JNA。</p>\n<h3 id=\"jni\"><a href=\"#jni\" class=\"headerlink\" title=\"jni\"></a>jni</h3><p>JNI用法：<a href=\"https://stackoverflow.com/questions/5963266/call-c-function-from-java\">Call c function from Java - Stack Overflow</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">HelloWorld</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">native</span> <span class=\"keyword\">void</span> <span class=\"title function_\">print</span><span class=\"params\">()</span>;  <span class=\"comment\">// 声明c方法</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">HelloWorld</span>().print();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        System.loadLibrary(<span class=\"string\">&quot;HelloWorld&quot;</span>);  <span class=\"comment\">// 加载HelloWorld.so库</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里还包含怎么编译so库出来的问题，详细见上述链接。</p>\n<p><strong>兼容性识别关键点：native、System.loadLibrary关键字</strong></p>\n<h3 id=\"jna\"><a href=\"#jna\" class=\"headerlink\" title=\"jna\"></a>jna</h3><p>JNA方法：<a href=\"https://github.com/java-native-access/jna/blob/master/www/GettingStarted.md\">jna&#x2F;GettingStarted.md at master · java-native-access&#x2F;jna · GitHub</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.sun.jna.examples;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.sun.jna.Library;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.sun.jna.Native;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.sun.jna.Platform;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** Simple example of JNA interface mapping and usage. */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">HelloWorld</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// This is the standard, stable way of mapping, which supports extensive</span></span><br><span class=\"line\">    <span class=\"comment\">// customization and mapping of Java to native types.</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">CLibrary</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Library</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">CLibrary</span> <span class=\"variable\">INSTANCE</span> <span class=\"operator\">=</span> (CLibrary)</span><br><span class=\"line\">            Native.load((Platform.isWindows() ? <span class=\"string\">&quot;msvcrt&quot;</span> : <span class=\"string\">&quot;c&quot;</span>),</span><br><span class=\"line\">                                CLibrary.class);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">void</span> <span class=\"title function_\">printf</span><span class=\"params\">(String format, Object... args)</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        CLibrary.INSTANCE.printf(<span class=\"string\">&quot;Hello, World\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i &lt; args.length;i++) &#123;</span><br><span class=\"line\">            CLibrary.INSTANCE.printf(<span class=\"string\">&quot;Argument %d: %s\\n&quot;</span>, i, args[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>兼容性识别关键点：是否引用了jna依赖。</strong></p>\n<h3 id=\"其他jvm系语言\"><a href=\"#其他jvm系语言\" class=\"headerlink\" title=\"其他jvm系语言\"></a>其他jvm系语言</h3><p>其他基于java虚拟机开发的语言调用so方法和上述类似，均通过java官方的JNI或JNA方法：</p>\n<ul>\n<li>scala：<a href=\"https://stackoverflow.com/questions/6286044/scala-c-integration\">scala c integration - Stack Overflow</a></li>\n<li>kotlin：<a href=\"https://stackoverflow.com/questions/72646387/calling-c-function-from-kotlin-using-jni\">Calling C function from Kotlin using JNI - Stack Overflow</a></li>\n<li>groovy：<a href=\"https://stackoverflow.com/questions/1105211/call-c-api-from-groovy?rq=4\">java - Call C API from Groovy - Stack Overflow</a></li>\n<li>clojure：<a href=\"https://stackoverflow.com/questions/53359255/calling-c-from-clojure\">Calling C++ from clojure - Stack Overflow</a></li>\n</ul>\n<h2 id=\"perl\"><a href=\"#perl\" class=\"headerlink\" title=\"perl\"></a>perl</h2><p>perl语言的特点跟python类似，也是一种脚本解释语言。</p>\n<h3 id=\"代码调用c-1\"><a href=\"#代码调用c-1\" class=\"headerlink\" title=\"代码调用c\"></a>代码调用c</h3><p>perl调用c的方法如下：<a href=\"https://stackoverflow.com/questions/15136890/how-do-i-call-a-c-function-from-a-perl-program\">How do I call a C function from a Perl program? - Stack Overflow</a></p>\n<figure class=\"highlight perl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> Inline <span class=\"string\">C =&gt;</span> &lt;&lt;<span class=\"string\">&#x27;__END_OF_C__&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> sum(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (a+b);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">__END_OF_C_<span class=\"number\">_</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">say</span> sum($x,$y);</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"ruby\"><a href=\"#ruby\" class=\"headerlink\" title=\"ruby\"></a>ruby</h2><p>ruby也是一种解释型语言。</p>\n<h3 id=\"代码调用c-2\"><a href=\"#代码调用c-2\" class=\"headerlink\" title=\"代码调用c\"></a>代码调用c</h3><p>ruby调用c的方式是通过<code>rb_define_method</code>方法：<a href=\"http://www.rubyinside.com/how-to-create-a-ruby-extension-in-c-in-under-5-minutes-100.html\">How to create a Ruby extension in C in under 5 minutes (rubyinside.com)</a></p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/<span class=\"regexp\">/ Include the Ruby headers and goodies</span></span><br><span class=\"line\"><span class=\"regexp\">#include &quot;ruby.h&quot;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">/</span><span class=\"regexp\">/ Defining a space for information and references about the module to be stored internally</span></span><br><span class=\"line\"><span class=\"regexp\">VALUE MyTest = Qnil;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">/</span><span class=\"regexp\">/ Prototype for the initialization method - Ruby calls this, not you</span></span><br><span class=\"line\"><span class=\"regexp\">void Init_mytest();</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">/</span><span class=\"regexp\">/ Prototype for our method &#x27;test1&#x27; - methods are prefixed by &#x27;method_&#x27; here</span></span><br><span class=\"line\"><span class=\"regexp\">VALUE method_test1(VALUE self);</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">/</span><span class=\"regexp\">/ The initialization method for this module</span></span><br><span class=\"line\"><span class=\"regexp\">void Init_mytest() &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">\tMyTest = rb_define_module(&quot;MyTest&quot;);  /</span><span class=\"regexp\">/ 定义c模块</span></span><br><span class=\"line\"><span class=\"regexp\">\trb_define_method(MyTest, &quot;test1&quot;, method_test1, 0);  /</span><span class=\"regexp\">/ 定义c方法</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">/</span><span class=\"regexp\">/ Our &#x27;test1&#x27; method.. it simply returns a value of &#x27;10&#x27; for now.</span></span><br><span class=\"line\"><span class=\"regexp\">VALUE method_test1(VALUE self) &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">\tint x = 10;</span></span><br><span class=\"line\"><span class=\"regexp\">\treturn INT2NUM(x);</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"代码调用so-1\"><a href=\"#代码调用so-1\" class=\"headerlink\" title=\"代码调用so\"></a>代码调用so</h3><p>ruby调用so的方式通过借助ffi：<a href=\"https://www.jertype.com/calling-c-shared-library/\">Calling C shared libraries with ruby FFI (jertype.com)</a></p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">require</span> <span class=\"string\">&#x27;ffi&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">module</span> <span class=\"title class_\">ConcatInterop</span></span><br><span class=\"line\">  <span class=\"keyword\">extend</span> <span class=\"variable constant_\">FFI</span><span class=\"symbol\">:</span><span class=\"symbol\">:Library</span></span><br><span class=\"line\"></span><br><span class=\"line\">  ffi_lib <span class=\"string\">&#x27;./concat.so&#x27;</span></span><br><span class=\"line\">  attach_function <span class=\"symbol\">:concat</span>, [<span class=\"symbol\">:string</span>, <span class=\"symbol\">:string</span>, <span class=\"symbol\">:pointer</span>], <span class=\"symbol\">:void</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"lua\"><a href=\"#lua\" class=\"headerlink\" title=\"lua\"></a>lua</h2><p>lua也是一种解释型语言。</p>\n<h3 id=\"代码调用c-3\"><a href=\"#代码调用c-3\" class=\"headerlink\" title=\"代码调用c\"></a>代码调用c</h3><p>lua调用c的方式是通过<code>lua_CFunction</code>方法：<a href=\"https://stackoverflow.com/questions/4190697/how-would-i-make-a-c-function-that-i-can-call-from-lua\">How would I make a C-function that I can call from Lua? - Stack Overflow</a></p>\n<h3 id=\"代码调用so-2\"><a href=\"#代码调用so-2\" class=\"headerlink\" title=\"代码调用so\"></a>代码调用so</h3><p>lua调用so的方式是通过ffi：<a href=\"https://stackoverflow.com/questions/37876215/how-to-call-a-function-in-shared-library-using-lua\">ffi - How to call a function in shared library using Lua - Stack Overflow</a></p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">local</span> lib = ffi.<span class=\"built_in\">load</span>(<span class=\"string\">&#x27;some.dll&#x27;</span>)</span><br><span class=\"line\">ffi.cdef<span class=\"string\">[[</span></span><br><span class=\"line\"><span class=\"string\">  void hello (void);</span></span><br><span class=\"line\"><span class=\"string\">]]</span></span><br><span class=\"line\">lib.hello()</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"php\"><a href=\"#php\" class=\"headerlink\" title=\"php\"></a>php</h2><p>php想要调用c或so的话，就不是在php内声明c函数签名的方式了，而是通过编写php extension：<a href=\"https://stackoverflow.com/questions/3125388/is-it-possible-to-call-c-code-from-php\">Is it possible to call C code from php - Stack Overflow</a></p>\n<h2 id=\"c-c-fortran-rust-go\"><a href=\"#c-c-fortran-rust-go\" class=\"headerlink\" title=\"c&#x2F;c++&#x2F;fortran&#x2F;rust&#x2F;go\"></a>c&#x2F;c++&#x2F;fortran&#x2F;rust&#x2F;go</h2><p>这些语言就都是编译型语言了，编译型语言一定是平台相关，意味着不存在出一个包就能达成跨平台的效果，故此类软件一定要做迁移。</p>\n<p>对于编译型语言，兼容性主要体现在编译过程，如：</p>\n<ul>\n<li>按照默认的readme、官方文档编译步骤，编译过程是否顺畅？</li>\n<li>是否存在某个平台相关选项导致编译失败？</li>\n</ul>\n","excerpt":"<p>本文要讨论的兼容性是指上层应用软件对不同架构芯片及各类板卡硬件的兼容性。本文将聚焦于各类编程语言的兼容性都是怎么引入的，以便于为后续对拓展平台软件生态需要做哪些工作提供一些指导。</p>","more":"<p><strong>什么样的软件具有好的兼容性？</strong></p>\n<p>对于一款软件，如果能够提供不同平台的二进制、或者仅提供一个二进制就能够在不同平台上跑，那么说明这款软件的兼容性很完备。但实际上受限于编程语言本身的能力、性能等约束，想达到这种目标往往比较困难。</p>\n<p><strong>什么时候会出现兼容性问题？</strong></p>\n<ul>\n<li>当代码中硬编码了汇编语言</li>\n<li>当代码中调用了so库，而该so库还被打包到最终的可运行包里</li>\n<li>当代码中调用了so库，且该so库是由软件源码包中的c&#x2F;c++等待编译文件编译出来的</li>\n</ul>\n<p>以上这些情况均会导致软件与平台相关，进而导致软件必须提供不同平台编译版本才能满足软件在指定平台的可运行。</p>\n<p>只要软件和平台相关，那么当指定平台缺少该软件的预编译包时，整个上层应用在该平台上的安装就会失败，从而带来不好的兼容性体验。</p>\n<p><strong>那么，如何评价一款软件在给定平台的兼容性情况？</strong></p>\n<p>首先需要明确的是，兼容性达成情况是一个bool类型。软件是否兼容与软件有多么不兼容，后者会影响到你去做迁移适配的动作吗？难道软件严重不兼容就不做平台适配了？并不是的，对于给定的平台，我们想让软件跑起来，无论它具有多少不兼容代码，都得一一解决。唯有此，才能达成软件运行的目的。所以，评价软件兼容性是一个非黑即白的结论。</p>\n<p><strong>如何识别软件是否需要做兼容性？</strong></p>\n<ul>\n<li>分析源码</li>\n<li>直接在指定平台上编译运行</li>\n</ul>\n<p>针对第一点，以下挑选了top流行语言来列举各种可能存在的硬件兼容性情况。</p>\n<h2 id=\"javascript\"><a href=\"#javascript\" class=\"headerlink\" title=\"javascript\"></a>javascript</h2><h3 id=\"代码调用so\"><a href=\"#代码调用so\" class=\"headerlink\" title=\"代码调用so\"></a>代码调用so</h3><p>javascript调用so，使用node-ffi包：<a href=\"https://github.com/node-ffi/node-ffi\">node-ffi&#x2F;node-ffi: Node.js Foreign Function Interface (github.com)</a></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> ffi = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;ffi&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> libm = ffi.<span class=\"title class_\">Library</span>(<span class=\"string\">&#x27;libm&#x27;</span>, &#123;</span><br><span class=\"line\">  <span class=\"string\">&#x27;ceil&#x27;</span>: [ <span class=\"string\">&#x27;double&#x27;</span>, [ <span class=\"string\">&#x27;double&#x27;</span> ] ]</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">libm.<span class=\"title function_\">ceil</span>(<span class=\"number\">1.5</span>); <span class=\"comment\">// 2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// You can also access just functions in the current process by passing a null</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> current = ffi.<span class=\"title class_\">Library</span>(<span class=\"literal\">null</span>, &#123;</span><br><span class=\"line\">  <span class=\"string\">&#x27;atoi&#x27;</span>: [ <span class=\"string\">&#x27;int&#x27;</span>, [ <span class=\"string\">&#x27;string&#x27;</span> ] ]</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">current.<span class=\"title function_\">atoi</span>(<span class=\"string\">&#x27;1234&#x27;</span>); <span class=\"comment\">// 1234</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>兼容性识别关键点：检查编译后的包是否包含so。</strong></p>\n<h3 id=\"代码包含c-c\"><a href=\"#代码包含c-c\" class=\"headerlink\" title=\"代码包含c&#x2F;c++\"></a>代码包含c&#x2F;c++</h3><p>有些javascript包中带有其他编程语言，比如node-ffi：<a href=\"https://api.github.com/repos/node-ffi/node-ffi/languages\">https://api.github.com/repos/node-ffi/node-ffi/languages</a></p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;JavaScript&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">65311</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;C++&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">35850</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;C&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">1364</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;Python&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">921</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>可以看到，js包里面具有c&#x2F;c++编译型语言，这种包自然会导致平台兼容性问题。</p>\n<p><strong>兼容性识别关键点：检查源码中是否包含编译型语言。</strong></p>\n<h3 id=\"assembly技术\"><a href=\"#assembly技术\" class=\"headerlink\" title=\"assembly技术\"></a>assembly技术</h3><p>javascript运行会被浏览器翻译为assembly中间机器语言，这里的机器语言并非CPU相关，真正运行还要再转义一次。</p>\n<p>这篇文章以一种自定义的JS-ASM来描绘java assembly是怎么工作的：<a href=\"https://www.codeproject.com/Articles/417071/JavaScript-Assembler-Language-Specification-JS-ASM\">JavaScript Assembler Language Specification (JS-ASM) - CodeProject</a></p>\n<h3 id=\"npm包\"><a href=\"#npm包\" class=\"headerlink\" title=\"npm包\"></a>npm包</h3><p><strong>npm包背景知识</strong></p>\n<p>npm包制作和发布参考：<a href=\"https://www.freecodecamp.org/news/how-to-create-and-publish-your-first-npm-package/\">How to Create and Publish an NPM Package – a Step-by-Step Guide (freecodecamp.org)</a></p>\n<p>制作npm包有两种方式：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 方式1：link形式</span></span><br><span class=\"line\">npm <span class=\"built_in\">link</span>  <span class=\"comment\"># 将当前npm工程本地全局发布</span></span><br><span class=\"line\">npm <span class=\"built_in\">link</span> &lt;package-name&gt;  <span class=\"comment\"># 在其他工程目录下通过该命令引用</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 方式2：离线包形式</span></span><br><span class=\"line\">npm pack  <span class=\"comment\"># 将当前npm工程打包为一个tgz</span></span><br><span class=\"line\"><span class=\"built_in\">cp</span> /path/to/&lt;package&gt;.tgz .  <span class=\"comment\"># 在其他工程目录下通过该命令集成</span></span><br><span class=\"line\"><span class=\"comment\"># 修改package.json，指定&lt;package-name&gt;: &lt;package&gt;.tgz</span></span><br></pre></td></tr></table></figure>\n\n<p>npm包安装过程解读：<a href=\"https://dev.to/shree_j/how-npm-works-internally-4012\">How npm install Works Internally? - DEV Community</a></p>\n<p>npm包工作的核心文件是package.json，该文件内定义了npm如何对该包进行操作，包括install、serve、test等。</p>\n<p>如果没有特别说明，包内index.js为npm包的入口（entrypoint），新包发布所能使用的功能函数统一从这里出口（export）</p>\n<p><strong>了解这些背景知识后，我们看下有哪些情况npm包在安装时会触发兼容性问题</strong></p>\n<p><strong>案例1：</strong><a href=\"https://forums.meteor.com/t/npm-install-2-8-2-fails-on-arm64-asks-to-upgrade-to-2-5-1-or-later/59177/4\">Npm install 2.8.2 fails on ARM64, asks to upgrade to 2.5.1 or later - core - Meteor.js forums</a></p>\n<p>该案例里npm包内具有平台检测硬编码，之所以做这类平台限制，是因为该包依赖了mongodb，而mongodb是平台相关，为适配arm，做了如下修复：</p>\n<p><a href=\"https://github.com/meteor/meteor/pull/12160/files#diff-e139871b4a22b32fdb9a795e1ac8ee683d848695e01d8b170e168534ef63d6c8\">Support ARM on Linux by aquinoit · Pull Request #12160 · meteor&#x2F;meteor (github.com)</a></p>\n<p><img src=\"/images/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%85%BC%E5%AE%B9%E6%80%A7/image-20230611113916798.png\" alt=\"image-20230611113916798\"></p>\n<p><strong>案例2：</strong><a href=\"https://github.com/twilio/twilio-video-app-react/issues/668\">Unable to <code>npm install</code> on M1 · Issue #668 · twilio&#x2F;twilio-video-app-react (github.com)</a></p>\n<p>该报错是因为npm安装过程中apt install chromium-browser命令执行失败导致，最后通过手动补全chromium依赖解决。</p>\n<p>结合以上案例可以得出，npm包在安装过程中体现的兼容性问题，取决于npm包安装脚本是否有外界依赖引入。</p>\n<p><strong>兼容性识别关键点：直接跑一遍npm install来检验</strong></p>\n<h3 id=\"python\"><a href=\"#python\" class=\"headerlink\" title=\"python\"></a>python</h3><h4 id=\"代码调用c\"><a href=\"#代码调用c\" class=\"headerlink\" title=\"代码调用c\"></a>代码调用c</h4><p>这篇文章介绍了各种python调用c的方法，并给出了优劣势对比：<a href=\"https://realpython.com/python-bindings-overview/\">Python Bindings: Calling C or C++ From Python – Real Python</a></p>\n<p>ctypes内置包会处理所有跟c、so的交互：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> ctypes <span class=\"keyword\">import</span> *</span><br><span class=\"line\"><span class=\"comment\"># either</span></span><br><span class=\"line\">libc = cdll.LoadLibrary(<span class=\"string\">&quot;libc.so.6&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\"># or</span></span><br><span class=\"line\">libc = CDLL(<span class=\"string\">&quot;libc.so.6&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<p><strong>兼容性识别关键点：识别源码中是否带有so名称，编译好的包是否具有so。</strong></p>\n<h3 id=\"wheel包\"><a href=\"#wheel包\" class=\"headerlink\" title=\"wheel包\"></a>wheel包</h3><p><strong>wheel包背景知识</strong></p>\n<p>和npm包一样，wheel包也有一个类似package.json的核心文件来承载包的元数据信息，该核心文件有一个演进史：</p>\n<p><a href=\"https://stackoverflow.com/questions/39484863/whats-the-difference-between-setup-py-and-setup-cfg-in-python-projects\">What’s the difference between setup.py and setup.cfg in python projects - Stack Overflow</a></p>\n<p>最开始是setup.py，然后是setup.cfg，再到现在则为pyproject.toml</p>\n<p>打包wheel的命令也有很多种，如build、wheel工具等，示例参考：<a href=\"https://towardsdatascience.com/how-to-package-your-python-code-df5a7739ab2e\">How to Create Python Packages | Towards Data Science</a></p>\n<p><strong>wheel包安装兼容性问题</strong></p>\n<p>安装过程触发本地编译，通过setup.py：</p>\n<p><img src=\"/images/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%85%BC%E5%AE%B9%E6%80%A7/image-20230611121349952.png\" alt=\"image-20230611121349952\"></p>\n<p>此时如果setup.py过程对平台有依赖，就会报错。</p>\n<p>同npm包，wheel包安装失败的原因仅有可能是引入了外部依赖。</p>\n<p><strong>兼容性识别关键点：直接跑一遍pip install来检验</strong></p>\n<h2 id=\"java\"><a href=\"#java\" class=\"headerlink\" title=\"java\"></a>java</h2><p>java调用so的方式是通过JNI或JNA。</p>\n<h3 id=\"jni\"><a href=\"#jni\" class=\"headerlink\" title=\"jni\"></a>jni</h3><p>JNI用法：<a href=\"https://stackoverflow.com/questions/5963266/call-c-function-from-java\">Call c function from Java - Stack Overflow</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">HelloWorld</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">native</span> <span class=\"keyword\">void</span> <span class=\"title function_\">print</span><span class=\"params\">()</span>;  <span class=\"comment\">// 声明c方法</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">HelloWorld</span>().print();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        System.loadLibrary(<span class=\"string\">&quot;HelloWorld&quot;</span>);  <span class=\"comment\">// 加载HelloWorld.so库</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里还包含怎么编译so库出来的问题，详细见上述链接。</p>\n<p><strong>兼容性识别关键点：native、System.loadLibrary关键字</strong></p>\n<h3 id=\"jna\"><a href=\"#jna\" class=\"headerlink\" title=\"jna\"></a>jna</h3><p>JNA方法：<a href=\"https://github.com/java-native-access/jna/blob/master/www/GettingStarted.md\">jna&#x2F;GettingStarted.md at master · java-native-access&#x2F;jna · GitHub</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.sun.jna.examples;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.sun.jna.Library;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.sun.jna.Native;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.sun.jna.Platform;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** Simple example of JNA interface mapping and usage. */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">HelloWorld</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// This is the standard, stable way of mapping, which supports extensive</span></span><br><span class=\"line\">    <span class=\"comment\">// customization and mapping of Java to native types.</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">CLibrary</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Library</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">CLibrary</span> <span class=\"variable\">INSTANCE</span> <span class=\"operator\">=</span> (CLibrary)</span><br><span class=\"line\">            Native.load((Platform.isWindows() ? <span class=\"string\">&quot;msvcrt&quot;</span> : <span class=\"string\">&quot;c&quot;</span>),</span><br><span class=\"line\">                                CLibrary.class);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">void</span> <span class=\"title function_\">printf</span><span class=\"params\">(String format, Object... args)</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        CLibrary.INSTANCE.printf(<span class=\"string\">&quot;Hello, World\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i &lt; args.length;i++) &#123;</span><br><span class=\"line\">            CLibrary.INSTANCE.printf(<span class=\"string\">&quot;Argument %d: %s\\n&quot;</span>, i, args[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>兼容性识别关键点：是否引用了jna依赖。</strong></p>\n<h3 id=\"其他jvm系语言\"><a href=\"#其他jvm系语言\" class=\"headerlink\" title=\"其他jvm系语言\"></a>其他jvm系语言</h3><p>其他基于java虚拟机开发的语言调用so方法和上述类似，均通过java官方的JNI或JNA方法：</p>\n<ul>\n<li>scala：<a href=\"https://stackoverflow.com/questions/6286044/scala-c-integration\">scala c integration - Stack Overflow</a></li>\n<li>kotlin：<a href=\"https://stackoverflow.com/questions/72646387/calling-c-function-from-kotlin-using-jni\">Calling C function from Kotlin using JNI - Stack Overflow</a></li>\n<li>groovy：<a href=\"https://stackoverflow.com/questions/1105211/call-c-api-from-groovy?rq=4\">java - Call C API from Groovy - Stack Overflow</a></li>\n<li>clojure：<a href=\"https://stackoverflow.com/questions/53359255/calling-c-from-clojure\">Calling C++ from clojure - Stack Overflow</a></li>\n</ul>\n<h2 id=\"perl\"><a href=\"#perl\" class=\"headerlink\" title=\"perl\"></a>perl</h2><p>perl语言的特点跟python类似，也是一种脚本解释语言。</p>\n<h3 id=\"代码调用c-1\"><a href=\"#代码调用c-1\" class=\"headerlink\" title=\"代码调用c\"></a>代码调用c</h3><p>perl调用c的方法如下：<a href=\"https://stackoverflow.com/questions/15136890/how-do-i-call-a-c-function-from-a-perl-program\">How do I call a C function from a Perl program? - Stack Overflow</a></p>\n<figure class=\"highlight perl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> Inline <span class=\"string\">C =&gt;</span> &lt;&lt;<span class=\"string\">&#x27;__END_OF_C__&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> sum(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (a+b);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">__END_OF_C_<span class=\"number\">_</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">say</span> sum($x,$y);</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"ruby\"><a href=\"#ruby\" class=\"headerlink\" title=\"ruby\"></a>ruby</h2><p>ruby也是一种解释型语言。</p>\n<h3 id=\"代码调用c-2\"><a href=\"#代码调用c-2\" class=\"headerlink\" title=\"代码调用c\"></a>代码调用c</h3><p>ruby调用c的方式是通过<code>rb_define_method</code>方法：<a href=\"http://www.rubyinside.com/how-to-create-a-ruby-extension-in-c-in-under-5-minutes-100.html\">How to create a Ruby extension in C in under 5 minutes (rubyinside.com)</a></p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/<span class=\"regexp\">/ Include the Ruby headers and goodies</span></span><br><span class=\"line\"><span class=\"regexp\">#include &quot;ruby.h&quot;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">/</span><span class=\"regexp\">/ Defining a space for information and references about the module to be stored internally</span></span><br><span class=\"line\"><span class=\"regexp\">VALUE MyTest = Qnil;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">/</span><span class=\"regexp\">/ Prototype for the initialization method - Ruby calls this, not you</span></span><br><span class=\"line\"><span class=\"regexp\">void Init_mytest();</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">/</span><span class=\"regexp\">/ Prototype for our method &#x27;test1&#x27; - methods are prefixed by &#x27;method_&#x27; here</span></span><br><span class=\"line\"><span class=\"regexp\">VALUE method_test1(VALUE self);</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">/</span><span class=\"regexp\">/ The initialization method for this module</span></span><br><span class=\"line\"><span class=\"regexp\">void Init_mytest() &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">\tMyTest = rb_define_module(&quot;MyTest&quot;);  /</span><span class=\"regexp\">/ 定义c模块</span></span><br><span class=\"line\"><span class=\"regexp\">\trb_define_method(MyTest, &quot;test1&quot;, method_test1, 0);  /</span><span class=\"regexp\">/ 定义c方法</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">/</span><span class=\"regexp\">/ Our &#x27;test1&#x27; method.. it simply returns a value of &#x27;10&#x27; for now.</span></span><br><span class=\"line\"><span class=\"regexp\">VALUE method_test1(VALUE self) &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">\tint x = 10;</span></span><br><span class=\"line\"><span class=\"regexp\">\treturn INT2NUM(x);</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"代码调用so-1\"><a href=\"#代码调用so-1\" class=\"headerlink\" title=\"代码调用so\"></a>代码调用so</h3><p>ruby调用so的方式通过借助ffi：<a href=\"https://www.jertype.com/calling-c-shared-library/\">Calling C shared libraries with ruby FFI (jertype.com)</a></p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">require</span> <span class=\"string\">&#x27;ffi&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">module</span> <span class=\"title class_\">ConcatInterop</span></span><br><span class=\"line\">  <span class=\"keyword\">extend</span> <span class=\"variable constant_\">FFI</span><span class=\"symbol\">:</span><span class=\"symbol\">:Library</span></span><br><span class=\"line\"></span><br><span class=\"line\">  ffi_lib <span class=\"string\">&#x27;./concat.so&#x27;</span></span><br><span class=\"line\">  attach_function <span class=\"symbol\">:concat</span>, [<span class=\"symbol\">:string</span>, <span class=\"symbol\">:string</span>, <span class=\"symbol\">:pointer</span>], <span class=\"symbol\">:void</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"lua\"><a href=\"#lua\" class=\"headerlink\" title=\"lua\"></a>lua</h2><p>lua也是一种解释型语言。</p>\n<h3 id=\"代码调用c-3\"><a href=\"#代码调用c-3\" class=\"headerlink\" title=\"代码调用c\"></a>代码调用c</h3><p>lua调用c的方式是通过<code>lua_CFunction</code>方法：<a href=\"https://stackoverflow.com/questions/4190697/how-would-i-make-a-c-function-that-i-can-call-from-lua\">How would I make a C-function that I can call from Lua? - Stack Overflow</a></p>\n<h3 id=\"代码调用so-2\"><a href=\"#代码调用so-2\" class=\"headerlink\" title=\"代码调用so\"></a>代码调用so</h3><p>lua调用so的方式是通过ffi：<a href=\"https://stackoverflow.com/questions/37876215/how-to-call-a-function-in-shared-library-using-lua\">ffi - How to call a function in shared library using Lua - Stack Overflow</a></p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">local</span> lib = ffi.<span class=\"built_in\">load</span>(<span class=\"string\">&#x27;some.dll&#x27;</span>)</span><br><span class=\"line\">ffi.cdef<span class=\"string\">[[</span></span><br><span class=\"line\"><span class=\"string\">  void hello (void);</span></span><br><span class=\"line\"><span class=\"string\">]]</span></span><br><span class=\"line\">lib.hello()</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"php\"><a href=\"#php\" class=\"headerlink\" title=\"php\"></a>php</h2><p>php想要调用c或so的话，就不是在php内声明c函数签名的方式了，而是通过编写php extension：<a href=\"https://stackoverflow.com/questions/3125388/is-it-possible-to-call-c-code-from-php\">Is it possible to call C code from php - Stack Overflow</a></p>\n<h2 id=\"c-c-fortran-rust-go\"><a href=\"#c-c-fortran-rust-go\" class=\"headerlink\" title=\"c&#x2F;c++&#x2F;fortran&#x2F;rust&#x2F;go\"></a>c&#x2F;c++&#x2F;fortran&#x2F;rust&#x2F;go</h2><p>这些语言就都是编译型语言了，编译型语言一定是平台相关，意味着不存在出一个包就能达成跨平台的效果，故此类软件一定要做迁移。</p>\n<p>对于编译型语言，兼容性主要体现在编译过程，如：</p>\n<ul>\n<li>按照默认的readme、官方文档编译步骤，编译过程是否顺畅？</li>\n<li>是否存在某个平台相关选项导致编译失败？</li>\n</ul>"},{"title":"编程语言镜像源","date":"2023-09-03T15:46:00.000Z","toc":true,"_content":"\n本文探索不同编程语言都是如何管理其依赖包的，如何做到快速安装使用？如何为其构建的源做贡献？以及，如果想自定义一个第三方包管理，怎么做？\n\n<!-- more -->\n\n## python\n\n### 自定义包上传官方源\n\n自定义包上传到pypi的教程：[Packaging Python Projects — Python Packaging User Guide](https://packaging.python.org/en/latest/tutorials/packaging-projects/)\n\n通过twine命令。\n\n\n有两点需要注意：\n\n1、需要设置2FA验证后才能生成token。\n\n什么是2FA验证：类似一种动态口令，需要手机扫二维码，获得口令码，再输入验证。\n\n腾讯小程序有一个比较好用的： Authentic\n\n2、如果遇到上传失败，提示403的情况，检查包名是否跟其他人重复：\n\n```bash\nERROR    HTTPError: 403 Forbidden from https://test.pypi.org/legacy/               \n         The user 'wutengda' isn't allowed to upload to project                    \n         'example-package-testing'. See https://test.pypi.org/help/#project-name   \n         for more information. \n```\n\n\n\n上传成功后，就可以使用该命令安装：\n\n```bash\n(venv) wutengda@wutengda:~/packaging_tutorial$ pip install example-package-wutengda\n \nCollecting example-package-wutengda\n  Downloading example_package_wutengda-0.0.1-py3-none-any.whl (2.7 kB)\nInstalling collected packages: example-package-wutengda\nSuccessfully installed example-package-wutengda-0.0.1\n```\n\n\n场景思考：\n\n对于pytorch，在arm上直接使用报没有和cuda联合编译，导致运行失败的情况。此时我们手动编译构建了一个可用的联合编译版本，如何提交到pypi？\n\n方式1：理想的，推动pytorch社区合入发布联合编译版本\n\n方式2：在pypi上开一个新账号，提交新包到该账号下。该方式弊端是，你没法用pytorch命名，而使用者想用的话，只能去适配你的名称\n\n方式3：新建一个私有pypi，将联合编译版本提交到这里。该方式需考虑：\n\n- 是否允许采用pytorch命名？\n- 当联合编译版本依赖其他包时，是否允许跨仓库关联解决？\n\n\n\n### 自定义私有源\n\n参考：[Setting up a Private PyPI Server](https://testdriven.io/blog/private-pypi/)\n\n安装pypiserver\n\n```bash\npip install pypiserver\ncd <dir-for-host-pypi>\npypi-server run -a . -P .\n```\n\n拉起成功后，可登录：localhost:8080\n\n`-a . -P .`表示不需要登录就可以上传包，只要在上传时保持账号密码为空即可。\n\n在没有指定目录时，上传的包会自动放到$HOME/packages目录下，如果该目录没有提前创建，上传会失败。\n\n上传成功后，即可访问[http://localhost:8080/simple](http://localhost:8080/simple)查看已上传的包。\n\n\n\n如果A包在自定义的仓库，B包在官方pypi源，此时pip install的行为是什么样的？示例：\n\n```bash\n# requirements.txt\nexample-package-wutengda==0.0.1  # 在官方pypi源\nuse-example-priv==0.0.1  # 在本地localhost:8080/simple私有源\n```\n\n安装前清理cache：\n\n```bash\npip cache purge\n```\n\n此时执行：\n\n```bash\n(venv) wutengda@wutengda:~/test$ pip install --index-url http://localhost:8080 --trusted-host=localhost:8080 -r requirements.txt\nLooking in indexes: http://localhost:8080\nCollecting example-package-wutengda==0.0.1\n  Downloading example_package_wutengda-0.0.1-py3-none-any.whl (2.7 kB)\nDEPRECATION: The HTML index page being used (http://localhost:8080/simple/use-example-priv/) is not a proper HTML 5 document. This is in violation of PEP 503 which requires these pages to be well-formed HTML 5 documents. Please reach out to the owners of this index page, and ask them to update this index page to a valid HTML 5 document. pip 22.2 will enforce this behaviour change. Discussion can be found at https://github.com/pypa/pip/issues/10825\nCollecting use-example-priv==0.0.1\n  Downloading http://localhost:8080/packages/use_example_priv-0.0.1-py3-none-any.whl (2.7 kB)\nInstalling collected packages: use-example-priv, example-package-wutengda\nSuccessfully installed example-package-wutengda-0.0.1 use-example-priv-0.0.1\n```\n\n可以正常安装， 不过会有一个DEPRECATION。\n\n\n\n**兼容性结论：**\n\n私有pypi源内如果有包依赖到官方源，则pip能够处理这种关系，pip将首先在当前配置的私有源中查找，如果未找到，则默认回退到官方源中查找。\n\n\n\n## java\n\n### 自定义包上传maven源\n\n参考：[Maven – Maven Central Repository (apache.org)](https://maven.apache.org/repository/)\n\n为jar包生成gpgkey：[Working with PGP Signatures - The Central Repository Documentation (sonatype.org)](https://central.sonatype.org/publish/requirements/gpg/#distributing-your-public-key)\n\n提交jar包到中央仓库：\n\n- apache项目都提交到这里：[Nexus Repository Manager (apache.org)](https://repository.apache.org/)\n\n- 其他项目提交到OSSRH：[OSSRH Guide - The Central Repository Documentation (sonatype.org)](https://central.sonatype.org/publish/publish-guide/)\n\n对于自定义的包，一般往OSSRH提交。该提交必须首先要持有一个JIRA账号和项目ticket（也就是新建一个group id）\n\n对于私人项目，groupid可基于github命名，比如：io.github.stavewu（其他命名方式参考：[Choosing your Coordinates - The Central Repository Documentation (sonatype.org)](https://central.sonatype.org/publish/requirements/coordinates/#choose-your-coordinates)）。提交new project后，还必须在自己的github下创建一个名为OSSRH-xxxxxx的仓库，完成后在对应OSSRH申请单下评论知会工作人员，通常是由机器人秒批的。\n\n这部分细节处理可参考：[发布 Jar 包到 Maven 中央仓库 – LOFFER – 一个可以fork的博客 (gitee.io)](https://index1024.gitee.io/xblog/release-jar-to-mvn-centeral-repo/)\n\n![image-20230929231952522](/images/编程语言源/image-20230929231952522.png)\n\n现在就可以通过jira账号登录OSSRH包管理网站：https://s01.oss.sonatype.org/\n\n准备jar包，pom.xml文件按照以下两个指南编写：\n\n- 最基本的包信息配置：[Requirements - The Central Repository Documentation (sonatype.org)](https://central.sonatype.org/publish/requirements/#create-a-ticket-with-sonatype)\n- 用于一键上传到maven repository的配置：[Apache Maven - The Central Repository Documentation (sonatype.org)](https://central.sonatype.org/publish/publish-maven/#performing-a-release-deployment)\n\n准备好后，使能编译：\n\n```bash\nmvn clean deploy\n```\n\n> java17版本在deploy阶段存在编译错误：[selenium webdriver - Unable to make field private final java.util.Comparator java.util.TreeMap.comparator accessible: java.base doesn't \"opens java.util\" to unnamed module - Stack Overflow](https://stackoverflow.com/questions/68974753/unable-to-make-field-private-final-java-util-comparator-java-util-treemap-compar)\n>\n> 可采用降版本为java8规避。\n\n如成功，将在OOSRH包管理网站上查询到staging profile信息：\n\n![image-20230930004122812](/images/编程语言源/image-20230930004122812.png)\n\n> 虽然官网写了：Upon release, your component will be published to Central: this typically occurs within 30 minutes, though updates to [search](https://search.maven.org/) can take up to four hours.\n>\n> 实际同步花个更长时间，可能大概两天，终于查到了我们要上传的包：\n>\n> ![image-20231001174057638](/images/编程语言源/image-20231001174057638.png)\n\n\n\n**兼容性结论：**\n\n1. maven central对group id有严格控制，必须要得到group id管理员许可才能够提交进去\n2. 如果想基于已有开源软件（如spark）合入问题修复的版本，如做了兼容性适配完善等，想提交到maven central的话，必定会收到group id权限限制，也即需要社区同意后才能合入，无法自行处理。\n\n\n\n### 自定义maven源\n\n自定义maven源可以使用sonatypes nexus：[Nexus！最受欢迎的仓库管理软件 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/544089278)\n\n从上一章节讨论：\n\n1. nexus是介于maven central和本地之间的中转仓库，所有提交的包都会先存在于nexus这里\n2. 有很多包管理网站基于nexus搭建，如OSSRH、apache基金会等\n\n该软件提供了图形化界面来上传包，支持除java以外的各种包类型，如npm等，详细包类型支持见[Uploading Components (sonatype.com)](https://help.sonatype.com/repomanager3/using-nexus-repository/uploading-components)。\n\nnexus本身是开源的：[GitHub - sonatype/nexus-public: Sonatype Nexus Repository Manager; Open-source codebase mirror](https://github.com/sonatype/nexus-public)\n\n\n\n## go\n\n参考：[Using Go Modules - The Go Programming Language](https://go.dev/blog/using-go-modules)\n\n类似maven这种包管理工具在go里面是go mod\n\ngo没有像maven一样有统一的中央仓库，go引入mod完全是靠各个包所在的网络链接来include\n\n以k8s为例，[k8s仓库](https://github.com/kubernetes/kubernetes)中存在一份go.mod，打开可以看到其require方式为url：\n\n```go\n// This is a generated file. Do not edit directly.\n// Ensure you've carefully read\n// https://git.k8s.io/community/contributors/devel/sig-architecture/vendor.md\n// Run hack/pin-dependency.sh to change pinned dependency versions.\n// Run hack/update-vendor.sh to update go.mod files and the vendor directory.\n\nmodule k8s.io/kubernetes\n\ngo 1.20\n\nrequire (\n\tbitbucket.org/bertimus9/systemstat v0.5.0\n\tgithub.com/Azure/azure-sdk-for-go v68.0.0+incompatible\n\tgithub.com/Azure/go-autorest/autorest v0.11.29\n\tgithub.com/Azure/go-autorest/autorest/adal v0.9.23\n\tgithub.com/GoogleCloudPlatform/k8s-cloud-provider v1.18.1-0.20220218231025-f11817397a1b\n\tgithub.com/JeffAshton/win_pdh v0.0.0-20161109143554-76bb4ee9f0ab\n\tgithub.com/Microsoft/go-winio v0.6.0\n\tgithub.com/Microsoft/hcsshim v0.8.25\n    ...\n```\n\n\n\n**兼容性结论：**\n\n对于兼容性来说，因为go本身没有中央仓库管理，因此如有定制的patch等，在合入go mod官方仓库前是可以通过rpm等系统包管理机制来承载。go本身最终编译生成的文件也是一个标准系统二进制文件。\n\n\n\n## js\n\n参考：\n\n- [Creating and publishing scoped public packages](https://docs.npmjs.com/creating-and-publishing-scoped-public-packages)\n\n- [超详细 如何发布自己的 npm 包 - 掘金 (juejin.cn)](https://juejin.cn/post/7039140144250617887)\n\njs的包发布通过npm即可完成，js的包也分两种，私人的和组织的，通过scope的表达方式进行（示例：`@xxx/hello-world`），这里的scope其实等价于namespace，用于预防和其他同名包冲突。不是所有的包都需要声明scope，比如vue。私人也可以发一些不带scope的包，比如shanglv-utils。\n\n因为在npm发布时要求必须要首先登录npm：`npm login`，所以不会出现私人包覆盖官方包的情况。\n\n\n\n**兼容性结论：**\n\nnpm发布包的机制和python基本一致，对于官方包，当官方包已经占位的情况下，我们无法去覆盖它，如有类型兼容性的patch需要合入，只有一种方式，就是通过包官方仓库接纳。\n\n\n\n## rust\n\nrust是有中央仓库的：[crates.io: Rust Package Registry](https://crates.io/)\n\n\n\n## ruby\n\nruby也有中央仓库托管各种包：[RubyGems.org](https://rubygems.org/)\n\n\n","source":"_posts/编程语言镜像源.md","raw":"---\ntitle: 编程语言镜像源\ndate: 2023/09/03 23:46:00\ntoc: true\ncategories: \n - 编程语言\ntags: \n - 软件生态\n---\n\n本文探索不同编程语言都是如何管理其依赖包的，如何做到快速安装使用？如何为其构建的源做贡献？以及，如果想自定义一个第三方包管理，怎么做？\n\n<!-- more -->\n\n## python\n\n### 自定义包上传官方源\n\n自定义包上传到pypi的教程：[Packaging Python Projects — Python Packaging User Guide](https://packaging.python.org/en/latest/tutorials/packaging-projects/)\n\n通过twine命令。\n\n\n有两点需要注意：\n\n1、需要设置2FA验证后才能生成token。\n\n什么是2FA验证：类似一种动态口令，需要手机扫二维码，获得口令码，再输入验证。\n\n腾讯小程序有一个比较好用的： Authentic\n\n2、如果遇到上传失败，提示403的情况，检查包名是否跟其他人重复：\n\n```bash\nERROR    HTTPError: 403 Forbidden from https://test.pypi.org/legacy/               \n         The user 'wutengda' isn't allowed to upload to project                    \n         'example-package-testing'. See https://test.pypi.org/help/#project-name   \n         for more information. \n```\n\n\n\n上传成功后，就可以使用该命令安装：\n\n```bash\n(venv) wutengda@wutengda:~/packaging_tutorial$ pip install example-package-wutengda\n \nCollecting example-package-wutengda\n  Downloading example_package_wutengda-0.0.1-py3-none-any.whl (2.7 kB)\nInstalling collected packages: example-package-wutengda\nSuccessfully installed example-package-wutengda-0.0.1\n```\n\n\n场景思考：\n\n对于pytorch，在arm上直接使用报没有和cuda联合编译，导致运行失败的情况。此时我们手动编译构建了一个可用的联合编译版本，如何提交到pypi？\n\n方式1：理想的，推动pytorch社区合入发布联合编译版本\n\n方式2：在pypi上开一个新账号，提交新包到该账号下。该方式弊端是，你没法用pytorch命名，而使用者想用的话，只能去适配你的名称\n\n方式3：新建一个私有pypi，将联合编译版本提交到这里。该方式需考虑：\n\n- 是否允许采用pytorch命名？\n- 当联合编译版本依赖其他包时，是否允许跨仓库关联解决？\n\n\n\n### 自定义私有源\n\n参考：[Setting up a Private PyPI Server](https://testdriven.io/blog/private-pypi/)\n\n安装pypiserver\n\n```bash\npip install pypiserver\ncd <dir-for-host-pypi>\npypi-server run -a . -P .\n```\n\n拉起成功后，可登录：localhost:8080\n\n`-a . -P .`表示不需要登录就可以上传包，只要在上传时保持账号密码为空即可。\n\n在没有指定目录时，上传的包会自动放到$HOME/packages目录下，如果该目录没有提前创建，上传会失败。\n\n上传成功后，即可访问[http://localhost:8080/simple](http://localhost:8080/simple)查看已上传的包。\n\n\n\n如果A包在自定义的仓库，B包在官方pypi源，此时pip install的行为是什么样的？示例：\n\n```bash\n# requirements.txt\nexample-package-wutengda==0.0.1  # 在官方pypi源\nuse-example-priv==0.0.1  # 在本地localhost:8080/simple私有源\n```\n\n安装前清理cache：\n\n```bash\npip cache purge\n```\n\n此时执行：\n\n```bash\n(venv) wutengda@wutengda:~/test$ pip install --index-url http://localhost:8080 --trusted-host=localhost:8080 -r requirements.txt\nLooking in indexes: http://localhost:8080\nCollecting example-package-wutengda==0.0.1\n  Downloading example_package_wutengda-0.0.1-py3-none-any.whl (2.7 kB)\nDEPRECATION: The HTML index page being used (http://localhost:8080/simple/use-example-priv/) is not a proper HTML 5 document. This is in violation of PEP 503 which requires these pages to be well-formed HTML 5 documents. Please reach out to the owners of this index page, and ask them to update this index page to a valid HTML 5 document. pip 22.2 will enforce this behaviour change. Discussion can be found at https://github.com/pypa/pip/issues/10825\nCollecting use-example-priv==0.0.1\n  Downloading http://localhost:8080/packages/use_example_priv-0.0.1-py3-none-any.whl (2.7 kB)\nInstalling collected packages: use-example-priv, example-package-wutengda\nSuccessfully installed example-package-wutengda-0.0.1 use-example-priv-0.0.1\n```\n\n可以正常安装， 不过会有一个DEPRECATION。\n\n\n\n**兼容性结论：**\n\n私有pypi源内如果有包依赖到官方源，则pip能够处理这种关系，pip将首先在当前配置的私有源中查找，如果未找到，则默认回退到官方源中查找。\n\n\n\n## java\n\n### 自定义包上传maven源\n\n参考：[Maven – Maven Central Repository (apache.org)](https://maven.apache.org/repository/)\n\n为jar包生成gpgkey：[Working with PGP Signatures - The Central Repository Documentation (sonatype.org)](https://central.sonatype.org/publish/requirements/gpg/#distributing-your-public-key)\n\n提交jar包到中央仓库：\n\n- apache项目都提交到这里：[Nexus Repository Manager (apache.org)](https://repository.apache.org/)\n\n- 其他项目提交到OSSRH：[OSSRH Guide - The Central Repository Documentation (sonatype.org)](https://central.sonatype.org/publish/publish-guide/)\n\n对于自定义的包，一般往OSSRH提交。该提交必须首先要持有一个JIRA账号和项目ticket（也就是新建一个group id）\n\n对于私人项目，groupid可基于github命名，比如：io.github.stavewu（其他命名方式参考：[Choosing your Coordinates - The Central Repository Documentation (sonatype.org)](https://central.sonatype.org/publish/requirements/coordinates/#choose-your-coordinates)）。提交new project后，还必须在自己的github下创建一个名为OSSRH-xxxxxx的仓库，完成后在对应OSSRH申请单下评论知会工作人员，通常是由机器人秒批的。\n\n这部分细节处理可参考：[发布 Jar 包到 Maven 中央仓库 – LOFFER – 一个可以fork的博客 (gitee.io)](https://index1024.gitee.io/xblog/release-jar-to-mvn-centeral-repo/)\n\n![image-20230929231952522](/images/编程语言源/image-20230929231952522.png)\n\n现在就可以通过jira账号登录OSSRH包管理网站：https://s01.oss.sonatype.org/\n\n准备jar包，pom.xml文件按照以下两个指南编写：\n\n- 最基本的包信息配置：[Requirements - The Central Repository Documentation (sonatype.org)](https://central.sonatype.org/publish/requirements/#create-a-ticket-with-sonatype)\n- 用于一键上传到maven repository的配置：[Apache Maven - The Central Repository Documentation (sonatype.org)](https://central.sonatype.org/publish/publish-maven/#performing-a-release-deployment)\n\n准备好后，使能编译：\n\n```bash\nmvn clean deploy\n```\n\n> java17版本在deploy阶段存在编译错误：[selenium webdriver - Unable to make field private final java.util.Comparator java.util.TreeMap.comparator accessible: java.base doesn't \"opens java.util\" to unnamed module - Stack Overflow](https://stackoverflow.com/questions/68974753/unable-to-make-field-private-final-java-util-comparator-java-util-treemap-compar)\n>\n> 可采用降版本为java8规避。\n\n如成功，将在OOSRH包管理网站上查询到staging profile信息：\n\n![image-20230930004122812](/images/编程语言源/image-20230930004122812.png)\n\n> 虽然官网写了：Upon release, your component will be published to Central: this typically occurs within 30 minutes, though updates to [search](https://search.maven.org/) can take up to four hours.\n>\n> 实际同步花个更长时间，可能大概两天，终于查到了我们要上传的包：\n>\n> ![image-20231001174057638](/images/编程语言源/image-20231001174057638.png)\n\n\n\n**兼容性结论：**\n\n1. maven central对group id有严格控制，必须要得到group id管理员许可才能够提交进去\n2. 如果想基于已有开源软件（如spark）合入问题修复的版本，如做了兼容性适配完善等，想提交到maven central的话，必定会收到group id权限限制，也即需要社区同意后才能合入，无法自行处理。\n\n\n\n### 自定义maven源\n\n自定义maven源可以使用sonatypes nexus：[Nexus！最受欢迎的仓库管理软件 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/544089278)\n\n从上一章节讨论：\n\n1. nexus是介于maven central和本地之间的中转仓库，所有提交的包都会先存在于nexus这里\n2. 有很多包管理网站基于nexus搭建，如OSSRH、apache基金会等\n\n该软件提供了图形化界面来上传包，支持除java以外的各种包类型，如npm等，详细包类型支持见[Uploading Components (sonatype.com)](https://help.sonatype.com/repomanager3/using-nexus-repository/uploading-components)。\n\nnexus本身是开源的：[GitHub - sonatype/nexus-public: Sonatype Nexus Repository Manager; Open-source codebase mirror](https://github.com/sonatype/nexus-public)\n\n\n\n## go\n\n参考：[Using Go Modules - The Go Programming Language](https://go.dev/blog/using-go-modules)\n\n类似maven这种包管理工具在go里面是go mod\n\ngo没有像maven一样有统一的中央仓库，go引入mod完全是靠各个包所在的网络链接来include\n\n以k8s为例，[k8s仓库](https://github.com/kubernetes/kubernetes)中存在一份go.mod，打开可以看到其require方式为url：\n\n```go\n// This is a generated file. Do not edit directly.\n// Ensure you've carefully read\n// https://git.k8s.io/community/contributors/devel/sig-architecture/vendor.md\n// Run hack/pin-dependency.sh to change pinned dependency versions.\n// Run hack/update-vendor.sh to update go.mod files and the vendor directory.\n\nmodule k8s.io/kubernetes\n\ngo 1.20\n\nrequire (\n\tbitbucket.org/bertimus9/systemstat v0.5.0\n\tgithub.com/Azure/azure-sdk-for-go v68.0.0+incompatible\n\tgithub.com/Azure/go-autorest/autorest v0.11.29\n\tgithub.com/Azure/go-autorest/autorest/adal v0.9.23\n\tgithub.com/GoogleCloudPlatform/k8s-cloud-provider v1.18.1-0.20220218231025-f11817397a1b\n\tgithub.com/JeffAshton/win_pdh v0.0.0-20161109143554-76bb4ee9f0ab\n\tgithub.com/Microsoft/go-winio v0.6.0\n\tgithub.com/Microsoft/hcsshim v0.8.25\n    ...\n```\n\n\n\n**兼容性结论：**\n\n对于兼容性来说，因为go本身没有中央仓库管理，因此如有定制的patch等，在合入go mod官方仓库前是可以通过rpm等系统包管理机制来承载。go本身最终编译生成的文件也是一个标准系统二进制文件。\n\n\n\n## js\n\n参考：\n\n- [Creating and publishing scoped public packages](https://docs.npmjs.com/creating-and-publishing-scoped-public-packages)\n\n- [超详细 如何发布自己的 npm 包 - 掘金 (juejin.cn)](https://juejin.cn/post/7039140144250617887)\n\njs的包发布通过npm即可完成，js的包也分两种，私人的和组织的，通过scope的表达方式进行（示例：`@xxx/hello-world`），这里的scope其实等价于namespace，用于预防和其他同名包冲突。不是所有的包都需要声明scope，比如vue。私人也可以发一些不带scope的包，比如shanglv-utils。\n\n因为在npm发布时要求必须要首先登录npm：`npm login`，所以不会出现私人包覆盖官方包的情况。\n\n\n\n**兼容性结论：**\n\nnpm发布包的机制和python基本一致，对于官方包，当官方包已经占位的情况下，我们无法去覆盖它，如有类型兼容性的patch需要合入，只有一种方式，就是通过包官方仓库接纳。\n\n\n\n## rust\n\nrust是有中央仓库的：[crates.io: Rust Package Registry](https://crates.io/)\n\n\n\n## ruby\n\nruby也有中央仓库托管各种包：[RubyGems.org](https://rubygems.org/)\n\n\n","slug":"编程语言镜像源","published":1,"updated":"2024-08-18T08:50:51.504Z","_id":"clzzazpbh0000lnp76urd4qng","comments":1,"layout":"post","photos":[],"content":"<p>本文探索不同编程语言都是如何管理其依赖包的，如何做到快速安装使用？如何为其构建的源做贡献？以及，如果想自定义一个第三方包管理，怎么做？</p>\n<span id=\"more\"></span>\n\n<h2 id=\"python\"><a href=\"#python\" class=\"headerlink\" title=\"python\"></a>python</h2><h3 id=\"自定义包上传官方源\"><a href=\"#自定义包上传官方源\" class=\"headerlink\" title=\"自定义包上传官方源\"></a>自定义包上传官方源</h3><p>自定义包上传到pypi的教程：<a href=\"https://packaging.python.org/en/latest/tutorials/packaging-projects/\">Packaging Python Projects — Python Packaging User Guide</a></p>\n<p>通过twine命令。</p>\n<p>有两点需要注意：</p>\n<p>1、需要设置2FA验证后才能生成token。</p>\n<p>什么是2FA验证：类似一种动态口令，需要手机扫二维码，获得口令码，再输入验证。</p>\n<p>腾讯小程序有一个比较好用的： Authentic</p>\n<p>2、如果遇到上传失败，提示403的情况，检查包名是否跟其他人重复：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ERROR    HTTPError: 403 Forbidden from https://test.pypi.org/legacy/               </span><br><span class=\"line\">         The user <span class=\"string\">&#x27;wutengda&#x27;</span> isn<span class=\"string\">&#x27;t allowed to upload to project                    </span></span><br><span class=\"line\"><span class=\"string\">         &#x27;</span>example-package-testing<span class=\"string\">&#x27;. See https://test.pypi.org/help/#project-name   </span></span><br><span class=\"line\"><span class=\"string\">         for more information. </span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>上传成功后，就可以使用该命令安装：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(venv) wutengda@wutengda:~/packaging_tutorial$ pip install example-package-wutengda</span><br><span class=\"line\"> </span><br><span class=\"line\">Collecting example-package-wutengda</span><br><span class=\"line\">  Downloading example_package_wutengda-0.0.1-py3-none-any.whl (2.7 kB)</span><br><span class=\"line\">Installing collected packages: example-package-wutengda</span><br><span class=\"line\">Successfully installed example-package-wutengda-0.0.1</span><br></pre></td></tr></table></figure>\n\n\n<p>场景思考：</p>\n<p>对于pytorch，在arm上直接使用报没有和cuda联合编译，导致运行失败的情况。此时我们手动编译构建了一个可用的联合编译版本，如何提交到pypi？</p>\n<p>方式1：理想的，推动pytorch社区合入发布联合编译版本</p>\n<p>方式2：在pypi上开一个新账号，提交新包到该账号下。该方式弊端是，你没法用pytorch命名，而使用者想用的话，只能去适配你的名称</p>\n<p>方式3：新建一个私有pypi，将联合编译版本提交到这里。该方式需考虑：</p>\n<ul>\n<li>是否允许采用pytorch命名？</li>\n<li>当联合编译版本依赖其他包时，是否允许跨仓库关联解决？</li>\n</ul>\n<h3 id=\"自定义私有源\"><a href=\"#自定义私有源\" class=\"headerlink\" title=\"自定义私有源\"></a>自定义私有源</h3><p>参考：<a href=\"https://testdriven.io/blog/private-pypi/\">Setting up a Private PyPI Server</a></p>\n<p>安装pypiserver</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip install pypiserver</span><br><span class=\"line\"><span class=\"built_in\">cd</span> &lt;dir-for-host-pypi&gt;</span><br><span class=\"line\">pypi-server run -a . -P .</span><br></pre></td></tr></table></figure>\n\n<p>拉起成功后，可登录：localhost:8080</p>\n<p><code>-a . -P .</code>表示不需要登录就可以上传包，只要在上传时保持账号密码为空即可。</p>\n<p>在没有指定目录时，上传的包会自动放到$HOME&#x2F;packages目录下，如果该目录没有提前创建，上传会失败。</p>\n<p>上传成功后，即可访问<a href=\"http://localhost:8080/simple\">http://localhost:8080/simple</a>查看已上传的包。</p>\n<p>如果A包在自定义的仓库，B包在官方pypi源，此时pip install的行为是什么样的？示例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># requirements.txt</span></span><br><span class=\"line\">example-package-wutengda==0.0.1  <span class=\"comment\"># 在官方pypi源</span></span><br><span class=\"line\">use-example-priv==0.0.1  <span class=\"comment\"># 在本地localhost:8080/simple私有源</span></span><br></pre></td></tr></table></figure>\n\n<p>安装前清理cache：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip cache purge</span><br></pre></td></tr></table></figure>\n\n<p>此时执行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(venv) wutengda@wutengda:~/test$ pip install --index-url http://localhost:8080 --trusted-host=localhost:8080 -r requirements.txt</span><br><span class=\"line\">Looking <span class=\"keyword\">in</span> indexes: http://localhost:8080</span><br><span class=\"line\">Collecting example-package-wutengda==0.0.1</span><br><span class=\"line\">  Downloading example_package_wutengda-0.0.1-py3-none-any.whl (2.7 kB)</span><br><span class=\"line\">DEPRECATION: The HTML index page being used (http://localhost:8080/simple/use-example-priv/) is not a proper HTML 5 document. This is <span class=\"keyword\">in</span> violation of PEP 503 <span class=\"built_in\">which</span> requires these pages to be well-formed HTML 5 documents. Please reach out to the owners of this index page, and ask them to update this index page to a valid HTML 5 document. pip 22.2 will enforce this behaviour change. Discussion can be found at https://github.com/pypa/pip/issues/10825</span><br><span class=\"line\">Collecting use-example-priv==0.0.1</span><br><span class=\"line\">  Downloading http://localhost:8080/packages/use_example_priv-0.0.1-py3-none-any.whl (2.7 kB)</span><br><span class=\"line\">Installing collected packages: use-example-priv, example-package-wutengda</span><br><span class=\"line\">Successfully installed example-package-wutengda-0.0.1 use-example-priv-0.0.1</span><br></pre></td></tr></table></figure>\n\n<p>可以正常安装， 不过会有一个DEPRECATION。</p>\n<p><strong>兼容性结论：</strong></p>\n<p>私有pypi源内如果有包依赖到官方源，则pip能够处理这种关系，pip将首先在当前配置的私有源中查找，如果未找到，则默认回退到官方源中查找。</p>\n<h2 id=\"java\"><a href=\"#java\" class=\"headerlink\" title=\"java\"></a>java</h2><h3 id=\"自定义包上传maven源\"><a href=\"#自定义包上传maven源\" class=\"headerlink\" title=\"自定义包上传maven源\"></a>自定义包上传maven源</h3><p>参考：<a href=\"https://maven.apache.org/repository/\">Maven – Maven Central Repository (apache.org)</a></p>\n<p>为jar包生成gpgkey：<a href=\"https://central.sonatype.org/publish/requirements/gpg/#distributing-your-public-key\">Working with PGP Signatures - The Central Repository Documentation (sonatype.org)</a></p>\n<p>提交jar包到中央仓库：</p>\n<ul>\n<li><p>apache项目都提交到这里：<a href=\"https://repository.apache.org/\">Nexus Repository Manager (apache.org)</a></p>\n</li>\n<li><p>其他项目提交到OSSRH：<a href=\"https://central.sonatype.org/publish/publish-guide/\">OSSRH Guide - The Central Repository Documentation (sonatype.org)</a></p>\n</li>\n</ul>\n<p>对于自定义的包，一般往OSSRH提交。该提交必须首先要持有一个JIRA账号和项目ticket（也就是新建一个group id）</p>\n<p>对于私人项目，groupid可基于github命名，比如：io.github.stavewu（其他命名方式参考：<a href=\"https://central.sonatype.org/publish/requirements/coordinates/#choose-your-coordinates\">Choosing your Coordinates - The Central Repository Documentation (sonatype.org)</a>）。提交new project后，还必须在自己的github下创建一个名为OSSRH-xxxxxx的仓库，完成后在对应OSSRH申请单下评论知会工作人员，通常是由机器人秒批的。</p>\n<p>这部分细节处理可参考：<a href=\"https://index1024.gitee.io/xblog/release-jar-to-mvn-centeral-repo/\">发布 Jar 包到 Maven 中央仓库 – LOFFER – 一个可以fork的博客 (gitee.io)</a></p>\n<p><img src=\"/images/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E6%BA%90/image-20230929231952522.png\" alt=\"image-20230929231952522\"></p>\n<p>现在就可以通过jira账号登录OSSRH包管理网站：<a href=\"https://s01.oss.sonatype.org/\">https://s01.oss.sonatype.org/</a></p>\n<p>准备jar包，pom.xml文件按照以下两个指南编写：</p>\n<ul>\n<li>最基本的包信息配置：<a href=\"https://central.sonatype.org/publish/requirements/#create-a-ticket-with-sonatype\">Requirements - The Central Repository Documentation (sonatype.org)</a></li>\n<li>用于一键上传到maven repository的配置：<a href=\"https://central.sonatype.org/publish/publish-maven/#performing-a-release-deployment\">Apache Maven - The Central Repository Documentation (sonatype.org)</a></li>\n</ul>\n<p>准备好后，使能编译：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mvn clean deploy</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>java17版本在deploy阶段存在编译错误：<a href=\"https://stackoverflow.com/questions/68974753/unable-to-make-field-private-final-java-util-comparator-java-util-treemap-compar\">selenium webdriver - Unable to make field private final java.util.Comparator java.util.TreeMap.comparator accessible: java.base doesn’t “opens java.util” to unnamed module - Stack Overflow</a></p>\n<p>可采用降版本为java8规避。</p>\n</blockquote>\n<p>如成功，将在OOSRH包管理网站上查询到staging profile信息：</p>\n<p><img src=\"/images/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E6%BA%90/image-20230930004122812.png\" alt=\"image-20230930004122812\"></p>\n<blockquote>\n<p>虽然官网写了：Upon release, your component will be published to Central: this typically occurs within 30 minutes, though updates to <a href=\"https://search.maven.org/\">search</a> can take up to four hours.</p>\n<p>实际同步花个更长时间，可能大概两天，终于查到了我们要上传的包：</p>\n<p><img src=\"/images/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E6%BA%90/image-20231001174057638.png\" alt=\"image-20231001174057638\"></p>\n</blockquote>\n<p><strong>兼容性结论：</strong></p>\n<ol>\n<li>maven central对group id有严格控制，必须要得到group id管理员许可才能够提交进去</li>\n<li>如果想基于已有开源软件（如spark）合入问题修复的版本，如做了兼容性适配完善等，想提交到maven central的话，必定会收到group id权限限制，也即需要社区同意后才能合入，无法自行处理。</li>\n</ol>\n<h3 id=\"自定义maven源\"><a href=\"#自定义maven源\" class=\"headerlink\" title=\"自定义maven源\"></a>自定义maven源</h3><p>自定义maven源可以使用sonatypes nexus：<a href=\"https://zhuanlan.zhihu.com/p/544089278\">Nexus！最受欢迎的仓库管理软件 - 知乎 (zhihu.com)</a></p>\n<p>从上一章节讨论：</p>\n<ol>\n<li>nexus是介于maven central和本地之间的中转仓库，所有提交的包都会先存在于nexus这里</li>\n<li>有很多包管理网站基于nexus搭建，如OSSRH、apache基金会等</li>\n</ol>\n<p>该软件提供了图形化界面来上传包，支持除java以外的各种包类型，如npm等，详细包类型支持见<a href=\"https://help.sonatype.com/repomanager3/using-nexus-repository/uploading-components\">Uploading Components (sonatype.com)</a>。</p>\n<p>nexus本身是开源的：<a href=\"https://github.com/sonatype/nexus-public\">GitHub - sonatype&#x2F;nexus-public: Sonatype Nexus Repository Manager; Open-source codebase mirror</a></p>\n<h2 id=\"go\"><a href=\"#go\" class=\"headerlink\" title=\"go\"></a>go</h2><p>参考：<a href=\"https://go.dev/blog/using-go-modules\">Using Go Modules - The Go Programming Language</a></p>\n<p>类似maven这种包管理工具在go里面是go mod</p>\n<p>go没有像maven一样有统一的中央仓库，go引入mod完全是靠各个包所在的网络链接来include</p>\n<p>以k8s为例，<a href=\"https://github.com/kubernetes/kubernetes\">k8s仓库</a>中存在一份go.mod，打开可以看到其require方式为url：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// This is a generated file. Do not edit directly.</span></span><br><span class=\"line\"><span class=\"comment\">// Ensure you&#x27;ve carefully read</span></span><br><span class=\"line\"><span class=\"comment\">// https://git.k8s.io/community/contributors/devel/sig-architecture/vendor.md</span></span><br><span class=\"line\"><span class=\"comment\">// Run hack/pin-dependency.sh to change pinned dependency versions.</span></span><br><span class=\"line\"><span class=\"comment\">// Run hack/update-vendor.sh to update go.mod files and the vendor directory.</span></span><br><span class=\"line\"></span><br><span class=\"line\">module k8s.io/kubernetes</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">go</span> <span class=\"number\">1.20</span></span><br><span class=\"line\"></span><br><span class=\"line\">require (</span><br><span class=\"line\">\tbitbucket.org/bertimus9/systemstat v0<span class=\"number\">.5</span><span class=\"number\">.0</span></span><br><span class=\"line\">\tgithub.com/Azure/azure-sdk-<span class=\"keyword\">for</span>-<span class=\"keyword\">go</span> v68<span class=\"number\">.0</span><span class=\"number\">.0</span>+incompatible</span><br><span class=\"line\">\tgithub.com/Azure/<span class=\"keyword\">go</span>-autorest/autorest v0<span class=\"number\">.11</span><span class=\"number\">.29</span></span><br><span class=\"line\">\tgithub.com/Azure/<span class=\"keyword\">go</span>-autorest/autorest/adal v0<span class=\"number\">.9</span><span class=\"number\">.23</span></span><br><span class=\"line\">\tgithub.com/GoogleCloudPlatform/k8s-cloud-provider v1<span class=\"number\">.18</span><span class=\"number\">.1</span><span class=\"number\">-0.20220218231025</span>-f11817397a1b</span><br><span class=\"line\">\tgithub.com/JeffAshton/win_pdh v0<span class=\"number\">.0</span><span class=\"number\">.0</span><span class=\"number\">-20161109143554</span><span class=\"number\">-76</span>bb4ee9f0ab</span><br><span class=\"line\">\tgithub.com/Microsoft/<span class=\"keyword\">go</span>-winio v0<span class=\"number\">.6</span><span class=\"number\">.0</span></span><br><span class=\"line\">\tgithub.com/Microsoft/hcsshim v0<span class=\"number\">.8</span><span class=\"number\">.25</span></span><br><span class=\"line\">    ...</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>兼容性结论：</strong></p>\n<p>对于兼容性来说，因为go本身没有中央仓库管理，因此如有定制的patch等，在合入go mod官方仓库前是可以通过rpm等系统包管理机制来承载。go本身最终编译生成的文件也是一个标准系统二进制文件。</p>\n<h2 id=\"js\"><a href=\"#js\" class=\"headerlink\" title=\"js\"></a>js</h2><p>参考：</p>\n<ul>\n<li><p><a href=\"https://docs.npmjs.com/creating-and-publishing-scoped-public-packages\">Creating and publishing scoped public packages</a></p>\n</li>\n<li><p><a href=\"https://juejin.cn/post/7039140144250617887\">超详细 如何发布自己的 npm 包 - 掘金 (juejin.cn)</a></p>\n</li>\n</ul>\n<p>js的包发布通过npm即可完成，js的包也分两种，私人的和组织的，通过scope的表达方式进行（示例：<code>@xxx/hello-world</code>），这里的scope其实等价于namespace，用于预防和其他同名包冲突。不是所有的包都需要声明scope，比如vue。私人也可以发一些不带scope的包，比如shanglv-utils。</p>\n<p>因为在npm发布时要求必须要首先登录npm：<code>npm login</code>，所以不会出现私人包覆盖官方包的情况。</p>\n<p><strong>兼容性结论：</strong></p>\n<p>npm发布包的机制和python基本一致，对于官方包，当官方包已经占位的情况下，我们无法去覆盖它，如有类型兼容性的patch需要合入，只有一种方式，就是通过包官方仓库接纳。</p>\n<h2 id=\"rust\"><a href=\"#rust\" class=\"headerlink\" title=\"rust\"></a>rust</h2><p>rust是有中央仓库的：<a href=\"https://crates.io/\">crates.io: Rust Package Registry</a></p>\n<h2 id=\"ruby\"><a href=\"#ruby\" class=\"headerlink\" title=\"ruby\"></a>ruby</h2><p>ruby也有中央仓库托管各种包：<a href=\"https://rubygems.org/\">RubyGems.org</a></p>\n","excerpt":"<p>本文探索不同编程语言都是如何管理其依赖包的，如何做到快速安装使用？如何为其构建的源做贡献？以及，如果想自定义一个第三方包管理，怎么做？</p>","more":"<h2 id=\"python\"><a href=\"#python\" class=\"headerlink\" title=\"python\"></a>python</h2><h3 id=\"自定义包上传官方源\"><a href=\"#自定义包上传官方源\" class=\"headerlink\" title=\"自定义包上传官方源\"></a>自定义包上传官方源</h3><p>自定义包上传到pypi的教程：<a href=\"https://packaging.python.org/en/latest/tutorials/packaging-projects/\">Packaging Python Projects — Python Packaging User Guide</a></p>\n<p>通过twine命令。</p>\n<p>有两点需要注意：</p>\n<p>1、需要设置2FA验证后才能生成token。</p>\n<p>什么是2FA验证：类似一种动态口令，需要手机扫二维码，获得口令码，再输入验证。</p>\n<p>腾讯小程序有一个比较好用的： Authentic</p>\n<p>2、如果遇到上传失败，提示403的情况，检查包名是否跟其他人重复：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ERROR    HTTPError: 403 Forbidden from https://test.pypi.org/legacy/               </span><br><span class=\"line\">         The user <span class=\"string\">&#x27;wutengda&#x27;</span> isn<span class=\"string\">&#x27;t allowed to upload to project                    </span></span><br><span class=\"line\"><span class=\"string\">         &#x27;</span>example-package-testing<span class=\"string\">&#x27;. See https://test.pypi.org/help/#project-name   </span></span><br><span class=\"line\"><span class=\"string\">         for more information. </span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>上传成功后，就可以使用该命令安装：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(venv) wutengda@wutengda:~/packaging_tutorial$ pip install example-package-wutengda</span><br><span class=\"line\"> </span><br><span class=\"line\">Collecting example-package-wutengda</span><br><span class=\"line\">  Downloading example_package_wutengda-0.0.1-py3-none-any.whl (2.7 kB)</span><br><span class=\"line\">Installing collected packages: example-package-wutengda</span><br><span class=\"line\">Successfully installed example-package-wutengda-0.0.1</span><br></pre></td></tr></table></figure>\n\n\n<p>场景思考：</p>\n<p>对于pytorch，在arm上直接使用报没有和cuda联合编译，导致运行失败的情况。此时我们手动编译构建了一个可用的联合编译版本，如何提交到pypi？</p>\n<p>方式1：理想的，推动pytorch社区合入发布联合编译版本</p>\n<p>方式2：在pypi上开一个新账号，提交新包到该账号下。该方式弊端是，你没法用pytorch命名，而使用者想用的话，只能去适配你的名称</p>\n<p>方式3：新建一个私有pypi，将联合编译版本提交到这里。该方式需考虑：</p>\n<ul>\n<li>是否允许采用pytorch命名？</li>\n<li>当联合编译版本依赖其他包时，是否允许跨仓库关联解决？</li>\n</ul>\n<h3 id=\"自定义私有源\"><a href=\"#自定义私有源\" class=\"headerlink\" title=\"自定义私有源\"></a>自定义私有源</h3><p>参考：<a href=\"https://testdriven.io/blog/private-pypi/\">Setting up a Private PyPI Server</a></p>\n<p>安装pypiserver</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip install pypiserver</span><br><span class=\"line\"><span class=\"built_in\">cd</span> &lt;dir-for-host-pypi&gt;</span><br><span class=\"line\">pypi-server run -a . -P .</span><br></pre></td></tr></table></figure>\n\n<p>拉起成功后，可登录：localhost:8080</p>\n<p><code>-a . -P .</code>表示不需要登录就可以上传包，只要在上传时保持账号密码为空即可。</p>\n<p>在没有指定目录时，上传的包会自动放到$HOME&#x2F;packages目录下，如果该目录没有提前创建，上传会失败。</p>\n<p>上传成功后，即可访问<a href=\"http://localhost:8080/simple\">http://localhost:8080/simple</a>查看已上传的包。</p>\n<p>如果A包在自定义的仓库，B包在官方pypi源，此时pip install的行为是什么样的？示例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># requirements.txt</span></span><br><span class=\"line\">example-package-wutengda==0.0.1  <span class=\"comment\"># 在官方pypi源</span></span><br><span class=\"line\">use-example-priv==0.0.1  <span class=\"comment\"># 在本地localhost:8080/simple私有源</span></span><br></pre></td></tr></table></figure>\n\n<p>安装前清理cache：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip cache purge</span><br></pre></td></tr></table></figure>\n\n<p>此时执行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(venv) wutengda@wutengda:~/test$ pip install --index-url http://localhost:8080 --trusted-host=localhost:8080 -r requirements.txt</span><br><span class=\"line\">Looking <span class=\"keyword\">in</span> indexes: http://localhost:8080</span><br><span class=\"line\">Collecting example-package-wutengda==0.0.1</span><br><span class=\"line\">  Downloading example_package_wutengda-0.0.1-py3-none-any.whl (2.7 kB)</span><br><span class=\"line\">DEPRECATION: The HTML index page being used (http://localhost:8080/simple/use-example-priv/) is not a proper HTML 5 document. This is <span class=\"keyword\">in</span> violation of PEP 503 <span class=\"built_in\">which</span> requires these pages to be well-formed HTML 5 documents. Please reach out to the owners of this index page, and ask them to update this index page to a valid HTML 5 document. pip 22.2 will enforce this behaviour change. Discussion can be found at https://github.com/pypa/pip/issues/10825</span><br><span class=\"line\">Collecting use-example-priv==0.0.1</span><br><span class=\"line\">  Downloading http://localhost:8080/packages/use_example_priv-0.0.1-py3-none-any.whl (2.7 kB)</span><br><span class=\"line\">Installing collected packages: use-example-priv, example-package-wutengda</span><br><span class=\"line\">Successfully installed example-package-wutengda-0.0.1 use-example-priv-0.0.1</span><br></pre></td></tr></table></figure>\n\n<p>可以正常安装， 不过会有一个DEPRECATION。</p>\n<p><strong>兼容性结论：</strong></p>\n<p>私有pypi源内如果有包依赖到官方源，则pip能够处理这种关系，pip将首先在当前配置的私有源中查找，如果未找到，则默认回退到官方源中查找。</p>\n<h2 id=\"java\"><a href=\"#java\" class=\"headerlink\" title=\"java\"></a>java</h2><h3 id=\"自定义包上传maven源\"><a href=\"#自定义包上传maven源\" class=\"headerlink\" title=\"自定义包上传maven源\"></a>自定义包上传maven源</h3><p>参考：<a href=\"https://maven.apache.org/repository/\">Maven – Maven Central Repository (apache.org)</a></p>\n<p>为jar包生成gpgkey：<a href=\"https://central.sonatype.org/publish/requirements/gpg/#distributing-your-public-key\">Working with PGP Signatures - The Central Repository Documentation (sonatype.org)</a></p>\n<p>提交jar包到中央仓库：</p>\n<ul>\n<li><p>apache项目都提交到这里：<a href=\"https://repository.apache.org/\">Nexus Repository Manager (apache.org)</a></p>\n</li>\n<li><p>其他项目提交到OSSRH：<a href=\"https://central.sonatype.org/publish/publish-guide/\">OSSRH Guide - The Central Repository Documentation (sonatype.org)</a></p>\n</li>\n</ul>\n<p>对于自定义的包，一般往OSSRH提交。该提交必须首先要持有一个JIRA账号和项目ticket（也就是新建一个group id）</p>\n<p>对于私人项目，groupid可基于github命名，比如：io.github.stavewu（其他命名方式参考：<a href=\"https://central.sonatype.org/publish/requirements/coordinates/#choose-your-coordinates\">Choosing your Coordinates - The Central Repository Documentation (sonatype.org)</a>）。提交new project后，还必须在自己的github下创建一个名为OSSRH-xxxxxx的仓库，完成后在对应OSSRH申请单下评论知会工作人员，通常是由机器人秒批的。</p>\n<p>这部分细节处理可参考：<a href=\"https://index1024.gitee.io/xblog/release-jar-to-mvn-centeral-repo/\">发布 Jar 包到 Maven 中央仓库 – LOFFER – 一个可以fork的博客 (gitee.io)</a></p>\n<p><img src=\"/images/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E6%BA%90/image-20230929231952522.png\" alt=\"image-20230929231952522\"></p>\n<p>现在就可以通过jira账号登录OSSRH包管理网站：<a href=\"https://s01.oss.sonatype.org/\">https://s01.oss.sonatype.org/</a></p>\n<p>准备jar包，pom.xml文件按照以下两个指南编写：</p>\n<ul>\n<li>最基本的包信息配置：<a href=\"https://central.sonatype.org/publish/requirements/#create-a-ticket-with-sonatype\">Requirements - The Central Repository Documentation (sonatype.org)</a></li>\n<li>用于一键上传到maven repository的配置：<a href=\"https://central.sonatype.org/publish/publish-maven/#performing-a-release-deployment\">Apache Maven - The Central Repository Documentation (sonatype.org)</a></li>\n</ul>\n<p>准备好后，使能编译：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mvn clean deploy</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>java17版本在deploy阶段存在编译错误：<a href=\"https://stackoverflow.com/questions/68974753/unable-to-make-field-private-final-java-util-comparator-java-util-treemap-compar\">selenium webdriver - Unable to make field private final java.util.Comparator java.util.TreeMap.comparator accessible: java.base doesn’t “opens java.util” to unnamed module - Stack Overflow</a></p>\n<p>可采用降版本为java8规避。</p>\n</blockquote>\n<p>如成功，将在OOSRH包管理网站上查询到staging profile信息：</p>\n<p><img src=\"/images/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E6%BA%90/image-20230930004122812.png\" alt=\"image-20230930004122812\"></p>\n<blockquote>\n<p>虽然官网写了：Upon release, your component will be published to Central: this typically occurs within 30 minutes, though updates to <a href=\"https://search.maven.org/\">search</a> can take up to four hours.</p>\n<p>实际同步花个更长时间，可能大概两天，终于查到了我们要上传的包：</p>\n<p><img src=\"/images/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E6%BA%90/image-20231001174057638.png\" alt=\"image-20231001174057638\"></p>\n</blockquote>\n<p><strong>兼容性结论：</strong></p>\n<ol>\n<li>maven central对group id有严格控制，必须要得到group id管理员许可才能够提交进去</li>\n<li>如果想基于已有开源软件（如spark）合入问题修复的版本，如做了兼容性适配完善等，想提交到maven central的话，必定会收到group id权限限制，也即需要社区同意后才能合入，无法自行处理。</li>\n</ol>\n<h3 id=\"自定义maven源\"><a href=\"#自定义maven源\" class=\"headerlink\" title=\"自定义maven源\"></a>自定义maven源</h3><p>自定义maven源可以使用sonatypes nexus：<a href=\"https://zhuanlan.zhihu.com/p/544089278\">Nexus！最受欢迎的仓库管理软件 - 知乎 (zhihu.com)</a></p>\n<p>从上一章节讨论：</p>\n<ol>\n<li>nexus是介于maven central和本地之间的中转仓库，所有提交的包都会先存在于nexus这里</li>\n<li>有很多包管理网站基于nexus搭建，如OSSRH、apache基金会等</li>\n</ol>\n<p>该软件提供了图形化界面来上传包，支持除java以外的各种包类型，如npm等，详细包类型支持见<a href=\"https://help.sonatype.com/repomanager3/using-nexus-repository/uploading-components\">Uploading Components (sonatype.com)</a>。</p>\n<p>nexus本身是开源的：<a href=\"https://github.com/sonatype/nexus-public\">GitHub - sonatype&#x2F;nexus-public: Sonatype Nexus Repository Manager; Open-source codebase mirror</a></p>\n<h2 id=\"go\"><a href=\"#go\" class=\"headerlink\" title=\"go\"></a>go</h2><p>参考：<a href=\"https://go.dev/blog/using-go-modules\">Using Go Modules - The Go Programming Language</a></p>\n<p>类似maven这种包管理工具在go里面是go mod</p>\n<p>go没有像maven一样有统一的中央仓库，go引入mod完全是靠各个包所在的网络链接来include</p>\n<p>以k8s为例，<a href=\"https://github.com/kubernetes/kubernetes\">k8s仓库</a>中存在一份go.mod，打开可以看到其require方式为url：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// This is a generated file. Do not edit directly.</span></span><br><span class=\"line\"><span class=\"comment\">// Ensure you&#x27;ve carefully read</span></span><br><span class=\"line\"><span class=\"comment\">// https://git.k8s.io/community/contributors/devel/sig-architecture/vendor.md</span></span><br><span class=\"line\"><span class=\"comment\">// Run hack/pin-dependency.sh to change pinned dependency versions.</span></span><br><span class=\"line\"><span class=\"comment\">// Run hack/update-vendor.sh to update go.mod files and the vendor directory.</span></span><br><span class=\"line\"></span><br><span class=\"line\">module k8s.io/kubernetes</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">go</span> <span class=\"number\">1.20</span></span><br><span class=\"line\"></span><br><span class=\"line\">require (</span><br><span class=\"line\">\tbitbucket.org/bertimus9/systemstat v0<span class=\"number\">.5</span><span class=\"number\">.0</span></span><br><span class=\"line\">\tgithub.com/Azure/azure-sdk-<span class=\"keyword\">for</span>-<span class=\"keyword\">go</span> v68<span class=\"number\">.0</span><span class=\"number\">.0</span>+incompatible</span><br><span class=\"line\">\tgithub.com/Azure/<span class=\"keyword\">go</span>-autorest/autorest v0<span class=\"number\">.11</span><span class=\"number\">.29</span></span><br><span class=\"line\">\tgithub.com/Azure/<span class=\"keyword\">go</span>-autorest/autorest/adal v0<span class=\"number\">.9</span><span class=\"number\">.23</span></span><br><span class=\"line\">\tgithub.com/GoogleCloudPlatform/k8s-cloud-provider v1<span class=\"number\">.18</span><span class=\"number\">.1</span><span class=\"number\">-0.20220218231025</span>-f11817397a1b</span><br><span class=\"line\">\tgithub.com/JeffAshton/win_pdh v0<span class=\"number\">.0</span><span class=\"number\">.0</span><span class=\"number\">-20161109143554</span><span class=\"number\">-76</span>bb4ee9f0ab</span><br><span class=\"line\">\tgithub.com/Microsoft/<span class=\"keyword\">go</span>-winio v0<span class=\"number\">.6</span><span class=\"number\">.0</span></span><br><span class=\"line\">\tgithub.com/Microsoft/hcsshim v0<span class=\"number\">.8</span><span class=\"number\">.25</span></span><br><span class=\"line\">    ...</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>兼容性结论：</strong></p>\n<p>对于兼容性来说，因为go本身没有中央仓库管理，因此如有定制的patch等，在合入go mod官方仓库前是可以通过rpm等系统包管理机制来承载。go本身最终编译生成的文件也是一个标准系统二进制文件。</p>\n<h2 id=\"js\"><a href=\"#js\" class=\"headerlink\" title=\"js\"></a>js</h2><p>参考：</p>\n<ul>\n<li><p><a href=\"https://docs.npmjs.com/creating-and-publishing-scoped-public-packages\">Creating and publishing scoped public packages</a></p>\n</li>\n<li><p><a href=\"https://juejin.cn/post/7039140144250617887\">超详细 如何发布自己的 npm 包 - 掘金 (juejin.cn)</a></p>\n</li>\n</ul>\n<p>js的包发布通过npm即可完成，js的包也分两种，私人的和组织的，通过scope的表达方式进行（示例：<code>@xxx/hello-world</code>），这里的scope其实等价于namespace，用于预防和其他同名包冲突。不是所有的包都需要声明scope，比如vue。私人也可以发一些不带scope的包，比如shanglv-utils。</p>\n<p>因为在npm发布时要求必须要首先登录npm：<code>npm login</code>，所以不会出现私人包覆盖官方包的情况。</p>\n<p><strong>兼容性结论：</strong></p>\n<p>npm发布包的机制和python基本一致，对于官方包，当官方包已经占位的情况下，我们无法去覆盖它，如有类型兼容性的patch需要合入，只有一种方式，就是通过包官方仓库接纳。</p>\n<h2 id=\"rust\"><a href=\"#rust\" class=\"headerlink\" title=\"rust\"></a>rust</h2><p>rust是有中央仓库的：<a href=\"https://crates.io/\">crates.io: Rust Package Registry</a></p>\n<h2 id=\"ruby\"><a href=\"#ruby\" class=\"headerlink\" title=\"ruby\"></a>ruby</h2><p>ruby也有中央仓库托管各种包：<a href=\"https://rubygems.org/\">RubyGems.org</a></p>"},{"title":"程序链接","date":"2024-06-10T16:38:00.000Z","toc":true,"_content":"\n什么是程序链接？它要解决程序在编译成二进制过程中的什么问题？\n\n<!-- more -->\n\n我们可以通过以下示例来认识链接过程：\n\n```bash\nld xx.o yy.o -o prog\n```\n\n比如给定简单的main程序：\n\n```c\n#include <stdio.h>\n\nint main() {\n    printf(\"hello world\\n\");\n    return 0;\n}\n```\n\nld要解决当前main程序和printf拼接的问题。\n\n\n标准程序和非标准程序：\n\n- 标准程序：程序不依赖其他.o文件，能够自闭环执行\n- 非标准程序：程序调用了其他.o文件，需要有一个链接过程\n\n非标准程序 -> 标准程序：在编译阶段提供一个placeholder指令，在链接阶段通过观察多个.o文件后补全。\n\n在未链接前main程序汇编如下：`cc -c test.c`\n\n```bash\n[root@localhost test]# objdump -S test.o\n\ntest.o:     file format elf64-x86-64\n\n\nDisassembly of section .text:\n\n0000000000000000 <main>:\n   0:   55                      push   %rbp\n   1:   48 89 e5                mov    %rsp,%rbp\n   4:   bf 00 00 00 00          mov    $0x0,%edi\n   9:   e8 00 00 00 00          call   e <main+0xe>\n   e:   b8 00 00 00 00          mov    $0x0,%eax\n  13:   5d                      pop    %rbp\n  14:   c3                      ret\n```\n\n显然，该函数没有给出printf的代码，无法自闭环，也就不是标准程序。\n\nELF：Executable，Linkable，Format。所有链接过程都是基于ELF这样的数据结构进行。\n\n\n## Header编码\n\n```c\ntypedef struct\n{\n  unsigned char e_ident[EI_NIDENT];     /* Magic number and other info */\n  Elf64_Half    e_type;                 /* Object file type */\n  Elf64_Half    e_machine;              /* Architecture */\n  Elf64_Word    e_version;              /* Object file version */\n  Elf64_Addr    e_entry;                /* Entry point virtual address */\n  Elf64_Off     e_phoff;                /* Program header table file offset */\n  Elf64_Off     e_shoff;                /* Section header table file offset */\n  Elf64_Word    e_flags;                /* Processor-specific flags */\n  Elf64_Half    e_ehsize;               /* ELF header size in bytes */\n  Elf64_Half    e_phentsize;            /* Program header table entry size */\n  Elf64_Half    e_phnum;                /* Program header table entry count */\n  Elf64_Half    e_shentsize;            /* Section header table entry size */\n  Elf64_Half    e_shnum;                /* Section header table entry count */\n  Elf64_Half    e_shstrndx;             /* Section header string table index */\n} Elf64_Ehdr;\n```\n\nSection header table（SHT），有e_shoff、e_shentsize、e_shnum\n\n因为SHT位于ELF文件末尾，故总程序大小为：e_shoff + e_shentsize * e_shnum\n\n现在已知：\n\n- header区间：[0, e_ehsize)\n\n- Section header table区间：[e_shoff, e_shoff + e_shentsize * e_shnum)\n\n剩余的[e_ehsize, e_shoff)区间是什么内容？—— Sections，即Section header所描述的具体内容。比如：.text、.rodata等\n\n![image-20240610184504549](/images/链接/image-20240610184504549.png)\n\n\n\n## Section header编码\n\n```c\ntypedef struct\n{\n  Elf64_Word    sh_name;                /* Section name (string tbl index) */\n  Elf64_Word    sh_type;                /* Section type */\n  Elf64_Xword   sh_flags;               /* Section flags */\n  Elf64_Addr    sh_addr;                /* Section virtual addr at execution */\n  Elf64_Off     sh_offset;              /* Section file offset */\n  Elf64_Xword   sh_size;                /* Section size in bytes */\n  Elf64_Word    sh_link;                /* Link to another section */\n  Elf64_Word    sh_info;                /* Additional section information */\n  Elf64_Xword   sh_addralign;           /* Section alignment */\n  Elf64_Xword   sh_entsize;             /* Entry size if section holds table */\n} Elf64_Shdr;\n```\n\nmain程序的Section header信息：\n\n```bash\n[root@localhost test]# readelf -S test.o\nThere are 14 section headers, starting at offset 0x248:\n\nSection Headers:\n  [Nr] Name              Type             Address           Offset\n       Size              EntSize          Flags  Link  Info  Align\n  [ 0]                   NULL             0000000000000000  00000000\n       0000000000000000  0000000000000000           0     0     0\n  [ 1] .text             PROGBITS         0000000000000000  00000040\n       0000000000000015  0000000000000000  AX       0     0     1\n  [ 2] .rela.text        RELA             0000000000000000  00000188\n       0000000000000030  0000000000000018   I      11     1     8\n  [ 3] .data             PROGBITS         0000000000000000  00000055\n       0000000000000000  0000000000000000  WA       0     0     1\n  [ 4] .bss              NOBITS           0000000000000000  00000055\n       0000000000000000  0000000000000000  WA       0     0     1\n  [ 5] .rodata           PROGBITS         0000000000000000  00000055\n       000000000000000c  0000000000000000   A       0     0     1\n  [ 6] .comment          PROGBITS         0000000000000000  00000061\n       0000000000000013  0000000000000001  MS       0     0     1\n  [ 7] .note.GNU-stack   PROGBITS         0000000000000000  00000074\n       0000000000000000  0000000000000000           0     0     1\n  [ 8] .note.gnu.pr[...] NOTE             0000000000000000  00000078\n       0000000000000030  0000000000000000   A       0     0     8\n  [ 9] .eh_frame         PROGBITS         0000000000000000  000000a8\n       0000000000000038  0000000000000000   A       0     0     8\n  [10] .rela.eh_frame    RELA             0000000000000000  000001b8\n       0000000000000018  0000000000000018   I      11     9     8\n  [11] .symtab           SYMTAB           0000000000000000  000000e0\n       0000000000000090  0000000000000018          12     4     8\n  [12] .strtab           STRTAB           0000000000000000  00000170\n       0000000000000012  0000000000000000           0     0     1\n  [13] .shstrtab         STRTAB           0000000000000000  000001d0\n       0000000000000074  0000000000000000           0     0     1\n\n```\n\n.symtab：字符串表（其实不是表，是一个所有字符串的merge，所以sh_entsize为0），保存了所有程序的字符串，比如“.text”字符串即存于.symtab内\n\n.symtab：符号表，具有sh_entsize值，按照严谨的表项编排\n\n\n\n## 符号表.symtab编码\n\n```c\ntypedef struct\n{\n  Elf64_Word    st_name;                /* Symbol name (string tbl index) */\n  unsigned char st_info;                /* Symbol type and binding */\n  unsigned char st_other;               /* Symbol visibility */\n  Elf64_Section st_shndx;               /* Section index */\n  Elf64_Addr    st_value;               /* Symbol value */\n  Elf64_Xword   st_size;                /* Symbol size */\n} Elf64_Sym;\n```\n\nmain程序的符号表内容：\n\n```bash\n[root@localhost test]# readelf -s test.o\n\nSymbol table '.symtab' contains 6 entries:\n   Num:    Value          Size Type    Bind   Vis      Ndx Name\n     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND\n     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS test.c\n     2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1 .text\n     3: 0000000000000000     0 SECTION LOCAL  DEFAULT    5 .rodata\n     4: 0000000000000000    21 FUNC    GLOBAL DEFAULT    1 main\n     5: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND puts\n```\n\n当我们在解释“i = j”表达式时，分别需解释两层映射：\n\n- Environment映射：字符串到地址的映射，找到j的地址\n- State映射：地址到值的映射，解析j的值（基于j的数据类型，如int-->4Byte）。这一步由编译器来做，得到movq、movw等具有操作数长度的指令\n\nEnvironment映射又可以分2层：\n\n- external映射：映射到.text段\n- internal映射：映射到stack\n\n链接器关注external映射部分（参考：龙书、虎书、The c programing language）。\n\n给定符号表，如何找到符号的值：\n\n```bash\n# 起始地址：\nStart:\nElf64_Ehdr[Elf64_Sym.st_shndx].sh_offset + Elf64_Sym.st_value  # 这里st_value为符号的相对偏移\n# 结束地址：\nEnd:\nStart + Elf64_Sym.st_size  # 这里st_size为符号的值长度（字节、字、双字等）\n\n# 基于上述结果得到Symbol内容\nELF[Start, End)\n```\n\n\n\n## 符号表内的st_info编码\n\n```c\ntypedef struct\n{\n  Elf64_Half si_boundto;                /* Direct bindings, symbol bound to */\n  Elf64_Half si_flags;                  /* Per symbol flags */\n} Elf64_Syminfo;\n\n/* Legal values for ST_BIND subfield of st_info (symbol binding).  */\n#define STB_LOCAL       0               /* Local symbol */\n#define STB_GLOBAL      1               /* Global symbol */\n#define STB_WEAK        2               /* Weak symbol */\n...\n\n/* Legal values for ST_TYPE subfield of st_info (symbol type).  */\n#define STT_NOTYPE      0               /* Symbol type is unspecified */\n#define STT_OBJECT      1               /* Symbol is a data object */\n#define STT_FUNC        2               /* Symbol is a code object */\n...\n```\n\nSTB_WEAK：对应到__attribute((weak))修饰的变量或函数等，表示某个变量或函数符号在链接和运行时没有找到对应符号实现时默认使用当前被修饰的weak实现。\n\n符号表基于si_boundto、si_flags、st_shndx描述每个变量或函数的各种符号定义，如：\n\n```c\nint a;\nint b = 1;\nextern c = 0;\nextern d = 1;\n__attribute((weak)) e;\n__attribute((weak)) f = 1;\n\nvoid g() {\n    a = 1;\n    b = 1;\n    c = 1;\n    d = 1;\n    e = 1;\n    f = 1;\n}\n```\n\n```bash \n[root@localhost test]# readelf -s sym.o\n\nSymbol table '.symtab' contains 10 entries:\n   Num:    Value          Size Type    Bind   Vis      Ndx Name\n     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND\n     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS sym.c\n     2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1 .text\n     3: 0000000000000000     4 OBJECT  GLOBAL DEFAULT    4 a\n     4: 0000000000000000     4 OBJECT  GLOBAL DEFAULT    3 b\n     5: 0000000000000004     4 OBJECT  GLOBAL DEFAULT    4 c\n     6: 0000000000000004     4 OBJECT  GLOBAL DEFAULT    3 d\n     7: 0000000000000008     4 OBJECT  WEAK   DEFAULT    4 e\n     8: 0000000000000008     4 OBJECT  WEAK   DEFAULT    3 f\n     9: 0000000000000000    67 FUNC    GLOBAL DEFAULT    1 g\n```\n\n## 可重定位.rela编码\n\n```c\ntypedef struct\n{\n  Elf64_Addr    r_offset;               /* Address */\n  Elf64_Xword   r_info;                 /* Relocation type and symbol index */\n  Elf64_Sxword  r_addend;               /* Addend */\n} Elf64_Rela;\n\n/* How to extract and insert information held in the r_info field.  */\n#define ELF64_R_SYM(i)                  ((i) >> 32)\n#define ELF64_R_TYPE(i)                 ((i) & 0xffffffff)\n#define ELF64_R_INFO(sym,type)          ((((Elf64_Xword) (sym)) << 32) + (type))\n\n/* AMD x86-64 relocations.  */\n#define R_X86_64_64             1       /* Direct 64 bit  */\n#define R_X86_64_PC32           2       /* PC relative 32 bit signed */\n#define R_X86_64_GOT32          3       /* 32 bit GOT entry */\n#define R_X86_64_PLT32          4       /* 32 bit PLT address */\n```\n\n以下面程序为例：\n\n```c\nextern void undef_func();\nextern int undef_array[2];\n\nvoid main()\n{\n        undef_func();\n        undef_array[0] = 1;\n        undef_array[1] = 2;\n}\n```\n\n反汇编，call位置跳转的地址未知，暂时先写为0x0：\n\n```bash\n[root@localhost test]# objdump -S rel.o\n\nrel.o:     file format elf64-x86-64\n\n\nDisassembly of section .text:\n\n0000000000000000 <main>:\n   0:   55                      push   %rbp\n   1:   48 89 e5                mov    %rsp,%rbp\n   4:   b8 00 00 00 00          mov    $0x0,%eax\n   9:   e8 00 00 00 00          call   e <main+0xe>\n   e:   c7 05 00 00 00 00 01    movl   $0x1,0x0(%rip)        # 18 <main+0x18>\n  15:   00 00 00\n  18:   c7 05 00 00 00 00 02    movl   $0x2,0x0(%rip)        # 22 <main+0x22>\n  1f:   00 00 00\n  22:   90                      nop\n  23:   5d                      pop    %rbp\n  24:   c3                      ret\n```\n\nrela节内容：\n\n```bash\n[root@localhost test]# readelf -r rel.o\n\nRelocation section '.rela.text' at offset 0x198 contains 3 entries:\n  Offset          Info           Type           Sym. Value    Sym. Name + Addend\n00000000000a  000400000004 R_X86_64_PLT32    0000000000000000 undef_func - 4\n000000000010  000500000002 R_X86_64_PC32     0000000000000000 undef_array - 8\n00000000001a  000500000002 R_X86_64_PC32     0000000000000000 undef_array - 4\n\nRelocation section '.rela.eh_frame' at offset 0x1e0 contains 1 entry:\n  Offset          Info           Type           Sym. Value    Sym. Name + Addend\n000000000020  000200000002 R_X86_64_PC32     0000000000000000 .text + 0\n```\n\n结合被引用的c文件：\n\n```c\nvoid undef_func() {}\nint undef_array[2] = {-1, -2};\n```\n\n链接：\n\n```bash\nld --entry=main rel.o  reled.o -i relocated.o\n```\n\n最终call位置被写入地址：\n\n```bash\n[root@localhost test]# objdump -S relocated.o\n\nrelocated.o:     file format elf64-x86-64\n\n\nDisassembly of section .text:\n\n0000000000401000 <main>:\n  401000:       55                      push   %rbp\n  401001:       48 89 e5                mov    %rsp,%rbp\n  401004:       b8 00 00 00 00          mov    $0x0,%eax\n  401009:       e8 17 00 00 00          call   401025 <undef_func>\n  40100e:       c7 05 e8 2f 00 00 01    movl   $0x1,0x2fe8(%rip)        # 404000 <undef_array>\n  401015:       00 00 00\n  401018:       c7 05 e2 2f 00 00 02    movl   $0x2,0x2fe2(%rip)        # 404004 <undef_array+0x4>\n  40101f:       00 00 00\n  401022:       90                      nop\n  401023:       5d                      pop    %rbp\n  401024:       c3                      ret\n\n0000000000401025 <undef_func>:\n  401025:       55                      push   %rbp\n  401026:       48 89 e5                mov    %rsp,%rbp\n  401029:       90                      nop\n  40102a:       5d                      pop    %rbp\n  40102b:       c3                      ret\n```\n\n以上过程为相对寻址，基于%rip指令寄存器（总是指向下一条指令）。\n\n\n\n## 动态链接\n\n动态链接是为了解决一部分代码被多个程序引用时如何共享实现节省内存的问题。\n\n动态链接是在运行时所做的动作，无法直接确定被链接程序所在的位置，且.text在运行时无法被修改，所以不能像本地链接那样直接修改指令操作数，为此需要有个中间媒介（即GOT、PLT）辅助。\n\n动态链接分两种：\n\n- 变量的动态链接\n- 函数的动态链接\n\n\n\n变量动态链接过程基于GOT：\n\n给定例子：\n\n```c\nextern int a;\n\nvoid func()\n{\n        int local_a = a;\n}\n```\n\n如果使用常规编译，得到\n\n```bash\n0000000000000000 <func>:\n   0:   55                      push   %rbp\n   1:   48 89 e5                mov    %rsp,%rbp\n   4:   48 8b 05 00 00 00 00    mov    0x0(%rip),%rax        # b <func+0xb>\n   b:   8b 00                   mov    (%rax),%eax\n   d:   89 45 fc                mov    %eax,-0x4(%rbp)\n  10:   90                      nop\n  11:   5d                      pop    %rbp\n  12:   c3                      ret\n```\n\n如果使用-fPIC编译，得到\n\n```bash\n00000000000010f5 <func>:\n    10f5:       55                      push   %rbp\n    10f6:       48 89 e5                mov    %rsp,%rbp\n    10f9:       48 8b 05 e8 2e 00 00    mov    0x2ee8(%rip),%rax        # 3fe8 <a@Base>\n    1100:       8b 00                   mov    (%rax),%eax\n    1102:       89 45 fc                mov    %eax,-0x4(%rbp)\n    1105:       90                      nop\n    1106:       5d                      pop    %rbp\n    1107:       c3                      ret\n```\n\n此时变量寻址过程依赖了GOT表，位于.data段，表项大小为8字节，即一个地址的大小：\n\n![image-20240610231929156](/images/链接/image-20240610231929156.png)\n\nGOT表中的值由动态链接器写入。\n\n\n\n函数动态链接过程基于GOT和PLT\n\nPLT实现在.text段中，每个表项大小为16字节，由若干指令组成\n\n示例：\n\n```c\n#include <stdlib.h>\n\nvoid main()\n{\n        int *a = malloc(64 * sizeof(int));\n}\n```\n\n反汇编：\n\n```bash\nDisassembly of section .plt:\n\n0000000000401020 <malloc@plt-0x10>:\n  401020:       ff 35 e2 2f 00 00       push   0x2fe2(%rip)        # 404008 <_GLOBAL_OFFSET_TABLE_+0x8>\n  401026:       ff 25 e4 2f 00 00       jmp    *0x2fe4(%rip)        # 404010 <_GLOBAL_OFFSET_TABLE_+0x10>\n  40102c:       0f 1f 40 00             nopl   0x0(%rax)\n\n0000000000401030 <malloc@plt>:\n  401030:       ff 25 e2 2f 00 00       jmp    *0x2fe2(%rip)        # 404018 <malloc@GLIBC_2.2.5>\n  401036:       68 00 00 00 00          push   $0x0\n  40103b:       e9 e0 ff ff ff          jmp    401020 <_init+0x20>\n...\n\n0000000000401122 <main>:\n  401122:       55                      push   %rbp\n  401123:       48 89 e5                mov    %rsp,%rbp\n  401126:       48 83 ec 10             sub    $0x10,%rsp\n  40112a:       bf 00 01 00 00          mov    $0x100,%edi\n  40112f:       e8 fc fe ff ff          call   401030 <malloc@plt>\n  401134:       48 89 45 f8             mov    %rax,-0x8(%rbp)\n  401138:       90                      nop\n  401139:       c9                      leave\n  40113a:       c3                      ret\n...  \n\nDisassembly of section .got.plt:\n\n0000000000404000 <_GLOBAL_OFFSET_TABLE_>:  # 这部分本身不是指令，objdump -D dump出来的将此处认为是指令，所以解析有误\n  404000:       10 3e                   adc    %bh,(%rsi)\n  404002:       40 00 00                rex add %al,(%rax)\n        ...\n  404015:       00 00                   add    %al,(%rax)\n  404017:       00 36                   add    %dh,(%rsi)  # 404018: 36 10 40 00\n  404019:       10 40 00                adc    %al,0x0(%rax)\n  40401c:       00 00                   add    %al,(%rax)\n```\n\n函数的动态链接使用了延迟绑定技术：\n\n首次执行过程：\n\n```bash\n  40112f:       e8 fc fe ff ff          call   401030 <malloc@plt>\n  401030:       ff 25 e2 2f 00 00       jmp    *0x2fe2(%rip)        # 404018 <malloc@GLIBC_2.2.5>  跳转到GOT表中（0x401026+0x2fe2=0x404018）尝试取malloc的缓存地址。首次执行从磁盘读入为0x401036，也就跳回了<malloc@plt>中的下一条指令\n  401036:       68 00 00 00 00          push   $0x0\n  40103b:       e9 e0 ff ff ff          jmp    401020 <_init+0x20>  # 跳转到动态链接器代码段\n```\n\n动态链接器填充GOT表中的malloc地址后，再次执行时：\n\n```bash\n  40112f:       e8 fc fe ff ff          call   401030 <malloc@plt>\n  401030:       ff 25 e2 2f 00 00       jmp    *0x2fe2(%rip)        # 404018 <malloc@GLIBC_2.2.5>  跳转到GOT表中（0x401026+0x2fe2=0x404018）尝试取malloc的缓存地址。再次执行malloc缓存地址获取成功，直接跳转到malloc代码段执行，不再调用动态链接器代码\n```\n\n完整过程如下：\n\n![image-20240611002011827](/images/链接/image-20240611002011827.png)\n\nGOT为什么放在.data段？—— 可运行时修改\n\n什么是PIC（位置无关代码）？—— 此段代码利用了GOT和PLT的相对偏移在文件和在内存均一致的特性，不依赖运行时的地址（也就是给什么地址都能保持代码原有的逻辑）。\n\n","source":"_posts/程序链接.md","raw":"---\ntitle: 程序链接\ndate: 2024/06/11 00:38:00\ntoc: true\ncategories: \n - 计算机组成\ntags: \n - 底层软件\n---\n\n什么是程序链接？它要解决程序在编译成二进制过程中的什么问题？\n\n<!-- more -->\n\n我们可以通过以下示例来认识链接过程：\n\n```bash\nld xx.o yy.o -o prog\n```\n\n比如给定简单的main程序：\n\n```c\n#include <stdio.h>\n\nint main() {\n    printf(\"hello world\\n\");\n    return 0;\n}\n```\n\nld要解决当前main程序和printf拼接的问题。\n\n\n标准程序和非标准程序：\n\n- 标准程序：程序不依赖其他.o文件，能够自闭环执行\n- 非标准程序：程序调用了其他.o文件，需要有一个链接过程\n\n非标准程序 -> 标准程序：在编译阶段提供一个placeholder指令，在链接阶段通过观察多个.o文件后补全。\n\n在未链接前main程序汇编如下：`cc -c test.c`\n\n```bash\n[root@localhost test]# objdump -S test.o\n\ntest.o:     file format elf64-x86-64\n\n\nDisassembly of section .text:\n\n0000000000000000 <main>:\n   0:   55                      push   %rbp\n   1:   48 89 e5                mov    %rsp,%rbp\n   4:   bf 00 00 00 00          mov    $0x0,%edi\n   9:   e8 00 00 00 00          call   e <main+0xe>\n   e:   b8 00 00 00 00          mov    $0x0,%eax\n  13:   5d                      pop    %rbp\n  14:   c3                      ret\n```\n\n显然，该函数没有给出printf的代码，无法自闭环，也就不是标准程序。\n\nELF：Executable，Linkable，Format。所有链接过程都是基于ELF这样的数据结构进行。\n\n\n## Header编码\n\n```c\ntypedef struct\n{\n  unsigned char e_ident[EI_NIDENT];     /* Magic number and other info */\n  Elf64_Half    e_type;                 /* Object file type */\n  Elf64_Half    e_machine;              /* Architecture */\n  Elf64_Word    e_version;              /* Object file version */\n  Elf64_Addr    e_entry;                /* Entry point virtual address */\n  Elf64_Off     e_phoff;                /* Program header table file offset */\n  Elf64_Off     e_shoff;                /* Section header table file offset */\n  Elf64_Word    e_flags;                /* Processor-specific flags */\n  Elf64_Half    e_ehsize;               /* ELF header size in bytes */\n  Elf64_Half    e_phentsize;            /* Program header table entry size */\n  Elf64_Half    e_phnum;                /* Program header table entry count */\n  Elf64_Half    e_shentsize;            /* Section header table entry size */\n  Elf64_Half    e_shnum;                /* Section header table entry count */\n  Elf64_Half    e_shstrndx;             /* Section header string table index */\n} Elf64_Ehdr;\n```\n\nSection header table（SHT），有e_shoff、e_shentsize、e_shnum\n\n因为SHT位于ELF文件末尾，故总程序大小为：e_shoff + e_shentsize * e_shnum\n\n现在已知：\n\n- header区间：[0, e_ehsize)\n\n- Section header table区间：[e_shoff, e_shoff + e_shentsize * e_shnum)\n\n剩余的[e_ehsize, e_shoff)区间是什么内容？—— Sections，即Section header所描述的具体内容。比如：.text、.rodata等\n\n![image-20240610184504549](/images/链接/image-20240610184504549.png)\n\n\n\n## Section header编码\n\n```c\ntypedef struct\n{\n  Elf64_Word    sh_name;                /* Section name (string tbl index) */\n  Elf64_Word    sh_type;                /* Section type */\n  Elf64_Xword   sh_flags;               /* Section flags */\n  Elf64_Addr    sh_addr;                /* Section virtual addr at execution */\n  Elf64_Off     sh_offset;              /* Section file offset */\n  Elf64_Xword   sh_size;                /* Section size in bytes */\n  Elf64_Word    sh_link;                /* Link to another section */\n  Elf64_Word    sh_info;                /* Additional section information */\n  Elf64_Xword   sh_addralign;           /* Section alignment */\n  Elf64_Xword   sh_entsize;             /* Entry size if section holds table */\n} Elf64_Shdr;\n```\n\nmain程序的Section header信息：\n\n```bash\n[root@localhost test]# readelf -S test.o\nThere are 14 section headers, starting at offset 0x248:\n\nSection Headers:\n  [Nr] Name              Type             Address           Offset\n       Size              EntSize          Flags  Link  Info  Align\n  [ 0]                   NULL             0000000000000000  00000000\n       0000000000000000  0000000000000000           0     0     0\n  [ 1] .text             PROGBITS         0000000000000000  00000040\n       0000000000000015  0000000000000000  AX       0     0     1\n  [ 2] .rela.text        RELA             0000000000000000  00000188\n       0000000000000030  0000000000000018   I      11     1     8\n  [ 3] .data             PROGBITS         0000000000000000  00000055\n       0000000000000000  0000000000000000  WA       0     0     1\n  [ 4] .bss              NOBITS           0000000000000000  00000055\n       0000000000000000  0000000000000000  WA       0     0     1\n  [ 5] .rodata           PROGBITS         0000000000000000  00000055\n       000000000000000c  0000000000000000   A       0     0     1\n  [ 6] .comment          PROGBITS         0000000000000000  00000061\n       0000000000000013  0000000000000001  MS       0     0     1\n  [ 7] .note.GNU-stack   PROGBITS         0000000000000000  00000074\n       0000000000000000  0000000000000000           0     0     1\n  [ 8] .note.gnu.pr[...] NOTE             0000000000000000  00000078\n       0000000000000030  0000000000000000   A       0     0     8\n  [ 9] .eh_frame         PROGBITS         0000000000000000  000000a8\n       0000000000000038  0000000000000000   A       0     0     8\n  [10] .rela.eh_frame    RELA             0000000000000000  000001b8\n       0000000000000018  0000000000000018   I      11     9     8\n  [11] .symtab           SYMTAB           0000000000000000  000000e0\n       0000000000000090  0000000000000018          12     4     8\n  [12] .strtab           STRTAB           0000000000000000  00000170\n       0000000000000012  0000000000000000           0     0     1\n  [13] .shstrtab         STRTAB           0000000000000000  000001d0\n       0000000000000074  0000000000000000           0     0     1\n\n```\n\n.symtab：字符串表（其实不是表，是一个所有字符串的merge，所以sh_entsize为0），保存了所有程序的字符串，比如“.text”字符串即存于.symtab内\n\n.symtab：符号表，具有sh_entsize值，按照严谨的表项编排\n\n\n\n## 符号表.symtab编码\n\n```c\ntypedef struct\n{\n  Elf64_Word    st_name;                /* Symbol name (string tbl index) */\n  unsigned char st_info;                /* Symbol type and binding */\n  unsigned char st_other;               /* Symbol visibility */\n  Elf64_Section st_shndx;               /* Section index */\n  Elf64_Addr    st_value;               /* Symbol value */\n  Elf64_Xword   st_size;                /* Symbol size */\n} Elf64_Sym;\n```\n\nmain程序的符号表内容：\n\n```bash\n[root@localhost test]# readelf -s test.o\n\nSymbol table '.symtab' contains 6 entries:\n   Num:    Value          Size Type    Bind   Vis      Ndx Name\n     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND\n     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS test.c\n     2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1 .text\n     3: 0000000000000000     0 SECTION LOCAL  DEFAULT    5 .rodata\n     4: 0000000000000000    21 FUNC    GLOBAL DEFAULT    1 main\n     5: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND puts\n```\n\n当我们在解释“i = j”表达式时，分别需解释两层映射：\n\n- Environment映射：字符串到地址的映射，找到j的地址\n- State映射：地址到值的映射，解析j的值（基于j的数据类型，如int-->4Byte）。这一步由编译器来做，得到movq、movw等具有操作数长度的指令\n\nEnvironment映射又可以分2层：\n\n- external映射：映射到.text段\n- internal映射：映射到stack\n\n链接器关注external映射部分（参考：龙书、虎书、The c programing language）。\n\n给定符号表，如何找到符号的值：\n\n```bash\n# 起始地址：\nStart:\nElf64_Ehdr[Elf64_Sym.st_shndx].sh_offset + Elf64_Sym.st_value  # 这里st_value为符号的相对偏移\n# 结束地址：\nEnd:\nStart + Elf64_Sym.st_size  # 这里st_size为符号的值长度（字节、字、双字等）\n\n# 基于上述结果得到Symbol内容\nELF[Start, End)\n```\n\n\n\n## 符号表内的st_info编码\n\n```c\ntypedef struct\n{\n  Elf64_Half si_boundto;                /* Direct bindings, symbol bound to */\n  Elf64_Half si_flags;                  /* Per symbol flags */\n} Elf64_Syminfo;\n\n/* Legal values for ST_BIND subfield of st_info (symbol binding).  */\n#define STB_LOCAL       0               /* Local symbol */\n#define STB_GLOBAL      1               /* Global symbol */\n#define STB_WEAK        2               /* Weak symbol */\n...\n\n/* Legal values for ST_TYPE subfield of st_info (symbol type).  */\n#define STT_NOTYPE      0               /* Symbol type is unspecified */\n#define STT_OBJECT      1               /* Symbol is a data object */\n#define STT_FUNC        2               /* Symbol is a code object */\n...\n```\n\nSTB_WEAK：对应到__attribute((weak))修饰的变量或函数等，表示某个变量或函数符号在链接和运行时没有找到对应符号实现时默认使用当前被修饰的weak实现。\n\n符号表基于si_boundto、si_flags、st_shndx描述每个变量或函数的各种符号定义，如：\n\n```c\nint a;\nint b = 1;\nextern c = 0;\nextern d = 1;\n__attribute((weak)) e;\n__attribute((weak)) f = 1;\n\nvoid g() {\n    a = 1;\n    b = 1;\n    c = 1;\n    d = 1;\n    e = 1;\n    f = 1;\n}\n```\n\n```bash \n[root@localhost test]# readelf -s sym.o\n\nSymbol table '.symtab' contains 10 entries:\n   Num:    Value          Size Type    Bind   Vis      Ndx Name\n     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND\n     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS sym.c\n     2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1 .text\n     3: 0000000000000000     4 OBJECT  GLOBAL DEFAULT    4 a\n     4: 0000000000000000     4 OBJECT  GLOBAL DEFAULT    3 b\n     5: 0000000000000004     4 OBJECT  GLOBAL DEFAULT    4 c\n     6: 0000000000000004     4 OBJECT  GLOBAL DEFAULT    3 d\n     7: 0000000000000008     4 OBJECT  WEAK   DEFAULT    4 e\n     8: 0000000000000008     4 OBJECT  WEAK   DEFAULT    3 f\n     9: 0000000000000000    67 FUNC    GLOBAL DEFAULT    1 g\n```\n\n## 可重定位.rela编码\n\n```c\ntypedef struct\n{\n  Elf64_Addr    r_offset;               /* Address */\n  Elf64_Xword   r_info;                 /* Relocation type and symbol index */\n  Elf64_Sxword  r_addend;               /* Addend */\n} Elf64_Rela;\n\n/* How to extract and insert information held in the r_info field.  */\n#define ELF64_R_SYM(i)                  ((i) >> 32)\n#define ELF64_R_TYPE(i)                 ((i) & 0xffffffff)\n#define ELF64_R_INFO(sym,type)          ((((Elf64_Xword) (sym)) << 32) + (type))\n\n/* AMD x86-64 relocations.  */\n#define R_X86_64_64             1       /* Direct 64 bit  */\n#define R_X86_64_PC32           2       /* PC relative 32 bit signed */\n#define R_X86_64_GOT32          3       /* 32 bit GOT entry */\n#define R_X86_64_PLT32          4       /* 32 bit PLT address */\n```\n\n以下面程序为例：\n\n```c\nextern void undef_func();\nextern int undef_array[2];\n\nvoid main()\n{\n        undef_func();\n        undef_array[0] = 1;\n        undef_array[1] = 2;\n}\n```\n\n反汇编，call位置跳转的地址未知，暂时先写为0x0：\n\n```bash\n[root@localhost test]# objdump -S rel.o\n\nrel.o:     file format elf64-x86-64\n\n\nDisassembly of section .text:\n\n0000000000000000 <main>:\n   0:   55                      push   %rbp\n   1:   48 89 e5                mov    %rsp,%rbp\n   4:   b8 00 00 00 00          mov    $0x0,%eax\n   9:   e8 00 00 00 00          call   e <main+0xe>\n   e:   c7 05 00 00 00 00 01    movl   $0x1,0x0(%rip)        # 18 <main+0x18>\n  15:   00 00 00\n  18:   c7 05 00 00 00 00 02    movl   $0x2,0x0(%rip)        # 22 <main+0x22>\n  1f:   00 00 00\n  22:   90                      nop\n  23:   5d                      pop    %rbp\n  24:   c3                      ret\n```\n\nrela节内容：\n\n```bash\n[root@localhost test]# readelf -r rel.o\n\nRelocation section '.rela.text' at offset 0x198 contains 3 entries:\n  Offset          Info           Type           Sym. Value    Sym. Name + Addend\n00000000000a  000400000004 R_X86_64_PLT32    0000000000000000 undef_func - 4\n000000000010  000500000002 R_X86_64_PC32     0000000000000000 undef_array - 8\n00000000001a  000500000002 R_X86_64_PC32     0000000000000000 undef_array - 4\n\nRelocation section '.rela.eh_frame' at offset 0x1e0 contains 1 entry:\n  Offset          Info           Type           Sym. Value    Sym. Name + Addend\n000000000020  000200000002 R_X86_64_PC32     0000000000000000 .text + 0\n```\n\n结合被引用的c文件：\n\n```c\nvoid undef_func() {}\nint undef_array[2] = {-1, -2};\n```\n\n链接：\n\n```bash\nld --entry=main rel.o  reled.o -i relocated.o\n```\n\n最终call位置被写入地址：\n\n```bash\n[root@localhost test]# objdump -S relocated.o\n\nrelocated.o:     file format elf64-x86-64\n\n\nDisassembly of section .text:\n\n0000000000401000 <main>:\n  401000:       55                      push   %rbp\n  401001:       48 89 e5                mov    %rsp,%rbp\n  401004:       b8 00 00 00 00          mov    $0x0,%eax\n  401009:       e8 17 00 00 00          call   401025 <undef_func>\n  40100e:       c7 05 e8 2f 00 00 01    movl   $0x1,0x2fe8(%rip)        # 404000 <undef_array>\n  401015:       00 00 00\n  401018:       c7 05 e2 2f 00 00 02    movl   $0x2,0x2fe2(%rip)        # 404004 <undef_array+0x4>\n  40101f:       00 00 00\n  401022:       90                      nop\n  401023:       5d                      pop    %rbp\n  401024:       c3                      ret\n\n0000000000401025 <undef_func>:\n  401025:       55                      push   %rbp\n  401026:       48 89 e5                mov    %rsp,%rbp\n  401029:       90                      nop\n  40102a:       5d                      pop    %rbp\n  40102b:       c3                      ret\n```\n\n以上过程为相对寻址，基于%rip指令寄存器（总是指向下一条指令）。\n\n\n\n## 动态链接\n\n动态链接是为了解决一部分代码被多个程序引用时如何共享实现节省内存的问题。\n\n动态链接是在运行时所做的动作，无法直接确定被链接程序所在的位置，且.text在运行时无法被修改，所以不能像本地链接那样直接修改指令操作数，为此需要有个中间媒介（即GOT、PLT）辅助。\n\n动态链接分两种：\n\n- 变量的动态链接\n- 函数的动态链接\n\n\n\n变量动态链接过程基于GOT：\n\n给定例子：\n\n```c\nextern int a;\n\nvoid func()\n{\n        int local_a = a;\n}\n```\n\n如果使用常规编译，得到\n\n```bash\n0000000000000000 <func>:\n   0:   55                      push   %rbp\n   1:   48 89 e5                mov    %rsp,%rbp\n   4:   48 8b 05 00 00 00 00    mov    0x0(%rip),%rax        # b <func+0xb>\n   b:   8b 00                   mov    (%rax),%eax\n   d:   89 45 fc                mov    %eax,-0x4(%rbp)\n  10:   90                      nop\n  11:   5d                      pop    %rbp\n  12:   c3                      ret\n```\n\n如果使用-fPIC编译，得到\n\n```bash\n00000000000010f5 <func>:\n    10f5:       55                      push   %rbp\n    10f6:       48 89 e5                mov    %rsp,%rbp\n    10f9:       48 8b 05 e8 2e 00 00    mov    0x2ee8(%rip),%rax        # 3fe8 <a@Base>\n    1100:       8b 00                   mov    (%rax),%eax\n    1102:       89 45 fc                mov    %eax,-0x4(%rbp)\n    1105:       90                      nop\n    1106:       5d                      pop    %rbp\n    1107:       c3                      ret\n```\n\n此时变量寻址过程依赖了GOT表，位于.data段，表项大小为8字节，即一个地址的大小：\n\n![image-20240610231929156](/images/链接/image-20240610231929156.png)\n\nGOT表中的值由动态链接器写入。\n\n\n\n函数动态链接过程基于GOT和PLT\n\nPLT实现在.text段中，每个表项大小为16字节，由若干指令组成\n\n示例：\n\n```c\n#include <stdlib.h>\n\nvoid main()\n{\n        int *a = malloc(64 * sizeof(int));\n}\n```\n\n反汇编：\n\n```bash\nDisassembly of section .plt:\n\n0000000000401020 <malloc@plt-0x10>:\n  401020:       ff 35 e2 2f 00 00       push   0x2fe2(%rip)        # 404008 <_GLOBAL_OFFSET_TABLE_+0x8>\n  401026:       ff 25 e4 2f 00 00       jmp    *0x2fe4(%rip)        # 404010 <_GLOBAL_OFFSET_TABLE_+0x10>\n  40102c:       0f 1f 40 00             nopl   0x0(%rax)\n\n0000000000401030 <malloc@plt>:\n  401030:       ff 25 e2 2f 00 00       jmp    *0x2fe2(%rip)        # 404018 <malloc@GLIBC_2.2.5>\n  401036:       68 00 00 00 00          push   $0x0\n  40103b:       e9 e0 ff ff ff          jmp    401020 <_init+0x20>\n...\n\n0000000000401122 <main>:\n  401122:       55                      push   %rbp\n  401123:       48 89 e5                mov    %rsp,%rbp\n  401126:       48 83 ec 10             sub    $0x10,%rsp\n  40112a:       bf 00 01 00 00          mov    $0x100,%edi\n  40112f:       e8 fc fe ff ff          call   401030 <malloc@plt>\n  401134:       48 89 45 f8             mov    %rax,-0x8(%rbp)\n  401138:       90                      nop\n  401139:       c9                      leave\n  40113a:       c3                      ret\n...  \n\nDisassembly of section .got.plt:\n\n0000000000404000 <_GLOBAL_OFFSET_TABLE_>:  # 这部分本身不是指令，objdump -D dump出来的将此处认为是指令，所以解析有误\n  404000:       10 3e                   adc    %bh,(%rsi)\n  404002:       40 00 00                rex add %al,(%rax)\n        ...\n  404015:       00 00                   add    %al,(%rax)\n  404017:       00 36                   add    %dh,(%rsi)  # 404018: 36 10 40 00\n  404019:       10 40 00                adc    %al,0x0(%rax)\n  40401c:       00 00                   add    %al,(%rax)\n```\n\n函数的动态链接使用了延迟绑定技术：\n\n首次执行过程：\n\n```bash\n  40112f:       e8 fc fe ff ff          call   401030 <malloc@plt>\n  401030:       ff 25 e2 2f 00 00       jmp    *0x2fe2(%rip)        # 404018 <malloc@GLIBC_2.2.5>  跳转到GOT表中（0x401026+0x2fe2=0x404018）尝试取malloc的缓存地址。首次执行从磁盘读入为0x401036，也就跳回了<malloc@plt>中的下一条指令\n  401036:       68 00 00 00 00          push   $0x0\n  40103b:       e9 e0 ff ff ff          jmp    401020 <_init+0x20>  # 跳转到动态链接器代码段\n```\n\n动态链接器填充GOT表中的malloc地址后，再次执行时：\n\n```bash\n  40112f:       e8 fc fe ff ff          call   401030 <malloc@plt>\n  401030:       ff 25 e2 2f 00 00       jmp    *0x2fe2(%rip)        # 404018 <malloc@GLIBC_2.2.5>  跳转到GOT表中（0x401026+0x2fe2=0x404018）尝试取malloc的缓存地址。再次执行malloc缓存地址获取成功，直接跳转到malloc代码段执行，不再调用动态链接器代码\n```\n\n完整过程如下：\n\n![image-20240611002011827](/images/链接/image-20240611002011827.png)\n\nGOT为什么放在.data段？—— 可运行时修改\n\n什么是PIC（位置无关代码）？—— 此段代码利用了GOT和PLT的相对偏移在文件和在内存均一致的特性，不依赖运行时的地址（也就是给什么地址都能保持代码原有的逻辑）。\n\n","slug":"程序链接","published":1,"updated":"2024-08-18T08:54:01.304Z","_id":"clzzb01y40003lnp758cq3wlv","comments":1,"layout":"post","photos":[],"content":"<p>什么是程序链接？它要解决程序在编译成二进制过程中的什么问题？</p>\n<span id=\"more\"></span>\n\n<p>我们可以通过以下示例来认识链接过程：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ld xx.o yy.o -o prog</span><br></pre></td></tr></table></figure>\n\n<p>比如给定简单的main程序：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;hello world\\n&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>ld要解决当前main程序和printf拼接的问题。</p>\n<p>标准程序和非标准程序：</p>\n<ul>\n<li>标准程序：程序不依赖其他.o文件，能够自闭环执行</li>\n<li>非标准程序：程序调用了其他.o文件，需要有一个链接过程</li>\n</ul>\n<p>非标准程序 -&gt; 标准程序：在编译阶段提供一个placeholder指令，在链接阶段通过观察多个.o文件后补全。</p>\n<p>在未链接前main程序汇编如下：<code>cc -c test.c</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost <span class=\"built_in\">test</span>]<span class=\"comment\"># objdump -S test.o</span></span><br><span class=\"line\"></span><br><span class=\"line\">test.o:     file format elf64-x86-64</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Disassembly of section .text:</span><br><span class=\"line\"></span><br><span class=\"line\">0000000000000000 &lt;main&gt;:</span><br><span class=\"line\">   0:   55                      push   %rbp</span><br><span class=\"line\">   1:   48 89 e5                mov    %rsp,%rbp</span><br><span class=\"line\">   4:   bf 00 00 00 00          mov    <span class=\"variable\">$0x0</span>,%edi</span><br><span class=\"line\">   9:   e8 00 00 00 00          call   e &lt;main+0xe&gt;</span><br><span class=\"line\">   e:   b8 00 00 00 00          mov    <span class=\"variable\">$0x0</span>,%eax</span><br><span class=\"line\">  13:   5d                      pop    %rbp</span><br><span class=\"line\">  14:   c3                      ret</span><br></pre></td></tr></table></figure>\n\n<p>显然，该函数没有给出printf的代码，无法自闭环，也就不是标准程序。</p>\n<p>ELF：Executable，Linkable，Format。所有链接过程都是基于ELF这样的数据结构进行。</p>\n<h2 id=\"Header编码\"><a href=\"#Header编码\" class=\"headerlink\" title=\"Header编码\"></a>Header编码</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  <span class=\"type\">unsigned</span> <span class=\"type\">char</span> e_ident[EI_NIDENT];     <span class=\"comment\">/* Magic number and other info */</span></span><br><span class=\"line\">  Elf64_Half    e_type;                 <span class=\"comment\">/* Object file type */</span></span><br><span class=\"line\">  Elf64_Half    e_machine;              <span class=\"comment\">/* Architecture */</span></span><br><span class=\"line\">  Elf64_Word    e_version;              <span class=\"comment\">/* Object file version */</span></span><br><span class=\"line\">  Elf64_Addr    e_entry;                <span class=\"comment\">/* Entry point virtual address */</span></span><br><span class=\"line\">  Elf64_Off     e_phoff;                <span class=\"comment\">/* Program header table file offset */</span></span><br><span class=\"line\">  Elf64_Off     e_shoff;                <span class=\"comment\">/* Section header table file offset */</span></span><br><span class=\"line\">  Elf64_Word    e_flags;                <span class=\"comment\">/* Processor-specific flags */</span></span><br><span class=\"line\">  Elf64_Half    e_ehsize;               <span class=\"comment\">/* ELF header size in bytes */</span></span><br><span class=\"line\">  Elf64_Half    e_phentsize;            <span class=\"comment\">/* Program header table entry size */</span></span><br><span class=\"line\">  Elf64_Half    e_phnum;                <span class=\"comment\">/* Program header table entry count */</span></span><br><span class=\"line\">  Elf64_Half    e_shentsize;            <span class=\"comment\">/* Section header table entry size */</span></span><br><span class=\"line\">  Elf64_Half    e_shnum;                <span class=\"comment\">/* Section header table entry count */</span></span><br><span class=\"line\">  Elf64_Half    e_shstrndx;             <span class=\"comment\">/* Section header string table index */</span></span><br><span class=\"line\">&#125; Elf64_Ehdr;</span><br></pre></td></tr></table></figure>\n\n<p>Section header table（SHT），有e_shoff、e_shentsize、e_shnum</p>\n<p>因为SHT位于ELF文件末尾，故总程序大小为：e_shoff + e_shentsize * e_shnum</p>\n<p>现在已知：</p>\n<ul>\n<li><p>header区间：[0, e_ehsize)</p>\n</li>\n<li><p>Section header table区间：[e_shoff, e_shoff + e_shentsize * e_shnum)</p>\n</li>\n</ul>\n<p>剩余的[e_ehsize, e_shoff)区间是什么内容？—— Sections，即Section header所描述的具体内容。比如：.text、.rodata等</p>\n<p><img src=\"/images/%E9%93%BE%E6%8E%A5/image-20240610184504549.png\" alt=\"image-20240610184504549\"></p>\n<h2 id=\"Section-header编码\"><a href=\"#Section-header编码\" class=\"headerlink\" title=\"Section header编码\"></a>Section header编码</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  Elf64_Word    sh_name;                <span class=\"comment\">/* Section name (string tbl index) */</span></span><br><span class=\"line\">  Elf64_Word    sh_type;                <span class=\"comment\">/* Section type */</span></span><br><span class=\"line\">  Elf64_Xword   sh_flags;               <span class=\"comment\">/* Section flags */</span></span><br><span class=\"line\">  Elf64_Addr    sh_addr;                <span class=\"comment\">/* Section virtual addr at execution */</span></span><br><span class=\"line\">  Elf64_Off     sh_offset;              <span class=\"comment\">/* Section file offset */</span></span><br><span class=\"line\">  Elf64_Xword   sh_size;                <span class=\"comment\">/* Section size in bytes */</span></span><br><span class=\"line\">  Elf64_Word    sh_link;                <span class=\"comment\">/* Link to another section */</span></span><br><span class=\"line\">  Elf64_Word    sh_info;                <span class=\"comment\">/* Additional section information */</span></span><br><span class=\"line\">  Elf64_Xword   sh_addralign;           <span class=\"comment\">/* Section alignment */</span></span><br><span class=\"line\">  Elf64_Xword   sh_entsize;             <span class=\"comment\">/* Entry size if section holds table */</span></span><br><span class=\"line\">&#125; Elf64_Shdr;</span><br></pre></td></tr></table></figure>\n\n<p>main程序的Section header信息：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost <span class=\"built_in\">test</span>]<span class=\"comment\"># readelf -S test.o</span></span><br><span class=\"line\">There are 14 section headers, starting at offset 0x248:</span><br><span class=\"line\"></span><br><span class=\"line\">Section Headers:</span><br><span class=\"line\">  [Nr] Name              Type             Address           Offset</span><br><span class=\"line\">       Size              EntSize          Flags  Link  Info  Align</span><br><span class=\"line\">  [ 0]                   NULL             0000000000000000  00000000</span><br><span class=\"line\">       0000000000000000  0000000000000000           0     0     0</span><br><span class=\"line\">  [ 1] .text             PROGBITS         0000000000000000  00000040</span><br><span class=\"line\">       0000000000000015  0000000000000000  AX       0     0     1</span><br><span class=\"line\">  [ 2] .rela.text        RELA             0000000000000000  00000188</span><br><span class=\"line\">       0000000000000030  0000000000000018   I      11     1     8</span><br><span class=\"line\">  [ 3] .data             PROGBITS         0000000000000000  00000055</span><br><span class=\"line\">       0000000000000000  0000000000000000  WA       0     0     1</span><br><span class=\"line\">  [ 4] .bss              NOBITS           0000000000000000  00000055</span><br><span class=\"line\">       0000000000000000  0000000000000000  WA       0     0     1</span><br><span class=\"line\">  [ 5] .rodata           PROGBITS         0000000000000000  00000055</span><br><span class=\"line\">       000000000000000c  0000000000000000   A       0     0     1</span><br><span class=\"line\">  [ 6] .comment          PROGBITS         0000000000000000  00000061</span><br><span class=\"line\">       0000000000000013  0000000000000001  MS       0     0     1</span><br><span class=\"line\">  [ 7] .note.GNU-stack   PROGBITS         0000000000000000  00000074</span><br><span class=\"line\">       0000000000000000  0000000000000000           0     0     1</span><br><span class=\"line\">  [ 8] .note.gnu.pr[...] NOTE             0000000000000000  00000078</span><br><span class=\"line\">       0000000000000030  0000000000000000   A       0     0     8</span><br><span class=\"line\">  [ 9] .eh_frame         PROGBITS         0000000000000000  000000a8</span><br><span class=\"line\">       0000000000000038  0000000000000000   A       0     0     8</span><br><span class=\"line\">  [10] .rela.eh_frame    RELA             0000000000000000  000001b8</span><br><span class=\"line\">       0000000000000018  0000000000000018   I      11     9     8</span><br><span class=\"line\">  [11] .symtab           SYMTAB           0000000000000000  000000e0</span><br><span class=\"line\">       0000000000000090  0000000000000018          12     4     8</span><br><span class=\"line\">  [12] .strtab           STRTAB           0000000000000000  00000170</span><br><span class=\"line\">       0000000000000012  0000000000000000           0     0     1</span><br><span class=\"line\">  [13] .shstrtab         STRTAB           0000000000000000  000001d0</span><br><span class=\"line\">       0000000000000074  0000000000000000           0     0     1</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>.symtab：字符串表（其实不是表，是一个所有字符串的merge，所以sh_entsize为0），保存了所有程序的字符串，比如“.text”字符串即存于.symtab内</p>\n<p>.symtab：符号表，具有sh_entsize值，按照严谨的表项编排</p>\n<h2 id=\"符号表-symtab编码\"><a href=\"#符号表-symtab编码\" class=\"headerlink\" title=\"符号表.symtab编码\"></a>符号表.symtab编码</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  Elf64_Word    st_name;                <span class=\"comment\">/* Symbol name (string tbl index) */</span></span><br><span class=\"line\">  <span class=\"type\">unsigned</span> <span class=\"type\">char</span> st_info;                <span class=\"comment\">/* Symbol type and binding */</span></span><br><span class=\"line\">  <span class=\"type\">unsigned</span> <span class=\"type\">char</span> st_other;               <span class=\"comment\">/* Symbol visibility */</span></span><br><span class=\"line\">  Elf64_Section st_shndx;               <span class=\"comment\">/* Section index */</span></span><br><span class=\"line\">  Elf64_Addr    st_value;               <span class=\"comment\">/* Symbol value */</span></span><br><span class=\"line\">  Elf64_Xword   st_size;                <span class=\"comment\">/* Symbol size */</span></span><br><span class=\"line\">&#125; Elf64_Sym;</span><br></pre></td></tr></table></figure>\n\n<p>main程序的符号表内容：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost <span class=\"built_in\">test</span>]<span class=\"comment\"># readelf -s test.o</span></span><br><span class=\"line\"></span><br><span class=\"line\">Symbol table <span class=\"string\">&#x27;.symtab&#x27;</span> contains 6 entries:</span><br><span class=\"line\">   Num:    Value          Size Type    Bind   Vis      Ndx Name</span><br><span class=\"line\">     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND</span><br><span class=\"line\">     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS test.c</span><br><span class=\"line\">     2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1 .text</span><br><span class=\"line\">     3: 0000000000000000     0 SECTION LOCAL  DEFAULT    5 .rodata</span><br><span class=\"line\">     4: 0000000000000000    21 FUNC    GLOBAL DEFAULT    1 main</span><br><span class=\"line\">     5: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND puts</span><br></pre></td></tr></table></figure>\n\n<p>当我们在解释“i &#x3D; j”表达式时，分别需解释两层映射：</p>\n<ul>\n<li>Environment映射：字符串到地址的映射，找到j的地址</li>\n<li>State映射：地址到值的映射，解析j的值（基于j的数据类型，如int–&gt;4Byte）。这一步由编译器来做，得到movq、movw等具有操作数长度的指令</li>\n</ul>\n<p>Environment映射又可以分2层：</p>\n<ul>\n<li>external映射：映射到.text段</li>\n<li>internal映射：映射到stack</li>\n</ul>\n<p>链接器关注external映射部分（参考：龙书、虎书、The c programing language）。</p>\n<p>给定符号表，如何找到符号的值：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 起始地址：</span></span><br><span class=\"line\">Start:</span><br><span class=\"line\">Elf64_Ehdr[Elf64_Sym.st_shndx].sh_offset + Elf64_Sym.st_value  <span class=\"comment\"># 这里st_value为符号的相对偏移</span></span><br><span class=\"line\"><span class=\"comment\"># 结束地址：</span></span><br><span class=\"line\">End:</span><br><span class=\"line\">Start + Elf64_Sym.st_size  <span class=\"comment\"># 这里st_size为符号的值长度（字节、字、双字等）</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 基于上述结果得到Symbol内容</span></span><br><span class=\"line\">ELF[Start, End)</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"符号表内的st-info编码\"><a href=\"#符号表内的st-info编码\" class=\"headerlink\" title=\"符号表内的st_info编码\"></a>符号表内的st_info编码</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  Elf64_Half si_boundto;                <span class=\"comment\">/* Direct bindings, symbol bound to */</span></span><br><span class=\"line\">  Elf64_Half si_flags;                  <span class=\"comment\">/* Per symbol flags */</span></span><br><span class=\"line\">&#125; Elf64_Syminfo;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* Legal values for ST_BIND subfield of st_info (symbol binding).  */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> STB_LOCAL       0               <span class=\"comment\">/* Local symbol */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> STB_GLOBAL      1               <span class=\"comment\">/* Global symbol */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> STB_WEAK        2               <span class=\"comment\">/* Weak symbol */</span></span></span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* Legal values for ST_TYPE subfield of st_info (symbol type).  */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> STT_NOTYPE      0               <span class=\"comment\">/* Symbol type is unspecified */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> STT_OBJECT      1               <span class=\"comment\">/* Symbol is a data object */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> STT_FUNC        2               <span class=\"comment\">/* Symbol is a code object */</span></span></span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>STB_WEAK：对应到__attribute((weak))修饰的变量或函数等，表示某个变量或函数符号在链接和运行时没有找到对应符号实现时默认使用当前被修饰的weak实现。</p>\n<p>符号表基于si_boundto、si_flags、st_shndx描述每个变量或函数的各种符号定义，如：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> a;</span><br><span class=\"line\"><span class=\"type\">int</span> b = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">extern</span> c = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">extern</span> d = <span class=\"number\">1</span>;</span><br><span class=\"line\">__attribute((weak)) e;</span><br><span class=\"line\">__attribute((weak)) f = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">g</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    a = <span class=\"number\">1</span>;</span><br><span class=\"line\">    b = <span class=\"number\">1</span>;</span><br><span class=\"line\">    c = <span class=\"number\">1</span>;</span><br><span class=\"line\">    d = <span class=\"number\">1</span>;</span><br><span class=\"line\">    e = <span class=\"number\">1</span>;</span><br><span class=\"line\">    f = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost <span class=\"built_in\">test</span>]<span class=\"comment\"># readelf -s sym.o</span></span><br><span class=\"line\"></span><br><span class=\"line\">Symbol table <span class=\"string\">&#x27;.symtab&#x27;</span> contains 10 entries:</span><br><span class=\"line\">   Num:    Value          Size Type    Bind   Vis      Ndx Name</span><br><span class=\"line\">     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND</span><br><span class=\"line\">     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS sym.c</span><br><span class=\"line\">     2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1 .text</span><br><span class=\"line\">     3: 0000000000000000     4 OBJECT  GLOBAL DEFAULT    4 a</span><br><span class=\"line\">     4: 0000000000000000     4 OBJECT  GLOBAL DEFAULT    3 b</span><br><span class=\"line\">     5: 0000000000000004     4 OBJECT  GLOBAL DEFAULT    4 c</span><br><span class=\"line\">     6: 0000000000000004     4 OBJECT  GLOBAL DEFAULT    3 d</span><br><span class=\"line\">     7: 0000000000000008     4 OBJECT  WEAK   DEFAULT    4 e</span><br><span class=\"line\">     8: 0000000000000008     4 OBJECT  WEAK   DEFAULT    3 f</span><br><span class=\"line\">     9: 0000000000000000    67 FUNC    GLOBAL DEFAULT    1 g</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"可重定位-rela编码\"><a href=\"#可重定位-rela编码\" class=\"headerlink\" title=\"可重定位.rela编码\"></a>可重定位.rela编码</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  Elf64_Addr    r_offset;               <span class=\"comment\">/* Address */</span></span><br><span class=\"line\">  Elf64_Xword   r_info;                 <span class=\"comment\">/* Relocation type and symbol index */</span></span><br><span class=\"line\">  Elf64_Sxword  r_addend;               <span class=\"comment\">/* Addend */</span></span><br><span class=\"line\">&#125; Elf64_Rela;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* How to extract and insert information held in the r_info field.  */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ELF64_R_SYM(i)                  ((i) &gt;&gt; 32)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ELF64_R_TYPE(i)                 ((i) &amp; 0xffffffff)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ELF64_R_INFO(sym,type)          ((((Elf64_Xword) (sym)) &lt;&lt; 32) + (type))</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* AMD x86-64 relocations.  */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> R_X86_64_64             1       <span class=\"comment\">/* Direct 64 bit  */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> R_X86_64_PC32           2       <span class=\"comment\">/* PC relative 32 bit signed */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> R_X86_64_GOT32          3       <span class=\"comment\">/* 32 bit GOT entry */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> R_X86_64_PLT32          4       <span class=\"comment\">/* 32 bit PLT address */</span></span></span><br></pre></td></tr></table></figure>\n\n<p>以下面程序为例：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"type\">void</span> <span class=\"title function_\">undef_func</span><span class=\"params\">()</span>;</span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"type\">int</span> undef_array[<span class=\"number\">2</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        undef_func();</span><br><span class=\"line\">        undef_array[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        undef_array[<span class=\"number\">1</span>] = <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>反汇编，call位置跳转的地址未知，暂时先写为0x0：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost <span class=\"built_in\">test</span>]<span class=\"comment\"># objdump -S rel.o</span></span><br><span class=\"line\"></span><br><span class=\"line\">rel.o:     file format elf64-x86-64</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Disassembly of section .text:</span><br><span class=\"line\"></span><br><span class=\"line\">0000000000000000 &lt;main&gt;:</span><br><span class=\"line\">   0:   55                      push   %rbp</span><br><span class=\"line\">   1:   48 89 e5                mov    %rsp,%rbp</span><br><span class=\"line\">   4:   b8 00 00 00 00          mov    <span class=\"variable\">$0x0</span>,%eax</span><br><span class=\"line\">   9:   e8 00 00 00 00          call   e &lt;main+0xe&gt;</span><br><span class=\"line\">   e:   c7 05 00 00 00 00 01    movl   <span class=\"variable\">$0x1</span>,0x0(%rip)        <span class=\"comment\"># 18 &lt;main+0x18&gt;</span></span><br><span class=\"line\">  15:   00 00 00</span><br><span class=\"line\">  18:   c7 05 00 00 00 00 02    movl   <span class=\"variable\">$0x2</span>,0x0(%rip)        <span class=\"comment\"># 22 &lt;main+0x22&gt;</span></span><br><span class=\"line\">  1f:   00 00 00</span><br><span class=\"line\">  22:   90                      nop</span><br><span class=\"line\">  23:   5d                      pop    %rbp</span><br><span class=\"line\">  24:   c3                      ret</span><br></pre></td></tr></table></figure>\n\n<p>rela节内容：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost <span class=\"built_in\">test</span>]<span class=\"comment\"># readelf -r rel.o</span></span><br><span class=\"line\"></span><br><span class=\"line\">Relocation section <span class=\"string\">&#x27;.rela.text&#x27;</span> at offset 0x198 contains 3 entries:</span><br><span class=\"line\">  Offset          Info           Type           Sym. Value    Sym. Name + Addend</span><br><span class=\"line\">00000000000a  000400000004 R_X86_64_PLT32    0000000000000000 undef_func - 4</span><br><span class=\"line\">000000000010  000500000002 R_X86_64_PC32     0000000000000000 undef_array - 8</span><br><span class=\"line\">00000000001a  000500000002 R_X86_64_PC32     0000000000000000 undef_array - 4</span><br><span class=\"line\"></span><br><span class=\"line\">Relocation section <span class=\"string\">&#x27;.rela.eh_frame&#x27;</span> at offset 0x1e0 contains 1 entry:</span><br><span class=\"line\">  Offset          Info           Type           Sym. Value    Sym. Name + Addend</span><br><span class=\"line\">000000000020  000200000002 R_X86_64_PC32     0000000000000000 .text + 0</span><br></pre></td></tr></table></figure>\n\n<p>结合被引用的c文件：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">undef_func</span><span class=\"params\">()</span> &#123;&#125;</span><br><span class=\"line\"><span class=\"type\">int</span> undef_array[<span class=\"number\">2</span>] = &#123;<span class=\"number\">-1</span>, <span class=\"number\">-2</span>&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>链接：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ld --entry=main rel.o  reled.o -i relocated.o</span><br></pre></td></tr></table></figure>\n\n<p>最终call位置被写入地址：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost <span class=\"built_in\">test</span>]<span class=\"comment\"># objdump -S relocated.o</span></span><br><span class=\"line\"></span><br><span class=\"line\">relocated.o:     file format elf64-x86-64</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Disassembly of section .text:</span><br><span class=\"line\"></span><br><span class=\"line\">0000000000401000 &lt;main&gt;:</span><br><span class=\"line\">  401000:       55                      push   %rbp</span><br><span class=\"line\">  401001:       48 89 e5                mov    %rsp,%rbp</span><br><span class=\"line\">  401004:       b8 00 00 00 00          mov    <span class=\"variable\">$0x0</span>,%eax</span><br><span class=\"line\">  401009:       e8 17 00 00 00          call   401025 &lt;undef_func&gt;</span><br><span class=\"line\">  40100e:       c7 05 e8 2f 00 00 01    movl   <span class=\"variable\">$0x1</span>,0x2fe8(%rip)        <span class=\"comment\"># 404000 &lt;undef_array&gt;</span></span><br><span class=\"line\">  401015:       00 00 00</span><br><span class=\"line\">  401018:       c7 05 e2 2f 00 00 02    movl   <span class=\"variable\">$0x2</span>,0x2fe2(%rip)        <span class=\"comment\"># 404004 &lt;undef_array+0x4&gt;</span></span><br><span class=\"line\">  40101f:       00 00 00</span><br><span class=\"line\">  401022:       90                      nop</span><br><span class=\"line\">  401023:       5d                      pop    %rbp</span><br><span class=\"line\">  401024:       c3                      ret</span><br><span class=\"line\"></span><br><span class=\"line\">0000000000401025 &lt;undef_func&gt;:</span><br><span class=\"line\">  401025:       55                      push   %rbp</span><br><span class=\"line\">  401026:       48 89 e5                mov    %rsp,%rbp</span><br><span class=\"line\">  401029:       90                      nop</span><br><span class=\"line\">  40102a:       5d                      pop    %rbp</span><br><span class=\"line\">  40102b:       c3                      ret</span><br></pre></td></tr></table></figure>\n\n<p>以上过程为相对寻址，基于%rip指令寄存器（总是指向下一条指令）。</p>\n<h2 id=\"动态链接\"><a href=\"#动态链接\" class=\"headerlink\" title=\"动态链接\"></a>动态链接</h2><p>动态链接是为了解决一部分代码被多个程序引用时如何共享实现节省内存的问题。</p>\n<p>动态链接是在运行时所做的动作，无法直接确定被链接程序所在的位置，且.text在运行时无法被修改，所以不能像本地链接那样直接修改指令操作数，为此需要有个中间媒介（即GOT、PLT）辅助。</p>\n<p>动态链接分两种：</p>\n<ul>\n<li>变量的动态链接</li>\n<li>函数的动态链接</li>\n</ul>\n<p>变量动态链接过程基于GOT：</p>\n<p>给定例子：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"type\">int</span> a;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">func</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> local_a = a;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果使用常规编译，得到</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0000000000000000 &lt;func&gt;:</span><br><span class=\"line\">   0:   55                      push   %rbp</span><br><span class=\"line\">   1:   48 89 e5                mov    %rsp,%rbp</span><br><span class=\"line\">   4:   48 8b 05 00 00 00 00    mov    0x0(%rip),%rax        <span class=\"comment\"># b &lt;func+0xb&gt;</span></span><br><span class=\"line\">   b:   8b 00                   mov    (%rax),%eax</span><br><span class=\"line\">   d:   89 45 <span class=\"built_in\">fc</span>                mov    %eax,-0x4(%rbp)</span><br><span class=\"line\">  10:   90                      nop</span><br><span class=\"line\">  11:   5d                      pop    %rbp</span><br><span class=\"line\">  12:   c3                      ret</span><br></pre></td></tr></table></figure>\n\n<p>如果使用-fPIC编译，得到</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">00000000000010f5 &lt;func&gt;:</span><br><span class=\"line\">    10f5:       55                      push   %rbp</span><br><span class=\"line\">    10f6:       48 89 e5                mov    %rsp,%rbp</span><br><span class=\"line\">    10f9:       48 8b 05 e8 2e 00 00    mov    0x2ee8(%rip),%rax        <span class=\"comment\"># 3fe8 &lt;a@Base&gt;</span></span><br><span class=\"line\">    1100:       8b 00                   mov    (%rax),%eax</span><br><span class=\"line\">    1102:       89 45 <span class=\"built_in\">fc</span>                mov    %eax,-0x4(%rbp)</span><br><span class=\"line\">    1105:       90                      nop</span><br><span class=\"line\">    1106:       5d                      pop    %rbp</span><br><span class=\"line\">    1107:       c3                      ret</span><br></pre></td></tr></table></figure>\n\n<p>此时变量寻址过程依赖了GOT表，位于.data段，表项大小为8字节，即一个地址的大小：</p>\n<p><img src=\"/images/%E9%93%BE%E6%8E%A5/image-20240610231929156.png\" alt=\"image-20240610231929156\"></p>\n<p>GOT表中的值由动态链接器写入。</p>\n<p>函数动态链接过程基于GOT和PLT</p>\n<p>PLT实现在.text段中，每个表项大小为16字节，由若干指令组成</p>\n<p>示例：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> *a = <span class=\"built_in\">malloc</span>(<span class=\"number\">64</span> * <span class=\"keyword\">sizeof</span>(<span class=\"type\">int</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>反汇编：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Disassembly of section .plt:</span><br><span class=\"line\"></span><br><span class=\"line\">0000000000401020 &lt;malloc@plt-0x10&gt;:</span><br><span class=\"line\">  401020:       ff 35 e2 2f 00 00       push   0x2fe2(%rip)        <span class=\"comment\"># 404008 &lt;_GLOBAL_OFFSET_TABLE_+0x8&gt;</span></span><br><span class=\"line\">  401026:       ff 25 e4 2f 00 00       jmp    *0x2fe4(%rip)        <span class=\"comment\"># 404010 &lt;_GLOBAL_OFFSET_TABLE_+0x10&gt;</span></span><br><span class=\"line\">  40102c:       0f 1f 40 00             nopl   0x0(%rax)</span><br><span class=\"line\"></span><br><span class=\"line\">0000000000401030 &lt;malloc@plt&gt;:</span><br><span class=\"line\">  401030:       ff 25 e2 2f 00 00       jmp    *0x2fe2(%rip)        <span class=\"comment\"># 404018 &lt;malloc@GLIBC_2.2.5&gt;</span></span><br><span class=\"line\">  401036:       68 00 00 00 00          push   <span class=\"variable\">$0x0</span></span><br><span class=\"line\">  40103b:       e9 e0 ff ff ff          jmp    401020 &lt;_init+0x20&gt;</span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">0000000000401122 &lt;main&gt;:</span><br><span class=\"line\">  401122:       55                      push   %rbp</span><br><span class=\"line\">  401123:       48 89 e5                mov    %rsp,%rbp</span><br><span class=\"line\">  401126:       48 83 ec 10             sub    <span class=\"variable\">$0x10</span>,%rsp</span><br><span class=\"line\">  40112a:       bf 00 01 00 00          mov    <span class=\"variable\">$0x100</span>,%edi</span><br><span class=\"line\">  40112f:       e8 <span class=\"built_in\">fc</span> fe ff ff          call   401030 &lt;malloc@plt&gt;</span><br><span class=\"line\">  401134:       48 89 45 f8             mov    %rax,-0x8(%rbp)</span><br><span class=\"line\">  401138:       90                      nop</span><br><span class=\"line\">  401139:       c9                      leave</span><br><span class=\"line\">  40113a:       c3                      ret</span><br><span class=\"line\">...  </span><br><span class=\"line\"></span><br><span class=\"line\">Disassembly of section .got.plt:</span><br><span class=\"line\"></span><br><span class=\"line\">0000000000404000 &lt;_GLOBAL_OFFSET_TABLE_&gt;:  <span class=\"comment\"># 这部分本身不是指令，objdump -D dump出来的将此处认为是指令，所以解析有误</span></span><br><span class=\"line\">  404000:       10 3e                   adc    %bh,(%rsi)</span><br><span class=\"line\">  404002:       40 00 00                rex add %al,(%rax)</span><br><span class=\"line\">        ...</span><br><span class=\"line\">  404015:       00 00                   add    %al,(%rax)</span><br><span class=\"line\">  404017:       00 36                   add    %dh,(%rsi)  <span class=\"comment\"># 404018: 36 10 40 00</span></span><br><span class=\"line\">  404019:       10 40 00                adc    %al,0x0(%rax)</span><br><span class=\"line\">  40401c:       00 00                   add    %al,(%rax)</span><br></pre></td></tr></table></figure>\n\n<p>函数的动态链接使用了延迟绑定技术：</p>\n<p>首次执行过程：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">40112f:       e8 <span class=\"built_in\">fc</span> fe ff ff          call   401030 &lt;malloc@plt&gt;</span><br><span class=\"line\">401030:       ff 25 e2 2f 00 00       jmp    *0x2fe2(%rip)        <span class=\"comment\"># 404018 &lt;malloc@GLIBC_2.2.5&gt;  跳转到GOT表中（0x401026+0x2fe2=0x404018）尝试取malloc的缓存地址。首次执行从磁盘读入为0x401036，也就跳回了&lt;malloc@plt&gt;中的下一条指令</span></span><br><span class=\"line\">401036:       68 00 00 00 00          push   <span class=\"variable\">$0x0</span></span><br><span class=\"line\">40103b:       e9 e0 ff ff ff          jmp    401020 &lt;_init+0x20&gt;  <span class=\"comment\"># 跳转到动态链接器代码段</span></span><br></pre></td></tr></table></figure>\n\n<p>动态链接器填充GOT表中的malloc地址后，再次执行时：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">40112f:       e8 <span class=\"built_in\">fc</span> fe ff ff          call   401030 &lt;malloc@plt&gt;</span><br><span class=\"line\">401030:       ff 25 e2 2f 00 00       jmp    *0x2fe2(%rip)        <span class=\"comment\"># 404018 &lt;malloc@GLIBC_2.2.5&gt;  跳转到GOT表中（0x401026+0x2fe2=0x404018）尝试取malloc的缓存地址。再次执行malloc缓存地址获取成功，直接跳转到malloc代码段执行，不再调用动态链接器代码</span></span><br></pre></td></tr></table></figure>\n\n<p>完整过程如下：</p>\n<p><img src=\"/images/%E9%93%BE%E6%8E%A5/image-20240611002011827.png\" alt=\"image-20240611002011827\"></p>\n<p>GOT为什么放在.data段？—— 可运行时修改</p>\n<p>什么是PIC（位置无关代码）？—— 此段代码利用了GOT和PLT的相对偏移在文件和在内存均一致的特性，不依赖运行时的地址（也就是给什么地址都能保持代码原有的逻辑）。</p>\n","excerpt":"<p>什么是程序链接？它要解决程序在编译成二进制过程中的什么问题？</p>","more":"<p>我们可以通过以下示例来认识链接过程：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ld xx.o yy.o -o prog</span><br></pre></td></tr></table></figure>\n\n<p>比如给定简单的main程序：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;hello world\\n&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>ld要解决当前main程序和printf拼接的问题。</p>\n<p>标准程序和非标准程序：</p>\n<ul>\n<li>标准程序：程序不依赖其他.o文件，能够自闭环执行</li>\n<li>非标准程序：程序调用了其他.o文件，需要有一个链接过程</li>\n</ul>\n<p>非标准程序 -&gt; 标准程序：在编译阶段提供一个placeholder指令，在链接阶段通过观察多个.o文件后补全。</p>\n<p>在未链接前main程序汇编如下：<code>cc -c test.c</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost <span class=\"built_in\">test</span>]<span class=\"comment\"># objdump -S test.o</span></span><br><span class=\"line\"></span><br><span class=\"line\">test.o:     file format elf64-x86-64</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Disassembly of section .text:</span><br><span class=\"line\"></span><br><span class=\"line\">0000000000000000 &lt;main&gt;:</span><br><span class=\"line\">   0:   55                      push   %rbp</span><br><span class=\"line\">   1:   48 89 e5                mov    %rsp,%rbp</span><br><span class=\"line\">   4:   bf 00 00 00 00          mov    <span class=\"variable\">$0x0</span>,%edi</span><br><span class=\"line\">   9:   e8 00 00 00 00          call   e &lt;main+0xe&gt;</span><br><span class=\"line\">   e:   b8 00 00 00 00          mov    <span class=\"variable\">$0x0</span>,%eax</span><br><span class=\"line\">  13:   5d                      pop    %rbp</span><br><span class=\"line\">  14:   c3                      ret</span><br></pre></td></tr></table></figure>\n\n<p>显然，该函数没有给出printf的代码，无法自闭环，也就不是标准程序。</p>\n<p>ELF：Executable，Linkable，Format。所有链接过程都是基于ELF这样的数据结构进行。</p>\n<h2 id=\"Header编码\"><a href=\"#Header编码\" class=\"headerlink\" title=\"Header编码\"></a>Header编码</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  <span class=\"type\">unsigned</span> <span class=\"type\">char</span> e_ident[EI_NIDENT];     <span class=\"comment\">/* Magic number and other info */</span></span><br><span class=\"line\">  Elf64_Half    e_type;                 <span class=\"comment\">/* Object file type */</span></span><br><span class=\"line\">  Elf64_Half    e_machine;              <span class=\"comment\">/* Architecture */</span></span><br><span class=\"line\">  Elf64_Word    e_version;              <span class=\"comment\">/* Object file version */</span></span><br><span class=\"line\">  Elf64_Addr    e_entry;                <span class=\"comment\">/* Entry point virtual address */</span></span><br><span class=\"line\">  Elf64_Off     e_phoff;                <span class=\"comment\">/* Program header table file offset */</span></span><br><span class=\"line\">  Elf64_Off     e_shoff;                <span class=\"comment\">/* Section header table file offset */</span></span><br><span class=\"line\">  Elf64_Word    e_flags;                <span class=\"comment\">/* Processor-specific flags */</span></span><br><span class=\"line\">  Elf64_Half    e_ehsize;               <span class=\"comment\">/* ELF header size in bytes */</span></span><br><span class=\"line\">  Elf64_Half    e_phentsize;            <span class=\"comment\">/* Program header table entry size */</span></span><br><span class=\"line\">  Elf64_Half    e_phnum;                <span class=\"comment\">/* Program header table entry count */</span></span><br><span class=\"line\">  Elf64_Half    e_shentsize;            <span class=\"comment\">/* Section header table entry size */</span></span><br><span class=\"line\">  Elf64_Half    e_shnum;                <span class=\"comment\">/* Section header table entry count */</span></span><br><span class=\"line\">  Elf64_Half    e_shstrndx;             <span class=\"comment\">/* Section header string table index */</span></span><br><span class=\"line\">&#125; Elf64_Ehdr;</span><br></pre></td></tr></table></figure>\n\n<p>Section header table（SHT），有e_shoff、e_shentsize、e_shnum</p>\n<p>因为SHT位于ELF文件末尾，故总程序大小为：e_shoff + e_shentsize * e_shnum</p>\n<p>现在已知：</p>\n<ul>\n<li><p>header区间：[0, e_ehsize)</p>\n</li>\n<li><p>Section header table区间：[e_shoff, e_shoff + e_shentsize * e_shnum)</p>\n</li>\n</ul>\n<p>剩余的[e_ehsize, e_shoff)区间是什么内容？—— Sections，即Section header所描述的具体内容。比如：.text、.rodata等</p>\n<p><img src=\"/images/%E9%93%BE%E6%8E%A5/image-20240610184504549.png\" alt=\"image-20240610184504549\"></p>\n<h2 id=\"Section-header编码\"><a href=\"#Section-header编码\" class=\"headerlink\" title=\"Section header编码\"></a>Section header编码</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  Elf64_Word    sh_name;                <span class=\"comment\">/* Section name (string tbl index) */</span></span><br><span class=\"line\">  Elf64_Word    sh_type;                <span class=\"comment\">/* Section type */</span></span><br><span class=\"line\">  Elf64_Xword   sh_flags;               <span class=\"comment\">/* Section flags */</span></span><br><span class=\"line\">  Elf64_Addr    sh_addr;                <span class=\"comment\">/* Section virtual addr at execution */</span></span><br><span class=\"line\">  Elf64_Off     sh_offset;              <span class=\"comment\">/* Section file offset */</span></span><br><span class=\"line\">  Elf64_Xword   sh_size;                <span class=\"comment\">/* Section size in bytes */</span></span><br><span class=\"line\">  Elf64_Word    sh_link;                <span class=\"comment\">/* Link to another section */</span></span><br><span class=\"line\">  Elf64_Word    sh_info;                <span class=\"comment\">/* Additional section information */</span></span><br><span class=\"line\">  Elf64_Xword   sh_addralign;           <span class=\"comment\">/* Section alignment */</span></span><br><span class=\"line\">  Elf64_Xword   sh_entsize;             <span class=\"comment\">/* Entry size if section holds table */</span></span><br><span class=\"line\">&#125; Elf64_Shdr;</span><br></pre></td></tr></table></figure>\n\n<p>main程序的Section header信息：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost <span class=\"built_in\">test</span>]<span class=\"comment\"># readelf -S test.o</span></span><br><span class=\"line\">There are 14 section headers, starting at offset 0x248:</span><br><span class=\"line\"></span><br><span class=\"line\">Section Headers:</span><br><span class=\"line\">  [Nr] Name              Type             Address           Offset</span><br><span class=\"line\">       Size              EntSize          Flags  Link  Info  Align</span><br><span class=\"line\">  [ 0]                   NULL             0000000000000000  00000000</span><br><span class=\"line\">       0000000000000000  0000000000000000           0     0     0</span><br><span class=\"line\">  [ 1] .text             PROGBITS         0000000000000000  00000040</span><br><span class=\"line\">       0000000000000015  0000000000000000  AX       0     0     1</span><br><span class=\"line\">  [ 2] .rela.text        RELA             0000000000000000  00000188</span><br><span class=\"line\">       0000000000000030  0000000000000018   I      11     1     8</span><br><span class=\"line\">  [ 3] .data             PROGBITS         0000000000000000  00000055</span><br><span class=\"line\">       0000000000000000  0000000000000000  WA       0     0     1</span><br><span class=\"line\">  [ 4] .bss              NOBITS           0000000000000000  00000055</span><br><span class=\"line\">       0000000000000000  0000000000000000  WA       0     0     1</span><br><span class=\"line\">  [ 5] .rodata           PROGBITS         0000000000000000  00000055</span><br><span class=\"line\">       000000000000000c  0000000000000000   A       0     0     1</span><br><span class=\"line\">  [ 6] .comment          PROGBITS         0000000000000000  00000061</span><br><span class=\"line\">       0000000000000013  0000000000000001  MS       0     0     1</span><br><span class=\"line\">  [ 7] .note.GNU-stack   PROGBITS         0000000000000000  00000074</span><br><span class=\"line\">       0000000000000000  0000000000000000           0     0     1</span><br><span class=\"line\">  [ 8] .note.gnu.pr[...] NOTE             0000000000000000  00000078</span><br><span class=\"line\">       0000000000000030  0000000000000000   A       0     0     8</span><br><span class=\"line\">  [ 9] .eh_frame         PROGBITS         0000000000000000  000000a8</span><br><span class=\"line\">       0000000000000038  0000000000000000   A       0     0     8</span><br><span class=\"line\">  [10] .rela.eh_frame    RELA             0000000000000000  000001b8</span><br><span class=\"line\">       0000000000000018  0000000000000018   I      11     9     8</span><br><span class=\"line\">  [11] .symtab           SYMTAB           0000000000000000  000000e0</span><br><span class=\"line\">       0000000000000090  0000000000000018          12     4     8</span><br><span class=\"line\">  [12] .strtab           STRTAB           0000000000000000  00000170</span><br><span class=\"line\">       0000000000000012  0000000000000000           0     0     1</span><br><span class=\"line\">  [13] .shstrtab         STRTAB           0000000000000000  000001d0</span><br><span class=\"line\">       0000000000000074  0000000000000000           0     0     1</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>.symtab：字符串表（其实不是表，是一个所有字符串的merge，所以sh_entsize为0），保存了所有程序的字符串，比如“.text”字符串即存于.symtab内</p>\n<p>.symtab：符号表，具有sh_entsize值，按照严谨的表项编排</p>\n<h2 id=\"符号表-symtab编码\"><a href=\"#符号表-symtab编码\" class=\"headerlink\" title=\"符号表.symtab编码\"></a>符号表.symtab编码</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  Elf64_Word    st_name;                <span class=\"comment\">/* Symbol name (string tbl index) */</span></span><br><span class=\"line\">  <span class=\"type\">unsigned</span> <span class=\"type\">char</span> st_info;                <span class=\"comment\">/* Symbol type and binding */</span></span><br><span class=\"line\">  <span class=\"type\">unsigned</span> <span class=\"type\">char</span> st_other;               <span class=\"comment\">/* Symbol visibility */</span></span><br><span class=\"line\">  Elf64_Section st_shndx;               <span class=\"comment\">/* Section index */</span></span><br><span class=\"line\">  Elf64_Addr    st_value;               <span class=\"comment\">/* Symbol value */</span></span><br><span class=\"line\">  Elf64_Xword   st_size;                <span class=\"comment\">/* Symbol size */</span></span><br><span class=\"line\">&#125; Elf64_Sym;</span><br></pre></td></tr></table></figure>\n\n<p>main程序的符号表内容：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost <span class=\"built_in\">test</span>]<span class=\"comment\"># readelf -s test.o</span></span><br><span class=\"line\"></span><br><span class=\"line\">Symbol table <span class=\"string\">&#x27;.symtab&#x27;</span> contains 6 entries:</span><br><span class=\"line\">   Num:    Value          Size Type    Bind   Vis      Ndx Name</span><br><span class=\"line\">     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND</span><br><span class=\"line\">     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS test.c</span><br><span class=\"line\">     2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1 .text</span><br><span class=\"line\">     3: 0000000000000000     0 SECTION LOCAL  DEFAULT    5 .rodata</span><br><span class=\"line\">     4: 0000000000000000    21 FUNC    GLOBAL DEFAULT    1 main</span><br><span class=\"line\">     5: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND puts</span><br></pre></td></tr></table></figure>\n\n<p>当我们在解释“i &#x3D; j”表达式时，分别需解释两层映射：</p>\n<ul>\n<li>Environment映射：字符串到地址的映射，找到j的地址</li>\n<li>State映射：地址到值的映射，解析j的值（基于j的数据类型，如int–&gt;4Byte）。这一步由编译器来做，得到movq、movw等具有操作数长度的指令</li>\n</ul>\n<p>Environment映射又可以分2层：</p>\n<ul>\n<li>external映射：映射到.text段</li>\n<li>internal映射：映射到stack</li>\n</ul>\n<p>链接器关注external映射部分（参考：龙书、虎书、The c programing language）。</p>\n<p>给定符号表，如何找到符号的值：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 起始地址：</span></span><br><span class=\"line\">Start:</span><br><span class=\"line\">Elf64_Ehdr[Elf64_Sym.st_shndx].sh_offset + Elf64_Sym.st_value  <span class=\"comment\"># 这里st_value为符号的相对偏移</span></span><br><span class=\"line\"><span class=\"comment\"># 结束地址：</span></span><br><span class=\"line\">End:</span><br><span class=\"line\">Start + Elf64_Sym.st_size  <span class=\"comment\"># 这里st_size为符号的值长度（字节、字、双字等）</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 基于上述结果得到Symbol内容</span></span><br><span class=\"line\">ELF[Start, End)</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"符号表内的st-info编码\"><a href=\"#符号表内的st-info编码\" class=\"headerlink\" title=\"符号表内的st_info编码\"></a>符号表内的st_info编码</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  Elf64_Half si_boundto;                <span class=\"comment\">/* Direct bindings, symbol bound to */</span></span><br><span class=\"line\">  Elf64_Half si_flags;                  <span class=\"comment\">/* Per symbol flags */</span></span><br><span class=\"line\">&#125; Elf64_Syminfo;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* Legal values for ST_BIND subfield of st_info (symbol binding).  */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> STB_LOCAL       0               <span class=\"comment\">/* Local symbol */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> STB_GLOBAL      1               <span class=\"comment\">/* Global symbol */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> STB_WEAK        2               <span class=\"comment\">/* Weak symbol */</span></span></span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* Legal values for ST_TYPE subfield of st_info (symbol type).  */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> STT_NOTYPE      0               <span class=\"comment\">/* Symbol type is unspecified */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> STT_OBJECT      1               <span class=\"comment\">/* Symbol is a data object */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> STT_FUNC        2               <span class=\"comment\">/* Symbol is a code object */</span></span></span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>STB_WEAK：对应到__attribute((weak))修饰的变量或函数等，表示某个变量或函数符号在链接和运行时没有找到对应符号实现时默认使用当前被修饰的weak实现。</p>\n<p>符号表基于si_boundto、si_flags、st_shndx描述每个变量或函数的各种符号定义，如：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> a;</span><br><span class=\"line\"><span class=\"type\">int</span> b = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">extern</span> c = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">extern</span> d = <span class=\"number\">1</span>;</span><br><span class=\"line\">__attribute((weak)) e;</span><br><span class=\"line\">__attribute((weak)) f = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">g</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    a = <span class=\"number\">1</span>;</span><br><span class=\"line\">    b = <span class=\"number\">1</span>;</span><br><span class=\"line\">    c = <span class=\"number\">1</span>;</span><br><span class=\"line\">    d = <span class=\"number\">1</span>;</span><br><span class=\"line\">    e = <span class=\"number\">1</span>;</span><br><span class=\"line\">    f = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost <span class=\"built_in\">test</span>]<span class=\"comment\"># readelf -s sym.o</span></span><br><span class=\"line\"></span><br><span class=\"line\">Symbol table <span class=\"string\">&#x27;.symtab&#x27;</span> contains 10 entries:</span><br><span class=\"line\">   Num:    Value          Size Type    Bind   Vis      Ndx Name</span><br><span class=\"line\">     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND</span><br><span class=\"line\">     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS sym.c</span><br><span class=\"line\">     2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1 .text</span><br><span class=\"line\">     3: 0000000000000000     4 OBJECT  GLOBAL DEFAULT    4 a</span><br><span class=\"line\">     4: 0000000000000000     4 OBJECT  GLOBAL DEFAULT    3 b</span><br><span class=\"line\">     5: 0000000000000004     4 OBJECT  GLOBAL DEFAULT    4 c</span><br><span class=\"line\">     6: 0000000000000004     4 OBJECT  GLOBAL DEFAULT    3 d</span><br><span class=\"line\">     7: 0000000000000008     4 OBJECT  WEAK   DEFAULT    4 e</span><br><span class=\"line\">     8: 0000000000000008     4 OBJECT  WEAK   DEFAULT    3 f</span><br><span class=\"line\">     9: 0000000000000000    67 FUNC    GLOBAL DEFAULT    1 g</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"可重定位-rela编码\"><a href=\"#可重定位-rela编码\" class=\"headerlink\" title=\"可重定位.rela编码\"></a>可重定位.rela编码</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  Elf64_Addr    r_offset;               <span class=\"comment\">/* Address */</span></span><br><span class=\"line\">  Elf64_Xword   r_info;                 <span class=\"comment\">/* Relocation type and symbol index */</span></span><br><span class=\"line\">  Elf64_Sxword  r_addend;               <span class=\"comment\">/* Addend */</span></span><br><span class=\"line\">&#125; Elf64_Rela;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* How to extract and insert information held in the r_info field.  */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ELF64_R_SYM(i)                  ((i) &gt;&gt; 32)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ELF64_R_TYPE(i)                 ((i) &amp; 0xffffffff)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ELF64_R_INFO(sym,type)          ((((Elf64_Xword) (sym)) &lt;&lt; 32) + (type))</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* AMD x86-64 relocations.  */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> R_X86_64_64             1       <span class=\"comment\">/* Direct 64 bit  */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> R_X86_64_PC32           2       <span class=\"comment\">/* PC relative 32 bit signed */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> R_X86_64_GOT32          3       <span class=\"comment\">/* 32 bit GOT entry */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> R_X86_64_PLT32          4       <span class=\"comment\">/* 32 bit PLT address */</span></span></span><br></pre></td></tr></table></figure>\n\n<p>以下面程序为例：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"type\">void</span> <span class=\"title function_\">undef_func</span><span class=\"params\">()</span>;</span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"type\">int</span> undef_array[<span class=\"number\">2</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        undef_func();</span><br><span class=\"line\">        undef_array[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        undef_array[<span class=\"number\">1</span>] = <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>反汇编，call位置跳转的地址未知，暂时先写为0x0：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost <span class=\"built_in\">test</span>]<span class=\"comment\"># objdump -S rel.o</span></span><br><span class=\"line\"></span><br><span class=\"line\">rel.o:     file format elf64-x86-64</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Disassembly of section .text:</span><br><span class=\"line\"></span><br><span class=\"line\">0000000000000000 &lt;main&gt;:</span><br><span class=\"line\">   0:   55                      push   %rbp</span><br><span class=\"line\">   1:   48 89 e5                mov    %rsp,%rbp</span><br><span class=\"line\">   4:   b8 00 00 00 00          mov    <span class=\"variable\">$0x0</span>,%eax</span><br><span class=\"line\">   9:   e8 00 00 00 00          call   e &lt;main+0xe&gt;</span><br><span class=\"line\">   e:   c7 05 00 00 00 00 01    movl   <span class=\"variable\">$0x1</span>,0x0(%rip)        <span class=\"comment\"># 18 &lt;main+0x18&gt;</span></span><br><span class=\"line\">  15:   00 00 00</span><br><span class=\"line\">  18:   c7 05 00 00 00 00 02    movl   <span class=\"variable\">$0x2</span>,0x0(%rip)        <span class=\"comment\"># 22 &lt;main+0x22&gt;</span></span><br><span class=\"line\">  1f:   00 00 00</span><br><span class=\"line\">  22:   90                      nop</span><br><span class=\"line\">  23:   5d                      pop    %rbp</span><br><span class=\"line\">  24:   c3                      ret</span><br></pre></td></tr></table></figure>\n\n<p>rela节内容：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost <span class=\"built_in\">test</span>]<span class=\"comment\"># readelf -r rel.o</span></span><br><span class=\"line\"></span><br><span class=\"line\">Relocation section <span class=\"string\">&#x27;.rela.text&#x27;</span> at offset 0x198 contains 3 entries:</span><br><span class=\"line\">  Offset          Info           Type           Sym. Value    Sym. Name + Addend</span><br><span class=\"line\">00000000000a  000400000004 R_X86_64_PLT32    0000000000000000 undef_func - 4</span><br><span class=\"line\">000000000010  000500000002 R_X86_64_PC32     0000000000000000 undef_array - 8</span><br><span class=\"line\">00000000001a  000500000002 R_X86_64_PC32     0000000000000000 undef_array - 4</span><br><span class=\"line\"></span><br><span class=\"line\">Relocation section <span class=\"string\">&#x27;.rela.eh_frame&#x27;</span> at offset 0x1e0 contains 1 entry:</span><br><span class=\"line\">  Offset          Info           Type           Sym. Value    Sym. Name + Addend</span><br><span class=\"line\">000000000020  000200000002 R_X86_64_PC32     0000000000000000 .text + 0</span><br></pre></td></tr></table></figure>\n\n<p>结合被引用的c文件：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">undef_func</span><span class=\"params\">()</span> &#123;&#125;</span><br><span class=\"line\"><span class=\"type\">int</span> undef_array[<span class=\"number\">2</span>] = &#123;<span class=\"number\">-1</span>, <span class=\"number\">-2</span>&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>链接：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ld --entry=main rel.o  reled.o -i relocated.o</span><br></pre></td></tr></table></figure>\n\n<p>最终call位置被写入地址：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost <span class=\"built_in\">test</span>]<span class=\"comment\"># objdump -S relocated.o</span></span><br><span class=\"line\"></span><br><span class=\"line\">relocated.o:     file format elf64-x86-64</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Disassembly of section .text:</span><br><span class=\"line\"></span><br><span class=\"line\">0000000000401000 &lt;main&gt;:</span><br><span class=\"line\">  401000:       55                      push   %rbp</span><br><span class=\"line\">  401001:       48 89 e5                mov    %rsp,%rbp</span><br><span class=\"line\">  401004:       b8 00 00 00 00          mov    <span class=\"variable\">$0x0</span>,%eax</span><br><span class=\"line\">  401009:       e8 17 00 00 00          call   401025 &lt;undef_func&gt;</span><br><span class=\"line\">  40100e:       c7 05 e8 2f 00 00 01    movl   <span class=\"variable\">$0x1</span>,0x2fe8(%rip)        <span class=\"comment\"># 404000 &lt;undef_array&gt;</span></span><br><span class=\"line\">  401015:       00 00 00</span><br><span class=\"line\">  401018:       c7 05 e2 2f 00 00 02    movl   <span class=\"variable\">$0x2</span>,0x2fe2(%rip)        <span class=\"comment\"># 404004 &lt;undef_array+0x4&gt;</span></span><br><span class=\"line\">  40101f:       00 00 00</span><br><span class=\"line\">  401022:       90                      nop</span><br><span class=\"line\">  401023:       5d                      pop    %rbp</span><br><span class=\"line\">  401024:       c3                      ret</span><br><span class=\"line\"></span><br><span class=\"line\">0000000000401025 &lt;undef_func&gt;:</span><br><span class=\"line\">  401025:       55                      push   %rbp</span><br><span class=\"line\">  401026:       48 89 e5                mov    %rsp,%rbp</span><br><span class=\"line\">  401029:       90                      nop</span><br><span class=\"line\">  40102a:       5d                      pop    %rbp</span><br><span class=\"line\">  40102b:       c3                      ret</span><br></pre></td></tr></table></figure>\n\n<p>以上过程为相对寻址，基于%rip指令寄存器（总是指向下一条指令）。</p>\n<h2 id=\"动态链接\"><a href=\"#动态链接\" class=\"headerlink\" title=\"动态链接\"></a>动态链接</h2><p>动态链接是为了解决一部分代码被多个程序引用时如何共享实现节省内存的问题。</p>\n<p>动态链接是在运行时所做的动作，无法直接确定被链接程序所在的位置，且.text在运行时无法被修改，所以不能像本地链接那样直接修改指令操作数，为此需要有个中间媒介（即GOT、PLT）辅助。</p>\n<p>动态链接分两种：</p>\n<ul>\n<li>变量的动态链接</li>\n<li>函数的动态链接</li>\n</ul>\n<p>变量动态链接过程基于GOT：</p>\n<p>给定例子：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"type\">int</span> a;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">func</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> local_a = a;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果使用常规编译，得到</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0000000000000000 &lt;func&gt;:</span><br><span class=\"line\">   0:   55                      push   %rbp</span><br><span class=\"line\">   1:   48 89 e5                mov    %rsp,%rbp</span><br><span class=\"line\">   4:   48 8b 05 00 00 00 00    mov    0x0(%rip),%rax        <span class=\"comment\"># b &lt;func+0xb&gt;</span></span><br><span class=\"line\">   b:   8b 00                   mov    (%rax),%eax</span><br><span class=\"line\">   d:   89 45 <span class=\"built_in\">fc</span>                mov    %eax,-0x4(%rbp)</span><br><span class=\"line\">  10:   90                      nop</span><br><span class=\"line\">  11:   5d                      pop    %rbp</span><br><span class=\"line\">  12:   c3                      ret</span><br></pre></td></tr></table></figure>\n\n<p>如果使用-fPIC编译，得到</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">00000000000010f5 &lt;func&gt;:</span><br><span class=\"line\">    10f5:       55                      push   %rbp</span><br><span class=\"line\">    10f6:       48 89 e5                mov    %rsp,%rbp</span><br><span class=\"line\">    10f9:       48 8b 05 e8 2e 00 00    mov    0x2ee8(%rip),%rax        <span class=\"comment\"># 3fe8 &lt;a@Base&gt;</span></span><br><span class=\"line\">    1100:       8b 00                   mov    (%rax),%eax</span><br><span class=\"line\">    1102:       89 45 <span class=\"built_in\">fc</span>                mov    %eax,-0x4(%rbp)</span><br><span class=\"line\">    1105:       90                      nop</span><br><span class=\"line\">    1106:       5d                      pop    %rbp</span><br><span class=\"line\">    1107:       c3                      ret</span><br></pre></td></tr></table></figure>\n\n<p>此时变量寻址过程依赖了GOT表，位于.data段，表项大小为8字节，即一个地址的大小：</p>\n<p><img src=\"/images/%E9%93%BE%E6%8E%A5/image-20240610231929156.png\" alt=\"image-20240610231929156\"></p>\n<p>GOT表中的值由动态链接器写入。</p>\n<p>函数动态链接过程基于GOT和PLT</p>\n<p>PLT实现在.text段中，每个表项大小为16字节，由若干指令组成</p>\n<p>示例：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> *a = <span class=\"built_in\">malloc</span>(<span class=\"number\">64</span> * <span class=\"keyword\">sizeof</span>(<span class=\"type\">int</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>反汇编：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Disassembly of section .plt:</span><br><span class=\"line\"></span><br><span class=\"line\">0000000000401020 &lt;malloc@plt-0x10&gt;:</span><br><span class=\"line\">  401020:       ff 35 e2 2f 00 00       push   0x2fe2(%rip)        <span class=\"comment\"># 404008 &lt;_GLOBAL_OFFSET_TABLE_+0x8&gt;</span></span><br><span class=\"line\">  401026:       ff 25 e4 2f 00 00       jmp    *0x2fe4(%rip)        <span class=\"comment\"># 404010 &lt;_GLOBAL_OFFSET_TABLE_+0x10&gt;</span></span><br><span class=\"line\">  40102c:       0f 1f 40 00             nopl   0x0(%rax)</span><br><span class=\"line\"></span><br><span class=\"line\">0000000000401030 &lt;malloc@plt&gt;:</span><br><span class=\"line\">  401030:       ff 25 e2 2f 00 00       jmp    *0x2fe2(%rip)        <span class=\"comment\"># 404018 &lt;malloc@GLIBC_2.2.5&gt;</span></span><br><span class=\"line\">  401036:       68 00 00 00 00          push   <span class=\"variable\">$0x0</span></span><br><span class=\"line\">  40103b:       e9 e0 ff ff ff          jmp    401020 &lt;_init+0x20&gt;</span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">0000000000401122 &lt;main&gt;:</span><br><span class=\"line\">  401122:       55                      push   %rbp</span><br><span class=\"line\">  401123:       48 89 e5                mov    %rsp,%rbp</span><br><span class=\"line\">  401126:       48 83 ec 10             sub    <span class=\"variable\">$0x10</span>,%rsp</span><br><span class=\"line\">  40112a:       bf 00 01 00 00          mov    <span class=\"variable\">$0x100</span>,%edi</span><br><span class=\"line\">  40112f:       e8 <span class=\"built_in\">fc</span> fe ff ff          call   401030 &lt;malloc@plt&gt;</span><br><span class=\"line\">  401134:       48 89 45 f8             mov    %rax,-0x8(%rbp)</span><br><span class=\"line\">  401138:       90                      nop</span><br><span class=\"line\">  401139:       c9                      leave</span><br><span class=\"line\">  40113a:       c3                      ret</span><br><span class=\"line\">...  </span><br><span class=\"line\"></span><br><span class=\"line\">Disassembly of section .got.plt:</span><br><span class=\"line\"></span><br><span class=\"line\">0000000000404000 &lt;_GLOBAL_OFFSET_TABLE_&gt;:  <span class=\"comment\"># 这部分本身不是指令，objdump -D dump出来的将此处认为是指令，所以解析有误</span></span><br><span class=\"line\">  404000:       10 3e                   adc    %bh,(%rsi)</span><br><span class=\"line\">  404002:       40 00 00                rex add %al,(%rax)</span><br><span class=\"line\">        ...</span><br><span class=\"line\">  404015:       00 00                   add    %al,(%rax)</span><br><span class=\"line\">  404017:       00 36                   add    %dh,(%rsi)  <span class=\"comment\"># 404018: 36 10 40 00</span></span><br><span class=\"line\">  404019:       10 40 00                adc    %al,0x0(%rax)</span><br><span class=\"line\">  40401c:       00 00                   add    %al,(%rax)</span><br></pre></td></tr></table></figure>\n\n<p>函数的动态链接使用了延迟绑定技术：</p>\n<p>首次执行过程：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">40112f:       e8 <span class=\"built_in\">fc</span> fe ff ff          call   401030 &lt;malloc@plt&gt;</span><br><span class=\"line\">401030:       ff 25 e2 2f 00 00       jmp    *0x2fe2(%rip)        <span class=\"comment\"># 404018 &lt;malloc@GLIBC_2.2.5&gt;  跳转到GOT表中（0x401026+0x2fe2=0x404018）尝试取malloc的缓存地址。首次执行从磁盘读入为0x401036，也就跳回了&lt;malloc@plt&gt;中的下一条指令</span></span><br><span class=\"line\">401036:       68 00 00 00 00          push   <span class=\"variable\">$0x0</span></span><br><span class=\"line\">40103b:       e9 e0 ff ff ff          jmp    401020 &lt;_init+0x20&gt;  <span class=\"comment\"># 跳转到动态链接器代码段</span></span><br></pre></td></tr></table></figure>\n\n<p>动态链接器填充GOT表中的malloc地址后，再次执行时：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">40112f:       e8 <span class=\"built_in\">fc</span> fe ff ff          call   401030 &lt;malloc@plt&gt;</span><br><span class=\"line\">401030:       ff 25 e2 2f 00 00       jmp    *0x2fe2(%rip)        <span class=\"comment\"># 404018 &lt;malloc@GLIBC_2.2.5&gt;  跳转到GOT表中（0x401026+0x2fe2=0x404018）尝试取malloc的缓存地址。再次执行malloc缓存地址获取成功，直接跳转到malloc代码段执行，不再调用动态链接器代码</span></span><br></pre></td></tr></table></figure>\n\n<p>完整过程如下：</p>\n<p><img src=\"/images/%E9%93%BE%E6%8E%A5/image-20240611002011827.png\" alt=\"image-20240611002011827\"></p>\n<p>GOT为什么放在.data段？—— 可运行时修改</p>\n<p>什么是PIC（位置无关代码）？—— 此段代码利用了GOT和PLT的相对偏移在文件和在内存均一致的特性，不依赖运行时的地址（也就是给什么地址都能保持代码原有的逻辑）。</p>"},{"title":"leetcode刷题随记","date":"2024-02-05T15:00:00.000Z","toc":true,"_content":"\n本文旨在记录刷题过程中的思考，以及在给定刷题路径上做一些变式补充。\n\n刷题路径遵循：<https://github.com/youngyangyang04/leetcode-master?tab=readme-ov-file>\n\n<!-- more -->\n\n## 数组\n\n### 题704：二分查找\n\n二分查找重点关注边界取舍，这里讨论left、right为闭区间的情况：\n\n*   外层循环为left <= right，具有等号\n*   里层赋值left = mid + 1 或 right = mid - 1，偏移1个单位\n\n为什么？\n\n外层循环取等号由内层赋值控制推导，存在加1减1时left == right的可能，且所指向的值未曾遍历。\n\n里层赋值偏移1个单位原因是，前一次的\\[mid]值判断已经在条件中得到结论，故下一个\\[mid]无需再遍历。\n\n> \\[数值]符号含义：指取该数值所指向的值。\n\n**变式题34：找边界**\n\n找出指定数值的起始位置和终止位置。仍然是二分查找，唯一要处理的点是：\n\n在匹配到指定数值后，不要停：\n\n*   起始位置对应：右边界 - 1\n*   终止位置对应：左边界 + 1\n*   暂存当前的位置\n\n最终循环会因为left <= right不满足打破。\n\n**变式题162：找峰值**\n\n题目要求只要找到任意一个峰值即可，为此可以使用二分。\n\n假设-1，n均为负无穷，所以原始数组就变为\\[-infinity, 1, 2, 1, -infinity]\n\n基于此取查找就可找到答案。\n\n因为数组不支持-1和n索引，所以可以定义一个匿名函数支持它，这里也利用了cpp中的pair\\<int,int>特性。\n\n```cpp\nauto get = [&](int i) -> pair<int, int> {\n\tif (i == -1 || i == n) {  // 如果是-1或n，pair第一个值比较起作用，一定是最小的\n        return {0, 0};\n    }\n    return {1, nums[i]};  // pair的第二值起作用，依据具体nums[i]\n};\n\nget(idx) > get(idx + 1) && get(idx) > get(idx - 1)  // 这就是峰值\n```\n\n### 题27：O1空间内处理数组删除\n\n方式1：快慢指针，快指针负责搜索不相等元素，慢指针负责等候快指针给的值进行存储。\n\n方式2：c++可以使用iterator，在`*it`匹配到相等元素后，通过erase删除v.erase(it)，并保证it不向下走，因为这里erase的实现上会讲数组后续元素都向前shift 1个单位，所以此时的it仍然指向下一个新值。\n\n当然，方式2比方式1慢很多（1ms vs 5ms），时间复杂度后者为O(n2)。\n\n### 题977：On时间内平方数组\n\n双指针解法，利用原有数组的有序特性 + 平方后的排序是两端大中间小的特性，推导出两个指针从两头开始，往中间遍历。\n\n### 题209：最小连续子数组\n\n使用滑动窗口，本质是双指针，维护一个双指针区间内部的sum，一边加一边卸，返回区间长度。\n\n**变式题121：股票价值最大化**\n\n思路：题目要求只能1次买入卖出，所以可以设想：每一天，都想一个问题，我在历史最低点买入，今天卖出，会盈利多少（也就是保存最小价格，和当天价格相减，取max，得到结果）\n\n**变式题122：支持多次买入卖出**\n\n思路：动态规划，二维数组做状态记录\n\n> 其实只用2个数值做记录也够用，因为我们总是只回看前一个数。\n\n一列是未持股时手上的现金，一列是持股后手上的现金\n\n下一列的值等于：\n\n*   今日未持股现金 = 昨日未持股现金，昨日持股后今日卖掉的现金 取最大&#x20;\n*   今日持股现金 = 昨日持股现金，昨日未持股现金买今日股票后的现金 取最大\n\n最后取未持股时的现金返回。\n\n### 题59：螺旋矩阵\n\n螺旋矩阵没什么算法，纯粹是边界处理，顺着方向写就行。\n\nright -> down -> left -> up\n\n每转一圈，边长减1。\n\n## 链表\n\n### 题203：移除链表元素\n\n两个基本注意点：\n\n*   要创建一个dummy节点，作为起始遍历辅助\n*   结束时要返回dummy.next，而不是head，因为head有可能已被删除\n\n### 题707：设计链表\n\n核心方法：addAtIndex，deleteAtIndex，get\n\n关键点是要初始化一个dummy节点，从该节点开始处理链表的新增和删除。其本质和上述移除链表元素是一样的，必须得有个假的头节点来处理index为0的情况。\n\n### 题206：翻转链表\n\n观察翻转前后的变化，只有相邻节点的next箭头变了，因此只需要prev、current两个变量：\n\n*   先暂存next，翻转current->prev\n*   然后prev、current往下平移1个单位\n\n最后prev就是头了。\n\n当然这道题的另一种思路是拷贝到新链表，弊端是占用了额外内存空间。\n\n### 题24：两两节点交换\n\n![](https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg)\n\n最小可重复交换操作为：\n\n```bash\n# 三个数一组\n[dummy 1 2] 3 4\n[dummy 2 1] 3 4\n# 指针偏移2个单位\ndummy 2 [1 3 4]\ndummy 2 [1 4 3]\n# 再偏移2个单位\ndummy 2 1 4 [3 null null]  # 无需交换\n\n# 不满两组的情况\n[dummy 1 2] 3\n[dummy 2 1] 3\ndummy 2 [1 3 null]  # 无需交换\n```\n\n所以截止条件为：只要有null，就无需再操作。\n\n这种最小可重复操作怎么发现的？\n\n观察一次有多少元素需要参与运算，上述1 2参与了，2的下一个元素3属于下一次运算的范畴，可以不处理。下一次运算时，3 4交换，此时前面的1箭头也要变，所以参与运算的就有3个。为了抽象为通用操作，第一次运算1 2时，在其前补充dummy元素。\n\n### 题19：删除链表的倒数第N个节点\n\n要求一次遍历计算出来：\n\n*   链表长度怎么获取？\n\n    *   只能遍历完。\n*   遍历完后推算出倒数第n的位置，怎么返回获取前后节点？\n\n    *   遍历时有意识的保存\n\n如何实现有意识的保存？思路：构造2个有距离的指针，同时shift遍历，距离就是n。\n\n### 题02.07：链表相交\n\n思路1：普通解法\n\n*   分别遍历每条链表，计算长度，得到长度之差\n*   挑长链表磨平差值\n*   此时两条链表并排，开始遍历比较，第一个出现相等的元素就是了\n\n思路2：数学算法\n\n链表A不相交部分长度a，链表A相交部分长度c\n\n链表A不相交部分长度a，链表A相交部分长度c\n\n```bash\na + c = m\nb + c = n\na + c + b = b + c + a\n```\n\n可以得到，不相交部分长度走完，一定是交点。\n\n### 题142：环形链表\n\n思路1：将所有被遍历的节点压栈set集合，如果有重复节点，set长度将不会增长。\n\n*   缺点：需要额外内存空间存储节点地址\n\n思路2：设置快慢指针，快指针1次2步，慢指针1次1步，如果快指针追上慢指针，则满足条件。\n\n一定能相遇吗？\n\n*   一定能的，即便快指针在固定节点循环，慢指针属于遍历，一定能踩到。\n\n相遇的点一定是交点吗？\n\n*   不是，但可以通过以下公式推导：假设a是环外长度，b是环内长度，n表示在环内转了n圈，f是快指针走的里程，s是慢指针走的里程\n\n```bash\n# 已知快指针比慢指针多走一倍里程\nf = 2s\n# 已知快慢相遇时，在相遇节点开始走n圈 + s就是快指针的里程\nf = s + nb\n# 推导得到\ns = nb\n# 已知从head走到入口节点需要：\na + nb\n# 慢指针已经走了nb步，还需再走a步，a步怎么来？和head开始的指针一起走，直至相遇，得到结论。\n```\n\n## hash表\n\n### 题242：有效的字母异位词\n\n思路1：最直接的方法是定义一个hashmap，第一轮迭代填充charMap，第二轮迭代减少charMap计数，如果出现-1的则return false。\n\n思路2：定义1个具有26长度的数组，每个位置依据字符串的字符位置进行++--，最后check一遍得到结果。\n\n### 题1002：查找共用字符\n\n这里有个坑是，不是说一个字母统计一次就行，而是如相同字母在多个words里分别重复出现了，那就都得输出出来。\n\n思路：一个当前word的freq数组，一个全局words的最小freq数组，分别统计每个词的字母出现频率。\n\n全局word在的foreach每个词时，总是取当前word每个槽位的最小值。\n\n### 题349：两个数组的交集\n\n这道题跟上面一道题有点类似，这道题要求一个字母只统计1次，并且只有两个数组之间的比较，所以可以认为是上一道题的简单版本。\n\n思路：set存储第一个数组内容，set.count(第二个数组中的每一个元素)，如果存在，则return\n\n### 题202：快乐数\n\n首先理解题意：\n\n*   拆解的数的每一位做平方\n*   希望得到1\n*   可能永远都得不到\n*   得不到的原因是无限循环（在某个圈内循环转）\n\n解题关键：找到循环的入口\n\n具体思路：记录历史算数，如果重复或为1，则退出\n\n### 题1：两数之和\n\n思路：排序，二分，要寻找的对象是：find(和 - 当前数值)。\n\n寻找对象的方法还可以是hashset，即hashset + find，这里要注意，find到值不能是自己，并且还要有数组下标返回，所以通过hashmap更合适。\n\n### 题454：四数相加\n\n四个数组，长度一致；每个数组挑1个数，和其他数相加；求和要等于0；返回有多少种可能。\n\n要把所有组合都遍历一遍，n的4次方。减少复杂度方法是，分为2组，每组n的2次方，从等于0改为ab组 = -cd组。ab组的求和存入hash表，值为等于该和的组数；cd组查询，这样就得到最终结果。\n\n### 题383：赎金信\n\n数组2中的字符作为候选，数组1消费。\n\n给1个hashmap对候选计数，数组1遍历时消费，如果找不到或value出现小于0的情况，则为false。\n\n### 题15：三数之和\n\n思路1：选target，剩下的元素求“两数之和”，因为本题要求返回所有元组，而两数之和给了1个只有1个元组答案的约束，所以，本题最后还得有一层去重处理。\n\n思路2：组合问题，从数组中选3，求和。\n\n组合问题是无序的，相比有序的数组还是差了点效率。所以\n\n思路3：这里可以基于排序后的数组，使用双指针解决\n\n*   遍历数组，从first = 0，选target\n*   定义left = first + 1、right == n - 1，双指针两方向往中间靠近，找所有解\n\nsecond和third就是双指针。\n\n### 题18：四数之和\n\n本质是在三数之和上套一层循环，怎么理解？\n\n*   遍历数组，从first = 0，选target\n*   遍历数组，从second = first + 1\n*   定义left = second + 1、right = n - 1，双指针两方向往中间靠近，找所有解\n\n相关剪枝细节（其实就是哪些可以跳过不做的）这里不展开。\n\n## 字符串\n\n### 题344：反转字符串\n\n这道题要求原地反转。\n\n思路：双指针从两端到中间依次反转字符对，截止条件：指针相遇或错过。\n\n**变式题541：反转字符串2**\n\n相比上一道字符串增加了步长，其余逻辑一致。\n\n### 题kama54：替换数字\n\n这道题也是要做到原地变更字符串。利用C++里的s.resize方法。\n\n核心思路是：预留卡位，从后往前填。\n\n### 题151：反转字符串中的单词\n\n这题考察对string api的熟悉程度。\n\n更高要求：原地修改字符串，大致步骤：\n\n*   字符串reverse\n*   删除多余空格\n*   单词reverse\n\n### 题kama55：右旋字符串\n\n思路上跟上道题类似，右旋只是表象，本质还是2个操作：\n\n*   字符串reverse\n*   区间字符串reverse（等同于单词reverse）\n\n### 题459：重复的子字符串\n\n特殊例子：ababdababd、acdfdacdfd，这也是重复的\n\n思路1：比较朴素的解法\n\n*   遍历各种长度（满足size % 长度 == 0）的子串\n*   始终满足是前一个子串的前缀：s\\[j] == s\\[j - 1]，j++，j < size\n\n思路2：特殊性质\n\n*   如果是重复子串，则abab + abab，去掉头尾， = bababa 包含ab\n*   如果不是，则absab + absab = bsababsa 不包含 absab\n\n## 双指针\n\n### 题27：移除元素\n\n原地操作移除元素，可使用快慢指针，慢指针指向当前要赋值的位置，快指针指向非目标元素的位置，如此迭代。\n\n## 栈与队列\n\n### 题232：用栈实现队列\n\n队列FIFO，栈LIFO，用栈实现队列核心要解决如何将栈头元素弹出问题。\n\n让第一次进栈的元素保持在栈尾？双栈思路。\n\n在pop/top时操作，将当前所有元素都转移到新栈上。\n\n注意这里有个tracky，新栈总是在为空时才从旧栈中补充元素。\n\n### 题225：用队列实现栈\n\npush时操作，将新push进队列的元素置于front位置，可通过循环将其他元素pop再push的方式。\n\n### 题20：有效的括号\n\n校验括号的方法：左括号进栈，右括号遇到匹配的左括号，则左括号弹栈，否则右括号进栈。\n\n### 题1047：删除字符串中的所以相邻重复项\n\n和上述题一样，相同的消掉，不同的入栈，最后反转下栈内元素输出即可。\n\n### 题150：逆波兰表达式求值\n\n思路：如果时数字，压栈，如果是符号，弹出两个数字，计算，再压栈。\n\n### 题239：滑动窗口最大值\n\n看着简单，操作起来有点难度。\n\n思路：优先队列，它能解决区间最大值的问题。但还要考虑：\n\n*   如何删除区间的第一个值问题\n\n这里就有一个位置信息需要在优先队列里保留，方法：\n\n*   设置队列节点为\\<nums\\[i], \\[i]>的pair对\n\n那么必须要始终确保优先队列的长度为窗口大小吗？不用。其实只要确保当前队列里的top仍然在窗口内，那么top就不需要摘除，保留即可，其他比top小的窗口外元素不影响。\n\n### 题347：前k个高频元素\n\n前k个 --> 优先队列，返回高频元素，所以队列元素设计为<频率,元素>pair，为了得到这种pair，还需要使用map收集。\n\n这块还需要重写优先队列的排序方式，只用频率排序。\n\n## 二叉树\n\n### 题144/145/94：二叉树遍历\n\n前序：中左右\n\n中序：左中右\n\n后序：左右中\n\n可以看出，前后是基于树的高来讲，root在树顶点，那么它就是前，树的叶子节点就是后。\n\n### 题102：层序遍历\n\n从上到下输出，前序\n\n遍历是深度的，所以还需要辅助信息，也就是层高\n\n层高对应到数组索引\n\n所以思路1：深度优先搜索\n\n```cpp\nclass Solution {\npublic:\n    vector<vector<int>> levelOrder(TreeNode* root) {\n        vector<vector<int>> res;\n        traversal(root, 0, res);\n        return res;\n    }\n\n    void traversal(TreeNode* node, int level, vector<vector<int>>& res) {\n        if (node == nullptr) {\n            return;\n        }\n        while (res.size() <= level) {\n            vector<int> ele;\n            res.push_back(ele);\n        }\n        res[level].push_back(node->val);  // 深度遍历到对应层级时加入对应的数组内\n        traversal(node->left, level + 1, res);\n        traversal(node->right, level + 1, res);\n    }\n};\n```\n\n思路2：广度优先搜索的层序版\n\n通过辅助的队列来实现。队列的职责是保存每一层的节点：\n\n*   检查队列是否为空\n*   **全部遍历**，依次弹出，取这些节点的左右节点重新入队列\n*   如此循环\n\n```cpp\nclass Solution {\npublic:\n    vector<vector<int>> levelOrder(TreeNode* root) {\n        vector<vector<int>> res;\n        if (root == nullptr) {\n            return res;\n        }\n        queue<TreeNode*> q;\n        q.push(root);\n        while (!q.empty()) {\n            int levelsize = q.size();\n            res.push_back(vector<int>());\n            for (int i = 0; i < levelsize; i++) {  // 广度优先搜索不需要这一层\n                TreeNode* cur = q.front();\n                q.pop();\n                res.back().push_back(cur->val);\n                if (cur->left != nullptr) {\n                    q.push(cur->left);\n                }\n                if (cur->right != nullptr) {\n                    q.push(cur->right);\n                }\n            }\n        }\n        return res;\n    }\n};\n```\n\n> 这里要注意一个细节，即层序遍历不是广度优先搜索。广度优先是1个节点1个节点逐个往下走，它没有层的信息，而层序遍历是将层的信息显性化出来。\n\n**变式题107：要求返回从底向上的层序遍历**\n\n思路：基于常规层序遍历将res翻转下。\n\n有其他思路吗？没有，官方题解本质仍然是翻转，只是在while循环中翻转和循环完翻转的问题。\n\n**变式题199：二叉树的右视图**\n\n思路1：层序，保留每一层的最优节点值。\n\n思路2：层序或dfs，在最后res中取back值。\n\n**变式题637：二叉树的层平均值**\n\n同样的做法，层序遍历时求平均。\n\n**变式题429：N叉树的层序遍历**\n\n只需要改造left、right为for children即可。\n\n**变式题515：二叉树的层最大值**\n\n同样的做法，层序遍历求最大。\n\n**变式题116：填充每个节点的下一个右侧节点**\n\n层序，在遍历时做好前后节点的next关联。\n\n**变式题104：二叉树的最大深度**\n\n思路1：层序，为层计数。\n\n思路2：深度DFS，可以不用辅助函数。\n\n**变式题559：N叉树的最大深度**\n\n思路类似，深度遍历，每下钻一层加1。\n\n**变式题111：二叉树的最小深度**\n\n思路：层序，当left、right都为空时直接返回。\n\n### 题226：翻转二叉树\n\n思路：深度遍历，无需辅助函数，直接翻转（这里可以选择前序，也可以选择后序）。\n\n### 题101：对称二叉树\n\n思路：层序遍历，弹出单层数组，判断是否对称。这里有个处理技巧，就是单层元素不按从左到右加入队列，而是两端对称加入；每次循环弹出2个节点进行比较。\n\n### 题222：完全二叉树的节点个数\n\n参考二叉树的最大深度解法，通过DFS来解。\n\n因为二叉树的性质，这里还有一种二分查找的解法，先算出有多少层，然后再二分叶子节点。\n\n### 题110：平衡二叉树\n\n平衡的性质是左右子树的高相差小于等于1\n\n*   首先要能算出高\n*   其次是判断是否满足小于等于1的条件\n\n### 题257：二叉树的所有路径\n\n深度优先搜索，本质也是使用回溯的方法，设计好输入、截止条件即可。\n\n### 题513：找树左下角的值\n\n左下角，高度最大，最左\n\n深度遍历需要带上这两个状态，同时要带上answer（当前高度，当前值）\n\n如果新遍历的比当前高度高，则刷新answer。\n\n处理细节：是否为左节点的状态可以去掉，转为由height > answer.curHeight代替，原因：height递增时的首次遍历的节点一定是左节点（通过由先遍历左子树再遍历右子树的方式控制）。\n\n### 题112：路径之和\n\n求路径和，判断是否等于目标值。\n\n路径和 = DFS + sum累加，遇到叶子节点后截止。\n\n### 题106：已知中后序，构造二叉树\n\n特征：后序的最后1个元素总是根节点。\n\n步骤：\n\n*   后序数组倒序遍历，选取的元素拿到中序遍历中做边界，分出左右子树数组\n*   递归构造左子树数组\n*   递归构造右子树数组\n*   左右子树拼接到当前的根节点\n\n因为涉及元素到index的查询，所以，构造1个（元素，index）的map加快索引。\n\n### 题654：最大二叉树\n\n这道题跟题106类似，递归，选出根节点，构造左右子树，拼接到根节点即可。\n\n### 题617：合并二叉树\n\n合并二叉树的逻辑也是构造左右子树，拼接到根节点。\n\n### 题700：二叉搜索树\n\n深度遍历即可，小于往左，大于往右。\n\n### 题98：验证二叉搜索树\n\n需满足两条规则：\n\n*   当前节点比左节点大，比右节点小；\n*   当前节点要小于或大于整体子树的区间范围，比如\\[5,4,7,null,null,3,9]，3比4小，false\n\n> 搜索树有个特征：不存在两个节点的值重复。\n\n### 题530：二叉搜索树的最小差值\n\n注意题目要求是任意两节点，非相邻节点。但实际根据树的性质，最小值只会存在于**中序遍历**下相邻的两个节点（因为中序遍历将得到1个递增序列）。\n\n中序遍历需具有以下状态：前一个节点的值，当前的最小值。\n\n### 题501：二叉搜索树的众数\n\n这道题的二叉树定义为节点值可重复。\n\n仍然按中序遍历，因为是递增序列，所以在遍历时保存前一个节点值preval，该值的count，当前的最大count，以及当前的最大countVals（因为要返回具体的val值）\n\n官方解答对首次处理中序有一个比较晦涩的点：\n\n```cpp\nint preval, int curCount, int maxCount\n\ndfs // 前序\n// 中序，注意看这里省略了对preval未初始化情况的处理\nif (node->val == preval) {\n  curCount++; \n} else {\n  curCount = 1;\n  preval = node->val;\n}\n```\n\n更直观的写法：\n\n```cpp\nint preNode, int curCount, int maxCount\ndfs // 前序\n// 中序\nif (preNode == nullptr) {\n  curCount = 1;\n} else if (preNode->val == node->val) {\n  curCount++;\n} else {\n  curCount = 1;\n}\npreNode = node;\n```\n\n可以看到，直观的写法中，if elseif块内的处理是一致的，故官方解法直接将二者合并为1个，无论preval是什么。\n\n### 题236：二叉树的最近公共祖先\n\n最近公共祖先的特征：\n\n*   该祖先的下一个node->left和node->right必有一方不是祖先\n\n所以在搜索时，可以先探查左右子树，如果同时为空，则说明该节点不包含目标；如果同时不为空，则说明该节点就是二者的公共祖先；如果一方为空、一方不为空，为空的子树没有包含目标，往不为空的搜索。\n\n```cpp\nclass Solution {\npublic:\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\n        if (root == nullptr || root == p || root == q) return root;\n\n        TreeNode* left = lowestCommonAncestor(root->left, p, q);\n        TreeNode* right = lowestCommonAncestor(root->right, p, q);\n\n        if (left == nullptr && right == nullptr) return nullptr;\n        if (left != nullptr && right != nullptr) return root;\n        if (left == nullptr) return right;\n        if (right == nullptr) return left;\n        return root;\n    }\n};\n```\n\n### 题701：二叉树的插入操作\n\n思路：找到节点要插入的位置，挂上去，这种适合前序遍历。\n\n首先判断节点是否为null，是则构造一个当前val的节点返回；否则对left、right进行遍历，并对返回值重新挂载到root。\n\n### 题450：二叉树的删除操作\n\n类似插入操作，同样是找到节点，然后执行删除：\n\n*   如果左右子树均为空，返回空\n*   如果左子树为空，返回右子树\n*   如果右子树为空，返回左子树\n*   如果都不为空，则找到右子树的最左节点，把当前左子树挂到这个节点上，然后返回右子树\n\n### 题669：修剪二叉搜索树\n\n区间描述要保留的节点，中序遍历，一路trim节点，trim规则：\n\n*   小于左边界的，trim左子树\n*   大于右边界的，trim右子树\n*   满足区间内的，左子树的trim结果挂到左节点，右子树的trim结果挂到右节点（整体结构上只会有边界节点会变化）\n\n```cpp\nclass Solution {\npublic:\n    TreeNode* trimBST(TreeNode* root, int low, int high) {\n        if (root == nullptr) {\n            return root;\n        }\n        if (root->val < low) {\n            return trimBST(root->right, low, high);\n        }\n        if (root->val > high) {\n            return trimBST(root->left, low, high);\n        }\n        root->left = trimBST(root->left, low, high);\n        root->right = trimBST(root->right, low, high);\n        return root;\n    }\n};\n```\n\n### 题108：有序数组转平衡二叉树\n\n二分查找，每个被发现的中间元素作为root节点，而二分本身能够确保树平衡。\n\n### 题538：二叉树转换为累加树\n\n二叉树转为递减数组，每次遍历累加前一个节点的值\n\n如果实现递减遍历？通过颠倒的中序遍历来做。\n\n遍历过程需要维护一个[currentSum]()值。\n\n## 回溯\n\n### 题77：组合\n\n这道题有两种写法，第一种是带有for循环的：\n\n```cpp\nclass Solution {\npublic:\n    vector<vector<int>> combine(int n, int k) {\n        vector<int> curVec;\n        vector<vector<int>> res;\n        backtracking(n, k, 1, curVec, res);\n        return res;\n    }\n\n    void backtracking(int n, int k, int start, vector<int>& curVec, vector<vector<int>>& res) {\n        if (curVec.size() == k) {\n            res.emplace_back(curVec);\n            return;\n        }\n        for (int i = start; i <= n; i++) {\n            curVec.push_back(i);\n            backtracking(n, k, i + 1, curVec, res);\n            curVec.pop_back();\n        }\n    }\n};\n```\n\n第二种是不带for循环的：\n\n```cpp\nclass Solution {\npublic:\n    vector<vector<int>> combine(int n, int k) {\n        vector<int> curVec;\n        vector<vector<int>> res;\n        backtracking(n, k, 1, curVec, res);\n        return res;\n    }\n\n    void backtracking(int n, int k, int cur, vector<int>& curVec, vector<vector<int>>& res) {\n        if (curVec.size() + n - cur + 1 < k) {  // 这里做了剪枝处理，表示如果当前数组长度+剩余待遍历区间长度小于k时，跳过不遍历，因为没必要\n            return;\n        }\n        if (curVec.size() == k) {\n            res.emplace_back(curVec);\n            return;\n        }\n        if (cur == n + 1) {\n            return;\n        }\n        curVec.push_back(cur);\n        backtracking(n, k, cur + 1, curVec, res);\n        curVec.pop_back();\n        backtracking(n, k, cur + 1, curVec, res);\n    }\n};\n```\n\n以上存在一个细节，在回收结果处，使用了emplace\\_back来copy数组\n\n其他方案有：\n\n*   入参不带&，而使用copy：backtracking(int n, int k, int cur, vector\\<int> curVec, vector\\<vector\\<int>>& res)\n*   入参带&，在回收结果时，自行构造一个新vector拷贝curVec\n\n实验证明，上述两种都不高效，且第一种方案内存使用异常高，是最优方案的10倍。\n\n**变式题216：组合总和3**\n\n这道题同样求组合，加了1个约束，要求组合的总和要等于指定值。\n\n思路：遍历所有组合，维护当前总和值，如果等于指定值且组合的size等于指定size，则返回，否则回溯。\n\n剪枝细节：同上道题，vec长度+区间长度 < 指定长度或者 vec长度大于指定长度的，无需遍历，直接返回。\n\n**变式题39：组合总和**\n\n这道题的约束为，不限制给定数组中的某个数被选择几次，找出所有能够求和等于target值的组合。\n\n类似题目：爬楼梯，可选的一步台阶范围类比这里给定的数组。\n\n解法（更适合不具有for循环的递归）\n\n```cpp\n    void backtracking(vector<int>& candidates, int index, int target, vector<int>& curVec, vector<vector<int>>& res) {\n        if (index == candidates.size()) {\n            return;\n        }\n        if (target == 0) {\n            res.emplace_back(curVec);\n            return;\n        }\n\n        // 跳过不使用candidates[index]\n        backtracking(candidates, index + 1, target, curVec, res);\n\n        // 使用candicates[index]\n        if (target - candidates[index] >= 0) {\n            curVec.emplace_back(candidates[index]);\n            backtracking(candidates, index, target - candidates[index], curVec, res);\n            curVec.pop_back();\n        }\n    }\n```\n\n**变式题40：组合总和2**\n\n这道题放宽了对给定数组的约束，允许数组内有元素重复，并且，结果要求不可重复，且每个元素只能被用一次。\n\n对于只能被用一次这条，正常组合解法已覆盖。\n\n对于结果要求不可重复这条，需要做两个步骤：\n\n*   对给定数组排序\n*   带for循环递归时，检查前后两个元素是否相同，是则跳过\n\n剪枝细节：如果target - 当前元素小于0，可以直接break，无需继续遍历。\n\n### 题17：电话号码的字母组合\n\n这道题求的是多组字母内分别取1的组合，之前的题型则为1组数内取k的组合。\n\n多组取1，对上述1组取多进行变式：\n\n```cpp\n    void backtracking(vector<string>& digitLetters /* 多组取1 */, int index /* 指向哪一组 */, string& curStr, vector<string>& res) {\n        if (curStr.size() == digitLetters.size()) {\n            res.emplace_back(curStr);\n            return;\n        }\n        for (int i = 0; i < digitLetters[index].size(); i++) {  // 遍历每一组内的所有字母\n            curStr.push_back(digitLetters[index][i]);\n            backtracking(digitLetters, index + 1, curStr, res);\n            curStr.pop_back();\n        }\n    }\n```\n\n### 题131：回文字符串\n\n遍历字符串，选择步长，可以是1，2，3等，检查该子串是否符合，如果符合，加入结果；如果不符合，继续往大步长遍历。\n\n每次处理完当前子串后，对剩余的子串做相同动作（回溯）\n\n将这个过程具象化为一张横纵回溯图，如下所示：\n\n![image](https://camo.githubusercontent.com/0e9d7097c5f8a06d6ee1a6fd0ab110e981442669d0dbcdeb6d5e25ef615d5f1a/68747470733a2f2f636f64652d7468696e6b696e672e63646e2e626365626f732e636f6d2f706963732f3133312e2545352538382538362545352538392542322545352539422539452545362539362538372545342542382542322e6a7067)\n\n横向对当前子串的区间放大，并分别判断\n\n纵向对剩余子串做同等处理\n\n### 题93：复原IP地址\n\n和回文串类似，对当前子串长度进行遍历，对剩余子串进行回溯。\n\n这里唯一要注意下对子串的合法性进行校验。\n\n### 题78：子集\n\n和爬楼梯类似，无需for循环，分考虑当前位置、不考虑当前位置两种场景进行回溯。\n\n```cpp\nclass Solution {\npublic:\n    vector<vector<int>> subsets(vector<int>& nums) {\n        vector<int> subset;\n        vector<vector<int>> res;\n        backtracking(nums, 0, subset, res);\n        return res;\n    }\n\n    void backtracking(vector<int>& nums, int start, vector<int>& subset, vector<vector<int>>& subsets) {\n        if (start >= nums.size()) {\n            subsets.emplace_back(subset);\n            return;\n        }\n        subset.push_back(nums[start]);\n        backtracking(nums, start + 1, subset, subsets);\n        subset.pop_back();\n        backtracking(nums, start + 1, subset, subsets);\n    }\n};\n```\n\n思考：什么时候回溯需要for循环，什么时候不用？\n\n其实这道题也可以套for循环：\n\n```cpp\nclass Solution {\npublic:\n    vector<vector<int>> subsets(vector<int>& nums) {\n        vector<int> subset;\n        vector<vector<int>> res;\n        backtracking(nums, 0, subset, res);\n        return res;\n    }\n\n    void backtracking(vector<int>& nums, int startIndex, vector<int>& subset, vector<vector<int>>& subsets) {\n        subsets.push_back(subset); // 收集子集，要放在终止添加的上面，否则会漏掉自己\n        if (startIndex >= nums.size()) { // 终止条件可以不加\n            return;\n        }\n        for (int i = startIndex; i < nums.size(); i++) {\n            subset.push_back(nums[i]);\n            backtracking(nums, i + 1, subset, subsets);\n            subset.pop_back();\n        }\n    }\n};\n```\n\n相比第一种没有for循环写法，具有for循环的写法明显不那么直观。\n\n**变式题90：子集2**\n\n相比上道题，这道题给定的数组元素重复，求不重复的子集。\n\n解法和**组合求和2**一致，先排序，再回溯，检测前后重复的跳过。\n\n### 题491：非递减子序列\n\n给定数组，带重复元素，找所有非递减子序列。\n\n这道题特殊之处在于需要给子序列回溯加限定条件：\n\n*   当前元素比序列中最后1个元素大的，不考虑\n*   当前元素已经在之前用过的，不考虑（使用set数据结构，保存本层当前元素）\n\n比如\\[4,7,6,7]：4回溯，7回溯，6跳过，7跳过\n\n### 题46：全排列\n\npush1 push2 push3 ==> 1,2,3\n\npush1 push2 pop2 push3 ==> 1,3,2\n\npop掉的元素需要有地方暂存，直接存回数组？—— 可以用1个bool数组标记是否被使用过。\n\n因为全排列不分前后顺序，所以在每层回溯时都要遍历全部nums数组元素。\n\n**变式题47：全排列2**\n\n给定的nums数组现在具有重复元素了，求全排列。\n\n重复元素的做法：排序，for循环遇到重复元素，跳过\n\n这里仅上述判断还不够，因为类似\\[1,2,2]的答案，2和2重复，但不能跳。\n\n所以还得再加1个原则：nums\\[i - 1]被用过，即used\\[i - 1] == false。\n\n## 贪心\n\n### 题455：分发饼干\n\n约束：每个人最多获得1块饼干。\n\n贪心策略：人按胃口排序，饼干按大小排序，遍历每个人，找能满足当前这个人胃口的最小饼干。\n\n### 题376：摆动序列\n\n删除若干元素后形成摆动序列，求序列最长的长度：可以转化为统计峰谷的数量。\n\n> 这里有个思维误区是：求要删除多少个元素，然后用序列总长 - 要删除的元素，该思路本身没问题，但对前后相等的过渡元素场景不好处理。\n\n### 题53：最大子数组和\n\n贪心策略：如果当前数组的sum为负数，则直接丢弃当前数组的sum（使sum置为0），从下一个新的元素开始计数。\n\n### 题122：买卖股票的最佳时机2\n\n贪心策略：求多个不相交的区间，区间的利润不存在负收益，然后对这些区间求和，得到最大利润。\n\n因为多个不相交无负收益区间之和等价于多个间隔为1的无负收益区间之和，所以问题可以简化相邻元素相减。\n\n### 题55：跳跃游戏\n\n贪心策略：每一个元素都遍历一遍，检查该元素能够跳到的位置，不断统计取最远，如果遍历时发现的当前i指针超过了最远的位置，那就说明后面的元素不可达，return false。\n\n### 题45：跳跃游戏2\n\n这道题保证了一定能跳到终点，求最小步数。\n\n仍然是每个元素都遍历一遍，检查该元素能够跳到的位置，不断统计取最远。不同的是，在这里面，需要维护一个每次跳的区间。\n\n比如首次区间就是：start = 0, end = 1\n\n后面的区间则为：start = end, end = rightmost + 1\n\n### 题1005：K次取反后的数组最大和\n\n贪心策略：\n\n*   值越小取反收益越大，比如：1 2选1，-2 -1选-2\n*   都是非负数时，对当前最小值进行反复取反\n\n简单点可以考虑用最小堆。\n\n### 题134：加油站\n\n能否到终点：对所有剩余油量求和，如果小于0，则无法到终点。\n\n选起点：该起点应能到达下一站；该起点应剩余油量要足够大（反例：\\[1,1,3], \\[1,2,1]，0号加油站不能作为起点，2号可以 ==>\\[0,-1,2]）\n\n如果有1段特别大cost的呢？比如剩余油量：\\[1,2,-3]，选1号加油站过不去，只能选0号加油站。\n\n所以问题变为，剩余油量序列，累积子序列不能为负。\n\n如果出现负数，怎么办？\n\n思路1：从后往前寻找能填平该负数的index，如果有，那么该index就是起点。\n\n```cpp\nclass Solution {\npublic:\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\n        int endIndex = 0;\n        int sumRest = 0;\n        int minGasRest = INT_MAX;\n        for (int i = 0; i < gas.size(); i++) {\n            int rest = gas[i] - cost[i];\n            sumRest += rest;\n            if (sumRest < minGasRest) {\n                minGasRest = sumRest;\n                endIndex = i;\n            }\n        }\n        if (sumRest < 0) {  // 不能到达终点\n            return -1;\n        }\n        if (minGasRest >= 0) {  // 0作为起点就能到达终点\n            return 0;\n        }\n\n        // 0作为起点不能达到终点，缺油，从后面补\n        for (int i = gas.size() - 1; i >= endIndex + 1; i--) {  // 注意有些答案将endIndex + 1处理为0，原因是即便从后往前重复计算前半段，前半段已经明确缺油，前半段计算进去也找不到补\n            int rest = gas[i] - cost[i];\n            minGasRest += rest;\n            if (minGasRest >= 0) {\n                return i;\n            }\n        }\n        return -1;\n    }\n};\n```\n\n思路2：借鉴最大子序列和的思路，出现负数时，就需要舍弃这部分，从下一个元素作为新起点。\n\n```cpp\nclass Solution {\npublic:\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\n        int curSum = 0;\n        int totalSum = 0;\n        int start = 0;\n        for (int i = 0; i < gas.size(); i++) {\n            int rest = gas[i] - cost[i];\n            curSum += rest;\n            totalSum += rest;\n            if (curSum < 0) {\n                start = i + 1;\n                curSum = 0;\n            }\n        }\n        if (totalSum < 0) return -1;  // 无解\n        return start;  // 如果有解，一定从子序列之和为非负数开始\n    }\n};\n```\n\n### 题135：分发糖果\n\nrating为1,2,3的，糖果为1,(1+1),(2+1)，后一个数=前一个数+1\n\nrating为3,2,1的，糖果为(2+1),(1+1),1，前一个数=后一个数+1\n\n推测：正方向遍历\n\n如果遇到正向递减的，如1,2,3,2,1，是否要跟着减一？不需要，如果减一会丢失的重复元素的位置信息。故正向递减按规则得到1,2,3,1,1\n\n按倒序规则得到1,1,3,2,1\n\n两个数组结合取最大值，得到1,2,3,2,1，就是我们最后想要的。\n\n重复元素怎么办？也适用\n\n1,2,3,3,3,2,1\n\n*   正向：1,2,3,1,1,1,1\n*   反向：1,1,1,1,3,2,1\n*   最大：1,2,3,1,3,2,1 ==> 是最终结果\n\n### 题860：柠檬水找零\n\n贪心思路：拿当前能够满足找零的最大面额去填。\n\n### 题406：根据身高重建队列\n\n这道题有点脑筋急转弯。关键还是要发现队列的规律：\n\n*   先按身高排（从高到低），如果身高相等的，按前方高于自身的数量排（从小到大），此时的序列接近直觉\n*   按上述顺序依次插入到新队列，身高高的总是先插入，身高矮的后插入，插入位置基于当前元素的前面高于自身的数量定，无论插入到哪都不会对当前新队列中已有的元素值造成影响，所以得到的新队列结果就是我们想要的。\n\n### 题452：用最小数量的箭引爆气球\n\n气球区间重叠的可用1支箭射爆，那么问题就变为寻找子集的数量。\n\n我们对所有气球区间按左边界排序，然后维护1个子集和所有气球区间比对，有更小的子集就更新，最后返回子集数量即可。\n\n### 题435：无重叠区间\n\n两个步骤：\n\n*   排序，按右边界大小排（优先参加结束时间早的），如果相等的，选区间长度短的\n*   遍历，发现有交集就去掉当前区间，计数加1\n\n另一个思路：\n\n*   排序，按左边界大小排，如果相等的，选区间长度短的\n*   遍历，发现有交集就去掉大的区间，留小区间，计数加1\n\n### 题763：划分字母空间\n\n这道题本质是求重叠子区间的题，但因为字母多，形成的子区间多，求子区间交集较为复杂，为此有一个巧妙的思路：通过遍历字符串，比较当前索引是否等于当前字母的右区间，是则为分割点。\n\n### 题56：合并区间\n\n也是求重叠子区间问题，常规思路，排序，依次遍历，发现有重合的就合并，否则加入结果集返回。\n\n### 题738：单调递增的数字\n\n找规律：从后往前，依次比较，如果出现不符合预期单调的，基于该规则改：比如32改为29，如此反复：4332，4329，4299，3299，2999。\n\n### 题968：监控二叉树\n\n贪心思路：让摄像头数量最少 等价于 让叶子节点尽量不要有摄像头，因为叶子节点放摄像头是非叶子节点的指数倍。\n\n为实现这种思路，需要对节点的状态分级：\n\n*   0：节点无覆盖\n*   1：节点有摄像头\n*   2：节点有覆盖\n\n通过后序遍历，基于每个节点的情况递推该状态值，并按情况放摄像头和计数。\n\n## 动态规划\n\n### 题509：斐波那契数\n\nf(2) = f(1) + f(0); f(3) = f(2) + f(1)；f(0)和f(1)已知，所以直接基于此for循环滚动相加到指定n值即可。\n\n动态规划在这里面用到的位置为：每次for循环记录n-1 n-2处的值。\n\n### 题70：爬楼梯\n\nn阶楼梯到顶，就有n-1阶楼梯的dp\\[n-1]种方法 + n-2阶楼梯的dp\\[n - 2]种方法。\n\n本质是斐波那契数。\n\n所以解法和斐波那契数一致。\n\n### 题746：使用最小花费爬楼梯\n\n动态规划数组定义：dp\\[i] = min(dp\\[i-1] + cost\\[i-1], dp\\[i-2] + cost\\[i-2])\n\n解释：dp\\[i]指当前第i阶所花费的最小费用。\n\n### 题62：不同路径\n\n机器人到达mxn矩阵右下角有多少不同路径，定义dp\\[i]\\[j]，表示到达i,j点有多少不同路径，其等于(i-1,j),(i,j-1)点的路径数之和。\n\n**变式题63：不同路径2**\n\n这道题在mxn矩阵中加了障碍物，整体思路是不变的，核心点在于遇到障碍物后，障碍物位置的dp\\[i]\\[j]要清零。\n\n### 题343：整数拆分\n\n一个整数i，可以拆分为：\n\n*   两个整数，j \\* (i - j)\n*   一个整数和再拆分的整数相乘：j \\* 再拆分(i - j)\n\n定义dp\\[i]为整数i的最大乘积\n\n那么上述再拆分的乘积即为：j \\* dp\\[i - j]\n\n那么整数i的最大乘积即可从上述两种情况中获取：\n\n```bash\nmax(j * (i - j), j * dp[i - j])\n```\n\nj的取值可以从1到i-1遍历，计算每种拆分j的值，取最大，就得到当前dp\\[i]最大：\n\n```bash\ncurMax = 0;\nfor j = 1..i-1\n\tcurMax = max(curMax, max(j * (i - j), j * dp[i - j]))\ndp[i] = curMax\n```\n\n### 题96：不同的二叉搜索树\n\n动态规划思路：\n\n遍历1..n，计算每个数i作为根节点时的二叉树个数，然后求和。\n\n定义dp\\[i]，表示以i为根节点时的二叉树个数\n\n针对每个根节点的取值j，都有dp\\[j] = dp\\[j-1] \\* dp\\[i-j]，得解。\n\n### 题kama46：01背包\n\n定义物品的weight和价值value，求一个给定bagweight容量的背包，可以放入的最大价值。\n\n这种就是01背包问题，对于每个物品，要么选1个，要么不选\n\n如果是每个物品可以选多次，那就是完全背包问题。\n\n背包问题的dp数组定义：dp\\[j]表示达到重量为j的背包最大可放入的价值。\n\n递推公式：dp\\[j] = max(dp\\[j], dp\\[j - weight\\[i]] + value\\[i])\n\n解释：不选，dp\\[j]，选，dp\\[j - weight\\[i]] + value\\[i]\n\n遍历方式：\n\n```cpp\nfor (int i = 0; i < weight.size(); i++) {  // 遍历物品\n\tfor (int j = bagweight; j >= weight[i]; j--) {  // 遍历重量\n\t\tdp[j] = max(dp[j], dp[j - weight[i]] + value[i]);\n\t}\n}\n```\n\n### 题416：分割等和子集\n\n将一个数组分成两部分，要求和相等\n\n思路：求和，除以2，得到背包的大小target，数组本身既是weight也是value。满足条件：dp\\[target] == target。\n\n### 题1049：最后一块石头的重量2\n\n题目核心问题在于任意石头，不是相邻石头，故需要动态规划。\n\n思路：两快石头相消，得到石头A-石头B的重量，推导到整个数组就是两个子数组相消得到的最小重量。\n\n如何得到最小重量？尽量让两个数组之和相等。这就回到上面的题416解法。\n\n### 题494：目标和\n\n回溯：选+，选-，直到pos遍历完， 检查是否等于target\n\n动态规划：求sum，再添加-，得到target，故公式（设x等于+号和）：x + (sum - x) = target，x = (sum + target) / 2，此时问题转化为：填满背包大小为x的组合有多少种。\n\ndp\\[i]定义：填满i大小的背包，有dp\\[i]种组合。\n\n递推公式：dp\\[j] += dp\\[j - nums\\[i]]，表示填满0大小背包组合数+填满1大小背包组合数+...\n\n### 题kama52：完全背包\n\n完全背包和01背包的区别是，完全背包可以重复地选择1件物品，而01不行。\n\n在实现上，为支持1件物品被重复选择，只需要将内层背包循环按从小到大遍历即可。\n\n```cpp\nfor (int i = 0; i < weight.size(); i++) {  // 遍历物品\n\tfor (int j = weight[i]; j <= bagsize; j++) {  // 遍历重量，从小到大遍历\n\t\tdp[j] = max(dp[j], dp[j - weight[i]] + value[i]);\n\t}\n}\n```\n\n### 题474：一和零\n\n字符串数组，每个字符串0和1的数量，本质就是当前字符串元素的重量，0和1的数量分别不能超过m和n，那么m和n即为背包容量。所以这道题本质是背包问题。\n\ndp\\[i]\\[j]定义：容量为i的背包A和容量为j的背包B所能承载的最多物品数。\n\n### 题518：零钱兑换2\n\n硬币可重复pick，完全背包问题。\n\n**求组合数，而不是求最大价值。组合数**意味着没有顺序之分。\n\ndp\\[j]定义：背包容量为i时的组合数\n\n递推公式：dp\\[j] += dp\\[j - coins\\[i]]，表示：背包容量为j的组合数 = 不加coins\\[i]当前背包容量为j的组合数 + 新增coins\\[i]从j-coins\\[i]继承的组合数\n\n该递推公式要求dp\\[0] = 1，不能为0，否则后续的推导全部为0。\n\n| 背包dp槽位            | **0** | **1** | **2**                       | **3** | **4**                                | **5** |\n| :---------------- | :---- | :---- | :-------------------------- | :---- | :----------------------------------- | :---- |\n| coins\\[0] = 1填充背包 | 1     | 1     | 1                           | 1     | 1                                    | 1     |\n| coins\\[1] = 2填充背包 |       |       | 2=dp\\[0]+dp\\[2]，更新到当前dp\\[2] | 2     | 3=dp\\[4]+dp\\[2]，dp\\[2]前面刚更新为2，所以这里为3 | 3     |\n| coins\\[2] = 5填充背包 |       |       |                             |       |                                      | 4     |\n\n### 题377：组合总和4\n\n**本题求排列数，有顺序之分。**\n\n排列数和组合数在for循环有差别：\n\n*   **如果求组合数就是外层for循环遍历物品，内层for遍历背包**。\n*   **如果求排列数就是外层for遍历背包，内层for循环遍历物品**。\n\n原因：如果把遍历nums（物品）放在外循环，遍历target的作为内循环的话，举一个例子：计算dp\\[4]的时候，结果集只有 {1,3} 这样的集合，不会有{3,1}这样的集合，因为nums遍历放在外层，3只能出现在1后面！\n\n### 题kama57：爬楼梯\n\n爬楼梯变式，可以选择小于等于m阶步长，爬n阶大小楼梯。\n\n背包：n，物品：\\[1\\~m]\n\n递推公式：dp\\[i] += dp\\[i - j]，其中i是背包，j是物品\n\n因为有序，所以背包在外，物品在内。\n\n### 题322：零钱兑换\n\n这道题求的是最小硬币数，前面求的是组合数。\n\n二者区别在于递推公式的变化。最小硬币数：dp\\[j] = min(dp\\[j], dp\\[j - nums\\[i]] + 1)\n\n其他注意点：因为是min，所以dp数组初始化为INT\\_MAX\n\n在遍历过程中，需规避INT\\_MAX + 1情况，否则溢出。\n\n递推公式的源头是dp\\[0]，应初始化为0。\n\n### 题279：完全平方数\n\n思路和上题一致，求最小数量。只是元素上做了一点区别，不是直接给的，而是要自己做下平方。\n\n### 题139：单词拆分\n\n思路：单词数组中的单词可重复抽取 ==> 完全背包\n\n背包：目标字符串。\n\ndp\\[j]定义：长度为j的字符串背包是否能被单词数组组合得到。\n\n有序：遍历背包长度，遍历单词长度\n\n递推公式：如果单词长度的子串“xxxxx\\[子串]”在单词数组里，且dp\\[xxxxx.len] == true, 则dp\\[j] = true。\n\n初始值：dp\\[0] = true，其他为false\n\n### 题kama56：多重背包\n\n01背包限定了物品数量为1，完全背包不限定物品数量，多重背包介于二者之间，限定了物品数量，但不一定为1。\n\n多重背包符合现实中的逻辑，物品资源是有限个的。\n\n多重背包可以退化为01背包，只需要将多个物品A展开为每一个物品A。\n\n所以整体代码框架是不变的，和01背包类似，唯一需要处理的是新增一个内部的for循环：\n\n```cpp\n#include <iostream>\n#include <vector>\nusing namespace std;\n\n\nint main() {\n    int bagweight, n;\n    cin >> bagweight >> n;\n    \n    vector<int> weights(n, 0);\n    vector<int> values(n, 0);\n    vector<int> nums(n, 0);\n    for (int i = 0; i < n; i++) cin >> weights[i];\n    for (int i = 0; i < n; i++) cin >> values[i];\n    for (int i = 0; i < n; i++) cin >> nums[i];\n    \n    vector<int> dp(bagweight + 1, 0);\n    for (int i = 0; i < n; i++) {\n        for (int j = bagweight; j >= weights[i]; j--) {\n            // 这里要根据物品数量做处理\n            for (int k = 1, k < nums[i]; k++) {\n                if (j - k * weights[i] < 0) continue;\n                dp[j] = max(dp[j], dp[j - k * weights[i]] + k * values[i]);\n            }\n        }\n    }\n    return dp[bagweight];\n}\n```\n\n### 题198：打家劫舍\n\n错误思路：维护一个前面有没有偷的标记，这种思路会导致起始点的偷or不偷不好处理。\n\n正确思路：偷or不偷，状态依赖。\n\ndp\\[i]定义：遍历到第i个物品时的最大金额。\n\n递推公式：dp\\[j] = max(dp\\[i - 2] + nums\\[i], dp\\[i - 1])，这里就表示了前1个偷or不偷的关系\n\n初始化：dp\\[0] = nums\\[0]，dp\\[1] = max(nums\\[0], nums\\[1])\n\n循环：只要1层循环即可，遍历物品。\n","source":"_posts/leetcode刷题随记.md","raw":"---\ntitle: leetcode刷题随记\ndate: 2024/02/05 23:00:00\ntoc: true\ncategories: \n - 编程基础\n---\n\n本文旨在记录刷题过程中的思考，以及在给定刷题路径上做一些变式补充。\n\n刷题路径遵循：<https://github.com/youngyangyang04/leetcode-master?tab=readme-ov-file>\n\n<!-- more -->\n\n## 数组\n\n### 题704：二分查找\n\n二分查找重点关注边界取舍，这里讨论left、right为闭区间的情况：\n\n*   外层循环为left <= right，具有等号\n*   里层赋值left = mid + 1 或 right = mid - 1，偏移1个单位\n\n为什么？\n\n外层循环取等号由内层赋值控制推导，存在加1减1时left == right的可能，且所指向的值未曾遍历。\n\n里层赋值偏移1个单位原因是，前一次的\\[mid]值判断已经在条件中得到结论，故下一个\\[mid]无需再遍历。\n\n> \\[数值]符号含义：指取该数值所指向的值。\n\n**变式题34：找边界**\n\n找出指定数值的起始位置和终止位置。仍然是二分查找，唯一要处理的点是：\n\n在匹配到指定数值后，不要停：\n\n*   起始位置对应：右边界 - 1\n*   终止位置对应：左边界 + 1\n*   暂存当前的位置\n\n最终循环会因为left <= right不满足打破。\n\n**变式题162：找峰值**\n\n题目要求只要找到任意一个峰值即可，为此可以使用二分。\n\n假设-1，n均为负无穷，所以原始数组就变为\\[-infinity, 1, 2, 1, -infinity]\n\n基于此取查找就可找到答案。\n\n因为数组不支持-1和n索引，所以可以定义一个匿名函数支持它，这里也利用了cpp中的pair\\<int,int>特性。\n\n```cpp\nauto get = [&](int i) -> pair<int, int> {\n\tif (i == -1 || i == n) {  // 如果是-1或n，pair第一个值比较起作用，一定是最小的\n        return {0, 0};\n    }\n    return {1, nums[i]};  // pair的第二值起作用，依据具体nums[i]\n};\n\nget(idx) > get(idx + 1) && get(idx) > get(idx - 1)  // 这就是峰值\n```\n\n### 题27：O1空间内处理数组删除\n\n方式1：快慢指针，快指针负责搜索不相等元素，慢指针负责等候快指针给的值进行存储。\n\n方式2：c++可以使用iterator，在`*it`匹配到相等元素后，通过erase删除v.erase(it)，并保证it不向下走，因为这里erase的实现上会讲数组后续元素都向前shift 1个单位，所以此时的it仍然指向下一个新值。\n\n当然，方式2比方式1慢很多（1ms vs 5ms），时间复杂度后者为O(n2)。\n\n### 题977：On时间内平方数组\n\n双指针解法，利用原有数组的有序特性 + 平方后的排序是两端大中间小的特性，推导出两个指针从两头开始，往中间遍历。\n\n### 题209：最小连续子数组\n\n使用滑动窗口，本质是双指针，维护一个双指针区间内部的sum，一边加一边卸，返回区间长度。\n\n**变式题121：股票价值最大化**\n\n思路：题目要求只能1次买入卖出，所以可以设想：每一天，都想一个问题，我在历史最低点买入，今天卖出，会盈利多少（也就是保存最小价格，和当天价格相减，取max，得到结果）\n\n**变式题122：支持多次买入卖出**\n\n思路：动态规划，二维数组做状态记录\n\n> 其实只用2个数值做记录也够用，因为我们总是只回看前一个数。\n\n一列是未持股时手上的现金，一列是持股后手上的现金\n\n下一列的值等于：\n\n*   今日未持股现金 = 昨日未持股现金，昨日持股后今日卖掉的现金 取最大&#x20;\n*   今日持股现金 = 昨日持股现金，昨日未持股现金买今日股票后的现金 取最大\n\n最后取未持股时的现金返回。\n\n### 题59：螺旋矩阵\n\n螺旋矩阵没什么算法，纯粹是边界处理，顺着方向写就行。\n\nright -> down -> left -> up\n\n每转一圈，边长减1。\n\n## 链表\n\n### 题203：移除链表元素\n\n两个基本注意点：\n\n*   要创建一个dummy节点，作为起始遍历辅助\n*   结束时要返回dummy.next，而不是head，因为head有可能已被删除\n\n### 题707：设计链表\n\n核心方法：addAtIndex，deleteAtIndex，get\n\n关键点是要初始化一个dummy节点，从该节点开始处理链表的新增和删除。其本质和上述移除链表元素是一样的，必须得有个假的头节点来处理index为0的情况。\n\n### 题206：翻转链表\n\n观察翻转前后的变化，只有相邻节点的next箭头变了，因此只需要prev、current两个变量：\n\n*   先暂存next，翻转current->prev\n*   然后prev、current往下平移1个单位\n\n最后prev就是头了。\n\n当然这道题的另一种思路是拷贝到新链表，弊端是占用了额外内存空间。\n\n### 题24：两两节点交换\n\n![](https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg)\n\n最小可重复交换操作为：\n\n```bash\n# 三个数一组\n[dummy 1 2] 3 4\n[dummy 2 1] 3 4\n# 指针偏移2个单位\ndummy 2 [1 3 4]\ndummy 2 [1 4 3]\n# 再偏移2个单位\ndummy 2 1 4 [3 null null]  # 无需交换\n\n# 不满两组的情况\n[dummy 1 2] 3\n[dummy 2 1] 3\ndummy 2 [1 3 null]  # 无需交换\n```\n\n所以截止条件为：只要有null，就无需再操作。\n\n这种最小可重复操作怎么发现的？\n\n观察一次有多少元素需要参与运算，上述1 2参与了，2的下一个元素3属于下一次运算的范畴，可以不处理。下一次运算时，3 4交换，此时前面的1箭头也要变，所以参与运算的就有3个。为了抽象为通用操作，第一次运算1 2时，在其前补充dummy元素。\n\n### 题19：删除链表的倒数第N个节点\n\n要求一次遍历计算出来：\n\n*   链表长度怎么获取？\n\n    *   只能遍历完。\n*   遍历完后推算出倒数第n的位置，怎么返回获取前后节点？\n\n    *   遍历时有意识的保存\n\n如何实现有意识的保存？思路：构造2个有距离的指针，同时shift遍历，距离就是n。\n\n### 题02.07：链表相交\n\n思路1：普通解法\n\n*   分别遍历每条链表，计算长度，得到长度之差\n*   挑长链表磨平差值\n*   此时两条链表并排，开始遍历比较，第一个出现相等的元素就是了\n\n思路2：数学算法\n\n链表A不相交部分长度a，链表A相交部分长度c\n\n链表A不相交部分长度a，链表A相交部分长度c\n\n```bash\na + c = m\nb + c = n\na + c + b = b + c + a\n```\n\n可以得到，不相交部分长度走完，一定是交点。\n\n### 题142：环形链表\n\n思路1：将所有被遍历的节点压栈set集合，如果有重复节点，set长度将不会增长。\n\n*   缺点：需要额外内存空间存储节点地址\n\n思路2：设置快慢指针，快指针1次2步，慢指针1次1步，如果快指针追上慢指针，则满足条件。\n\n一定能相遇吗？\n\n*   一定能的，即便快指针在固定节点循环，慢指针属于遍历，一定能踩到。\n\n相遇的点一定是交点吗？\n\n*   不是，但可以通过以下公式推导：假设a是环外长度，b是环内长度，n表示在环内转了n圈，f是快指针走的里程，s是慢指针走的里程\n\n```bash\n# 已知快指针比慢指针多走一倍里程\nf = 2s\n# 已知快慢相遇时，在相遇节点开始走n圈 + s就是快指针的里程\nf = s + nb\n# 推导得到\ns = nb\n# 已知从head走到入口节点需要：\na + nb\n# 慢指针已经走了nb步，还需再走a步，a步怎么来？和head开始的指针一起走，直至相遇，得到结论。\n```\n\n## hash表\n\n### 题242：有效的字母异位词\n\n思路1：最直接的方法是定义一个hashmap，第一轮迭代填充charMap，第二轮迭代减少charMap计数，如果出现-1的则return false。\n\n思路2：定义1个具有26长度的数组，每个位置依据字符串的字符位置进行++--，最后check一遍得到结果。\n\n### 题1002：查找共用字符\n\n这里有个坑是，不是说一个字母统计一次就行，而是如相同字母在多个words里分别重复出现了，那就都得输出出来。\n\n思路：一个当前word的freq数组，一个全局words的最小freq数组，分别统计每个词的字母出现频率。\n\n全局word在的foreach每个词时，总是取当前word每个槽位的最小值。\n\n### 题349：两个数组的交集\n\n这道题跟上面一道题有点类似，这道题要求一个字母只统计1次，并且只有两个数组之间的比较，所以可以认为是上一道题的简单版本。\n\n思路：set存储第一个数组内容，set.count(第二个数组中的每一个元素)，如果存在，则return\n\n### 题202：快乐数\n\n首先理解题意：\n\n*   拆解的数的每一位做平方\n*   希望得到1\n*   可能永远都得不到\n*   得不到的原因是无限循环（在某个圈内循环转）\n\n解题关键：找到循环的入口\n\n具体思路：记录历史算数，如果重复或为1，则退出\n\n### 题1：两数之和\n\n思路：排序，二分，要寻找的对象是：find(和 - 当前数值)。\n\n寻找对象的方法还可以是hashset，即hashset + find，这里要注意，find到值不能是自己，并且还要有数组下标返回，所以通过hashmap更合适。\n\n### 题454：四数相加\n\n四个数组，长度一致；每个数组挑1个数，和其他数相加；求和要等于0；返回有多少种可能。\n\n要把所有组合都遍历一遍，n的4次方。减少复杂度方法是，分为2组，每组n的2次方，从等于0改为ab组 = -cd组。ab组的求和存入hash表，值为等于该和的组数；cd组查询，这样就得到最终结果。\n\n### 题383：赎金信\n\n数组2中的字符作为候选，数组1消费。\n\n给1个hashmap对候选计数，数组1遍历时消费，如果找不到或value出现小于0的情况，则为false。\n\n### 题15：三数之和\n\n思路1：选target，剩下的元素求“两数之和”，因为本题要求返回所有元组，而两数之和给了1个只有1个元组答案的约束，所以，本题最后还得有一层去重处理。\n\n思路2：组合问题，从数组中选3，求和。\n\n组合问题是无序的，相比有序的数组还是差了点效率。所以\n\n思路3：这里可以基于排序后的数组，使用双指针解决\n\n*   遍历数组，从first = 0，选target\n*   定义left = first + 1、right == n - 1，双指针两方向往中间靠近，找所有解\n\nsecond和third就是双指针。\n\n### 题18：四数之和\n\n本质是在三数之和上套一层循环，怎么理解？\n\n*   遍历数组，从first = 0，选target\n*   遍历数组，从second = first + 1\n*   定义left = second + 1、right = n - 1，双指针两方向往中间靠近，找所有解\n\n相关剪枝细节（其实就是哪些可以跳过不做的）这里不展开。\n\n## 字符串\n\n### 题344：反转字符串\n\n这道题要求原地反转。\n\n思路：双指针从两端到中间依次反转字符对，截止条件：指针相遇或错过。\n\n**变式题541：反转字符串2**\n\n相比上一道字符串增加了步长，其余逻辑一致。\n\n### 题kama54：替换数字\n\n这道题也是要做到原地变更字符串。利用C++里的s.resize方法。\n\n核心思路是：预留卡位，从后往前填。\n\n### 题151：反转字符串中的单词\n\n这题考察对string api的熟悉程度。\n\n更高要求：原地修改字符串，大致步骤：\n\n*   字符串reverse\n*   删除多余空格\n*   单词reverse\n\n### 题kama55：右旋字符串\n\n思路上跟上道题类似，右旋只是表象，本质还是2个操作：\n\n*   字符串reverse\n*   区间字符串reverse（等同于单词reverse）\n\n### 题459：重复的子字符串\n\n特殊例子：ababdababd、acdfdacdfd，这也是重复的\n\n思路1：比较朴素的解法\n\n*   遍历各种长度（满足size % 长度 == 0）的子串\n*   始终满足是前一个子串的前缀：s\\[j] == s\\[j - 1]，j++，j < size\n\n思路2：特殊性质\n\n*   如果是重复子串，则abab + abab，去掉头尾， = bababa 包含ab\n*   如果不是，则absab + absab = bsababsa 不包含 absab\n\n## 双指针\n\n### 题27：移除元素\n\n原地操作移除元素，可使用快慢指针，慢指针指向当前要赋值的位置，快指针指向非目标元素的位置，如此迭代。\n\n## 栈与队列\n\n### 题232：用栈实现队列\n\n队列FIFO，栈LIFO，用栈实现队列核心要解决如何将栈头元素弹出问题。\n\n让第一次进栈的元素保持在栈尾？双栈思路。\n\n在pop/top时操作，将当前所有元素都转移到新栈上。\n\n注意这里有个tracky，新栈总是在为空时才从旧栈中补充元素。\n\n### 题225：用队列实现栈\n\npush时操作，将新push进队列的元素置于front位置，可通过循环将其他元素pop再push的方式。\n\n### 题20：有效的括号\n\n校验括号的方法：左括号进栈，右括号遇到匹配的左括号，则左括号弹栈，否则右括号进栈。\n\n### 题1047：删除字符串中的所以相邻重复项\n\n和上述题一样，相同的消掉，不同的入栈，最后反转下栈内元素输出即可。\n\n### 题150：逆波兰表达式求值\n\n思路：如果时数字，压栈，如果是符号，弹出两个数字，计算，再压栈。\n\n### 题239：滑动窗口最大值\n\n看着简单，操作起来有点难度。\n\n思路：优先队列，它能解决区间最大值的问题。但还要考虑：\n\n*   如何删除区间的第一个值问题\n\n这里就有一个位置信息需要在优先队列里保留，方法：\n\n*   设置队列节点为\\<nums\\[i], \\[i]>的pair对\n\n那么必须要始终确保优先队列的长度为窗口大小吗？不用。其实只要确保当前队列里的top仍然在窗口内，那么top就不需要摘除，保留即可，其他比top小的窗口外元素不影响。\n\n### 题347：前k个高频元素\n\n前k个 --> 优先队列，返回高频元素，所以队列元素设计为<频率,元素>pair，为了得到这种pair，还需要使用map收集。\n\n这块还需要重写优先队列的排序方式，只用频率排序。\n\n## 二叉树\n\n### 题144/145/94：二叉树遍历\n\n前序：中左右\n\n中序：左中右\n\n后序：左右中\n\n可以看出，前后是基于树的高来讲，root在树顶点，那么它就是前，树的叶子节点就是后。\n\n### 题102：层序遍历\n\n从上到下输出，前序\n\n遍历是深度的，所以还需要辅助信息，也就是层高\n\n层高对应到数组索引\n\n所以思路1：深度优先搜索\n\n```cpp\nclass Solution {\npublic:\n    vector<vector<int>> levelOrder(TreeNode* root) {\n        vector<vector<int>> res;\n        traversal(root, 0, res);\n        return res;\n    }\n\n    void traversal(TreeNode* node, int level, vector<vector<int>>& res) {\n        if (node == nullptr) {\n            return;\n        }\n        while (res.size() <= level) {\n            vector<int> ele;\n            res.push_back(ele);\n        }\n        res[level].push_back(node->val);  // 深度遍历到对应层级时加入对应的数组内\n        traversal(node->left, level + 1, res);\n        traversal(node->right, level + 1, res);\n    }\n};\n```\n\n思路2：广度优先搜索的层序版\n\n通过辅助的队列来实现。队列的职责是保存每一层的节点：\n\n*   检查队列是否为空\n*   **全部遍历**，依次弹出，取这些节点的左右节点重新入队列\n*   如此循环\n\n```cpp\nclass Solution {\npublic:\n    vector<vector<int>> levelOrder(TreeNode* root) {\n        vector<vector<int>> res;\n        if (root == nullptr) {\n            return res;\n        }\n        queue<TreeNode*> q;\n        q.push(root);\n        while (!q.empty()) {\n            int levelsize = q.size();\n            res.push_back(vector<int>());\n            for (int i = 0; i < levelsize; i++) {  // 广度优先搜索不需要这一层\n                TreeNode* cur = q.front();\n                q.pop();\n                res.back().push_back(cur->val);\n                if (cur->left != nullptr) {\n                    q.push(cur->left);\n                }\n                if (cur->right != nullptr) {\n                    q.push(cur->right);\n                }\n            }\n        }\n        return res;\n    }\n};\n```\n\n> 这里要注意一个细节，即层序遍历不是广度优先搜索。广度优先是1个节点1个节点逐个往下走，它没有层的信息，而层序遍历是将层的信息显性化出来。\n\n**变式题107：要求返回从底向上的层序遍历**\n\n思路：基于常规层序遍历将res翻转下。\n\n有其他思路吗？没有，官方题解本质仍然是翻转，只是在while循环中翻转和循环完翻转的问题。\n\n**变式题199：二叉树的右视图**\n\n思路1：层序，保留每一层的最优节点值。\n\n思路2：层序或dfs，在最后res中取back值。\n\n**变式题637：二叉树的层平均值**\n\n同样的做法，层序遍历时求平均。\n\n**变式题429：N叉树的层序遍历**\n\n只需要改造left、right为for children即可。\n\n**变式题515：二叉树的层最大值**\n\n同样的做法，层序遍历求最大。\n\n**变式题116：填充每个节点的下一个右侧节点**\n\n层序，在遍历时做好前后节点的next关联。\n\n**变式题104：二叉树的最大深度**\n\n思路1：层序，为层计数。\n\n思路2：深度DFS，可以不用辅助函数。\n\n**变式题559：N叉树的最大深度**\n\n思路类似，深度遍历，每下钻一层加1。\n\n**变式题111：二叉树的最小深度**\n\n思路：层序，当left、right都为空时直接返回。\n\n### 题226：翻转二叉树\n\n思路：深度遍历，无需辅助函数，直接翻转（这里可以选择前序，也可以选择后序）。\n\n### 题101：对称二叉树\n\n思路：层序遍历，弹出单层数组，判断是否对称。这里有个处理技巧，就是单层元素不按从左到右加入队列，而是两端对称加入；每次循环弹出2个节点进行比较。\n\n### 题222：完全二叉树的节点个数\n\n参考二叉树的最大深度解法，通过DFS来解。\n\n因为二叉树的性质，这里还有一种二分查找的解法，先算出有多少层，然后再二分叶子节点。\n\n### 题110：平衡二叉树\n\n平衡的性质是左右子树的高相差小于等于1\n\n*   首先要能算出高\n*   其次是判断是否满足小于等于1的条件\n\n### 题257：二叉树的所有路径\n\n深度优先搜索，本质也是使用回溯的方法，设计好输入、截止条件即可。\n\n### 题513：找树左下角的值\n\n左下角，高度最大，最左\n\n深度遍历需要带上这两个状态，同时要带上answer（当前高度，当前值）\n\n如果新遍历的比当前高度高，则刷新answer。\n\n处理细节：是否为左节点的状态可以去掉，转为由height > answer.curHeight代替，原因：height递增时的首次遍历的节点一定是左节点（通过由先遍历左子树再遍历右子树的方式控制）。\n\n### 题112：路径之和\n\n求路径和，判断是否等于目标值。\n\n路径和 = DFS + sum累加，遇到叶子节点后截止。\n\n### 题106：已知中后序，构造二叉树\n\n特征：后序的最后1个元素总是根节点。\n\n步骤：\n\n*   后序数组倒序遍历，选取的元素拿到中序遍历中做边界，分出左右子树数组\n*   递归构造左子树数组\n*   递归构造右子树数组\n*   左右子树拼接到当前的根节点\n\n因为涉及元素到index的查询，所以，构造1个（元素，index）的map加快索引。\n\n### 题654：最大二叉树\n\n这道题跟题106类似，递归，选出根节点，构造左右子树，拼接到根节点即可。\n\n### 题617：合并二叉树\n\n合并二叉树的逻辑也是构造左右子树，拼接到根节点。\n\n### 题700：二叉搜索树\n\n深度遍历即可，小于往左，大于往右。\n\n### 题98：验证二叉搜索树\n\n需满足两条规则：\n\n*   当前节点比左节点大，比右节点小；\n*   当前节点要小于或大于整体子树的区间范围，比如\\[5,4,7,null,null,3,9]，3比4小，false\n\n> 搜索树有个特征：不存在两个节点的值重复。\n\n### 题530：二叉搜索树的最小差值\n\n注意题目要求是任意两节点，非相邻节点。但实际根据树的性质，最小值只会存在于**中序遍历**下相邻的两个节点（因为中序遍历将得到1个递增序列）。\n\n中序遍历需具有以下状态：前一个节点的值，当前的最小值。\n\n### 题501：二叉搜索树的众数\n\n这道题的二叉树定义为节点值可重复。\n\n仍然按中序遍历，因为是递增序列，所以在遍历时保存前一个节点值preval，该值的count，当前的最大count，以及当前的最大countVals（因为要返回具体的val值）\n\n官方解答对首次处理中序有一个比较晦涩的点：\n\n```cpp\nint preval, int curCount, int maxCount\n\ndfs // 前序\n// 中序，注意看这里省略了对preval未初始化情况的处理\nif (node->val == preval) {\n  curCount++; \n} else {\n  curCount = 1;\n  preval = node->val;\n}\n```\n\n更直观的写法：\n\n```cpp\nint preNode, int curCount, int maxCount\ndfs // 前序\n// 中序\nif (preNode == nullptr) {\n  curCount = 1;\n} else if (preNode->val == node->val) {\n  curCount++;\n} else {\n  curCount = 1;\n}\npreNode = node;\n```\n\n可以看到，直观的写法中，if elseif块内的处理是一致的，故官方解法直接将二者合并为1个，无论preval是什么。\n\n### 题236：二叉树的最近公共祖先\n\n最近公共祖先的特征：\n\n*   该祖先的下一个node->left和node->right必有一方不是祖先\n\n所以在搜索时，可以先探查左右子树，如果同时为空，则说明该节点不包含目标；如果同时不为空，则说明该节点就是二者的公共祖先；如果一方为空、一方不为空，为空的子树没有包含目标，往不为空的搜索。\n\n```cpp\nclass Solution {\npublic:\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\n        if (root == nullptr || root == p || root == q) return root;\n\n        TreeNode* left = lowestCommonAncestor(root->left, p, q);\n        TreeNode* right = lowestCommonAncestor(root->right, p, q);\n\n        if (left == nullptr && right == nullptr) return nullptr;\n        if (left != nullptr && right != nullptr) return root;\n        if (left == nullptr) return right;\n        if (right == nullptr) return left;\n        return root;\n    }\n};\n```\n\n### 题701：二叉树的插入操作\n\n思路：找到节点要插入的位置，挂上去，这种适合前序遍历。\n\n首先判断节点是否为null，是则构造一个当前val的节点返回；否则对left、right进行遍历，并对返回值重新挂载到root。\n\n### 题450：二叉树的删除操作\n\n类似插入操作，同样是找到节点，然后执行删除：\n\n*   如果左右子树均为空，返回空\n*   如果左子树为空，返回右子树\n*   如果右子树为空，返回左子树\n*   如果都不为空，则找到右子树的最左节点，把当前左子树挂到这个节点上，然后返回右子树\n\n### 题669：修剪二叉搜索树\n\n区间描述要保留的节点，中序遍历，一路trim节点，trim规则：\n\n*   小于左边界的，trim左子树\n*   大于右边界的，trim右子树\n*   满足区间内的，左子树的trim结果挂到左节点，右子树的trim结果挂到右节点（整体结构上只会有边界节点会变化）\n\n```cpp\nclass Solution {\npublic:\n    TreeNode* trimBST(TreeNode* root, int low, int high) {\n        if (root == nullptr) {\n            return root;\n        }\n        if (root->val < low) {\n            return trimBST(root->right, low, high);\n        }\n        if (root->val > high) {\n            return trimBST(root->left, low, high);\n        }\n        root->left = trimBST(root->left, low, high);\n        root->right = trimBST(root->right, low, high);\n        return root;\n    }\n};\n```\n\n### 题108：有序数组转平衡二叉树\n\n二分查找，每个被发现的中间元素作为root节点，而二分本身能够确保树平衡。\n\n### 题538：二叉树转换为累加树\n\n二叉树转为递减数组，每次遍历累加前一个节点的值\n\n如果实现递减遍历？通过颠倒的中序遍历来做。\n\n遍历过程需要维护一个[currentSum]()值。\n\n## 回溯\n\n### 题77：组合\n\n这道题有两种写法，第一种是带有for循环的：\n\n```cpp\nclass Solution {\npublic:\n    vector<vector<int>> combine(int n, int k) {\n        vector<int> curVec;\n        vector<vector<int>> res;\n        backtracking(n, k, 1, curVec, res);\n        return res;\n    }\n\n    void backtracking(int n, int k, int start, vector<int>& curVec, vector<vector<int>>& res) {\n        if (curVec.size() == k) {\n            res.emplace_back(curVec);\n            return;\n        }\n        for (int i = start; i <= n; i++) {\n            curVec.push_back(i);\n            backtracking(n, k, i + 1, curVec, res);\n            curVec.pop_back();\n        }\n    }\n};\n```\n\n第二种是不带for循环的：\n\n```cpp\nclass Solution {\npublic:\n    vector<vector<int>> combine(int n, int k) {\n        vector<int> curVec;\n        vector<vector<int>> res;\n        backtracking(n, k, 1, curVec, res);\n        return res;\n    }\n\n    void backtracking(int n, int k, int cur, vector<int>& curVec, vector<vector<int>>& res) {\n        if (curVec.size() + n - cur + 1 < k) {  // 这里做了剪枝处理，表示如果当前数组长度+剩余待遍历区间长度小于k时，跳过不遍历，因为没必要\n            return;\n        }\n        if (curVec.size() == k) {\n            res.emplace_back(curVec);\n            return;\n        }\n        if (cur == n + 1) {\n            return;\n        }\n        curVec.push_back(cur);\n        backtracking(n, k, cur + 1, curVec, res);\n        curVec.pop_back();\n        backtracking(n, k, cur + 1, curVec, res);\n    }\n};\n```\n\n以上存在一个细节，在回收结果处，使用了emplace\\_back来copy数组\n\n其他方案有：\n\n*   入参不带&，而使用copy：backtracking(int n, int k, int cur, vector\\<int> curVec, vector\\<vector\\<int>>& res)\n*   入参带&，在回收结果时，自行构造一个新vector拷贝curVec\n\n实验证明，上述两种都不高效，且第一种方案内存使用异常高，是最优方案的10倍。\n\n**变式题216：组合总和3**\n\n这道题同样求组合，加了1个约束，要求组合的总和要等于指定值。\n\n思路：遍历所有组合，维护当前总和值，如果等于指定值且组合的size等于指定size，则返回，否则回溯。\n\n剪枝细节：同上道题，vec长度+区间长度 < 指定长度或者 vec长度大于指定长度的，无需遍历，直接返回。\n\n**变式题39：组合总和**\n\n这道题的约束为，不限制给定数组中的某个数被选择几次，找出所有能够求和等于target值的组合。\n\n类似题目：爬楼梯，可选的一步台阶范围类比这里给定的数组。\n\n解法（更适合不具有for循环的递归）\n\n```cpp\n    void backtracking(vector<int>& candidates, int index, int target, vector<int>& curVec, vector<vector<int>>& res) {\n        if (index == candidates.size()) {\n            return;\n        }\n        if (target == 0) {\n            res.emplace_back(curVec);\n            return;\n        }\n\n        // 跳过不使用candidates[index]\n        backtracking(candidates, index + 1, target, curVec, res);\n\n        // 使用candicates[index]\n        if (target - candidates[index] >= 0) {\n            curVec.emplace_back(candidates[index]);\n            backtracking(candidates, index, target - candidates[index], curVec, res);\n            curVec.pop_back();\n        }\n    }\n```\n\n**变式题40：组合总和2**\n\n这道题放宽了对给定数组的约束，允许数组内有元素重复，并且，结果要求不可重复，且每个元素只能被用一次。\n\n对于只能被用一次这条，正常组合解法已覆盖。\n\n对于结果要求不可重复这条，需要做两个步骤：\n\n*   对给定数组排序\n*   带for循环递归时，检查前后两个元素是否相同，是则跳过\n\n剪枝细节：如果target - 当前元素小于0，可以直接break，无需继续遍历。\n\n### 题17：电话号码的字母组合\n\n这道题求的是多组字母内分别取1的组合，之前的题型则为1组数内取k的组合。\n\n多组取1，对上述1组取多进行变式：\n\n```cpp\n    void backtracking(vector<string>& digitLetters /* 多组取1 */, int index /* 指向哪一组 */, string& curStr, vector<string>& res) {\n        if (curStr.size() == digitLetters.size()) {\n            res.emplace_back(curStr);\n            return;\n        }\n        for (int i = 0; i < digitLetters[index].size(); i++) {  // 遍历每一组内的所有字母\n            curStr.push_back(digitLetters[index][i]);\n            backtracking(digitLetters, index + 1, curStr, res);\n            curStr.pop_back();\n        }\n    }\n```\n\n### 题131：回文字符串\n\n遍历字符串，选择步长，可以是1，2，3等，检查该子串是否符合，如果符合，加入结果；如果不符合，继续往大步长遍历。\n\n每次处理完当前子串后，对剩余的子串做相同动作（回溯）\n\n将这个过程具象化为一张横纵回溯图，如下所示：\n\n![image](https://camo.githubusercontent.com/0e9d7097c5f8a06d6ee1a6fd0ab110e981442669d0dbcdeb6d5e25ef615d5f1a/68747470733a2f2f636f64652d7468696e6b696e672e63646e2e626365626f732e636f6d2f706963732f3133312e2545352538382538362545352538392542322545352539422539452545362539362538372545342542382542322e6a7067)\n\n横向对当前子串的区间放大，并分别判断\n\n纵向对剩余子串做同等处理\n\n### 题93：复原IP地址\n\n和回文串类似，对当前子串长度进行遍历，对剩余子串进行回溯。\n\n这里唯一要注意下对子串的合法性进行校验。\n\n### 题78：子集\n\n和爬楼梯类似，无需for循环，分考虑当前位置、不考虑当前位置两种场景进行回溯。\n\n```cpp\nclass Solution {\npublic:\n    vector<vector<int>> subsets(vector<int>& nums) {\n        vector<int> subset;\n        vector<vector<int>> res;\n        backtracking(nums, 0, subset, res);\n        return res;\n    }\n\n    void backtracking(vector<int>& nums, int start, vector<int>& subset, vector<vector<int>>& subsets) {\n        if (start >= nums.size()) {\n            subsets.emplace_back(subset);\n            return;\n        }\n        subset.push_back(nums[start]);\n        backtracking(nums, start + 1, subset, subsets);\n        subset.pop_back();\n        backtracking(nums, start + 1, subset, subsets);\n    }\n};\n```\n\n思考：什么时候回溯需要for循环，什么时候不用？\n\n其实这道题也可以套for循环：\n\n```cpp\nclass Solution {\npublic:\n    vector<vector<int>> subsets(vector<int>& nums) {\n        vector<int> subset;\n        vector<vector<int>> res;\n        backtracking(nums, 0, subset, res);\n        return res;\n    }\n\n    void backtracking(vector<int>& nums, int startIndex, vector<int>& subset, vector<vector<int>>& subsets) {\n        subsets.push_back(subset); // 收集子集，要放在终止添加的上面，否则会漏掉自己\n        if (startIndex >= nums.size()) { // 终止条件可以不加\n            return;\n        }\n        for (int i = startIndex; i < nums.size(); i++) {\n            subset.push_back(nums[i]);\n            backtracking(nums, i + 1, subset, subsets);\n            subset.pop_back();\n        }\n    }\n};\n```\n\n相比第一种没有for循环写法，具有for循环的写法明显不那么直观。\n\n**变式题90：子集2**\n\n相比上道题，这道题给定的数组元素重复，求不重复的子集。\n\n解法和**组合求和2**一致，先排序，再回溯，检测前后重复的跳过。\n\n### 题491：非递减子序列\n\n给定数组，带重复元素，找所有非递减子序列。\n\n这道题特殊之处在于需要给子序列回溯加限定条件：\n\n*   当前元素比序列中最后1个元素大的，不考虑\n*   当前元素已经在之前用过的，不考虑（使用set数据结构，保存本层当前元素）\n\n比如\\[4,7,6,7]：4回溯，7回溯，6跳过，7跳过\n\n### 题46：全排列\n\npush1 push2 push3 ==> 1,2,3\n\npush1 push2 pop2 push3 ==> 1,3,2\n\npop掉的元素需要有地方暂存，直接存回数组？—— 可以用1个bool数组标记是否被使用过。\n\n因为全排列不分前后顺序，所以在每层回溯时都要遍历全部nums数组元素。\n\n**变式题47：全排列2**\n\n给定的nums数组现在具有重复元素了，求全排列。\n\n重复元素的做法：排序，for循环遇到重复元素，跳过\n\n这里仅上述判断还不够，因为类似\\[1,2,2]的答案，2和2重复，但不能跳。\n\n所以还得再加1个原则：nums\\[i - 1]被用过，即used\\[i - 1] == false。\n\n## 贪心\n\n### 题455：分发饼干\n\n约束：每个人最多获得1块饼干。\n\n贪心策略：人按胃口排序，饼干按大小排序，遍历每个人，找能满足当前这个人胃口的最小饼干。\n\n### 题376：摆动序列\n\n删除若干元素后形成摆动序列，求序列最长的长度：可以转化为统计峰谷的数量。\n\n> 这里有个思维误区是：求要删除多少个元素，然后用序列总长 - 要删除的元素，该思路本身没问题，但对前后相等的过渡元素场景不好处理。\n\n### 题53：最大子数组和\n\n贪心策略：如果当前数组的sum为负数，则直接丢弃当前数组的sum（使sum置为0），从下一个新的元素开始计数。\n\n### 题122：买卖股票的最佳时机2\n\n贪心策略：求多个不相交的区间，区间的利润不存在负收益，然后对这些区间求和，得到最大利润。\n\n因为多个不相交无负收益区间之和等价于多个间隔为1的无负收益区间之和，所以问题可以简化相邻元素相减。\n\n### 题55：跳跃游戏\n\n贪心策略：每一个元素都遍历一遍，检查该元素能够跳到的位置，不断统计取最远，如果遍历时发现的当前i指针超过了最远的位置，那就说明后面的元素不可达，return false。\n\n### 题45：跳跃游戏2\n\n这道题保证了一定能跳到终点，求最小步数。\n\n仍然是每个元素都遍历一遍，检查该元素能够跳到的位置，不断统计取最远。不同的是，在这里面，需要维护一个每次跳的区间。\n\n比如首次区间就是：start = 0, end = 1\n\n后面的区间则为：start = end, end = rightmost + 1\n\n### 题1005：K次取反后的数组最大和\n\n贪心策略：\n\n*   值越小取反收益越大，比如：1 2选1，-2 -1选-2\n*   都是非负数时，对当前最小值进行反复取反\n\n简单点可以考虑用最小堆。\n\n### 题134：加油站\n\n能否到终点：对所有剩余油量求和，如果小于0，则无法到终点。\n\n选起点：该起点应能到达下一站；该起点应剩余油量要足够大（反例：\\[1,1,3], \\[1,2,1]，0号加油站不能作为起点，2号可以 ==>\\[0,-1,2]）\n\n如果有1段特别大cost的呢？比如剩余油量：\\[1,2,-3]，选1号加油站过不去，只能选0号加油站。\n\n所以问题变为，剩余油量序列，累积子序列不能为负。\n\n如果出现负数，怎么办？\n\n思路1：从后往前寻找能填平该负数的index，如果有，那么该index就是起点。\n\n```cpp\nclass Solution {\npublic:\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\n        int endIndex = 0;\n        int sumRest = 0;\n        int minGasRest = INT_MAX;\n        for (int i = 0; i < gas.size(); i++) {\n            int rest = gas[i] - cost[i];\n            sumRest += rest;\n            if (sumRest < minGasRest) {\n                minGasRest = sumRest;\n                endIndex = i;\n            }\n        }\n        if (sumRest < 0) {  // 不能到达终点\n            return -1;\n        }\n        if (minGasRest >= 0) {  // 0作为起点就能到达终点\n            return 0;\n        }\n\n        // 0作为起点不能达到终点，缺油，从后面补\n        for (int i = gas.size() - 1; i >= endIndex + 1; i--) {  // 注意有些答案将endIndex + 1处理为0，原因是即便从后往前重复计算前半段，前半段已经明确缺油，前半段计算进去也找不到补\n            int rest = gas[i] - cost[i];\n            minGasRest += rest;\n            if (minGasRest >= 0) {\n                return i;\n            }\n        }\n        return -1;\n    }\n};\n```\n\n思路2：借鉴最大子序列和的思路，出现负数时，就需要舍弃这部分，从下一个元素作为新起点。\n\n```cpp\nclass Solution {\npublic:\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\n        int curSum = 0;\n        int totalSum = 0;\n        int start = 0;\n        for (int i = 0; i < gas.size(); i++) {\n            int rest = gas[i] - cost[i];\n            curSum += rest;\n            totalSum += rest;\n            if (curSum < 0) {\n                start = i + 1;\n                curSum = 0;\n            }\n        }\n        if (totalSum < 0) return -1;  // 无解\n        return start;  // 如果有解，一定从子序列之和为非负数开始\n    }\n};\n```\n\n### 题135：分发糖果\n\nrating为1,2,3的，糖果为1,(1+1),(2+1)，后一个数=前一个数+1\n\nrating为3,2,1的，糖果为(2+1),(1+1),1，前一个数=后一个数+1\n\n推测：正方向遍历\n\n如果遇到正向递减的，如1,2,3,2,1，是否要跟着减一？不需要，如果减一会丢失的重复元素的位置信息。故正向递减按规则得到1,2,3,1,1\n\n按倒序规则得到1,1,3,2,1\n\n两个数组结合取最大值，得到1,2,3,2,1，就是我们最后想要的。\n\n重复元素怎么办？也适用\n\n1,2,3,3,3,2,1\n\n*   正向：1,2,3,1,1,1,1\n*   反向：1,1,1,1,3,2,1\n*   最大：1,2,3,1,3,2,1 ==> 是最终结果\n\n### 题860：柠檬水找零\n\n贪心思路：拿当前能够满足找零的最大面额去填。\n\n### 题406：根据身高重建队列\n\n这道题有点脑筋急转弯。关键还是要发现队列的规律：\n\n*   先按身高排（从高到低），如果身高相等的，按前方高于自身的数量排（从小到大），此时的序列接近直觉\n*   按上述顺序依次插入到新队列，身高高的总是先插入，身高矮的后插入，插入位置基于当前元素的前面高于自身的数量定，无论插入到哪都不会对当前新队列中已有的元素值造成影响，所以得到的新队列结果就是我们想要的。\n\n### 题452：用最小数量的箭引爆气球\n\n气球区间重叠的可用1支箭射爆，那么问题就变为寻找子集的数量。\n\n我们对所有气球区间按左边界排序，然后维护1个子集和所有气球区间比对，有更小的子集就更新，最后返回子集数量即可。\n\n### 题435：无重叠区间\n\n两个步骤：\n\n*   排序，按右边界大小排（优先参加结束时间早的），如果相等的，选区间长度短的\n*   遍历，发现有交集就去掉当前区间，计数加1\n\n另一个思路：\n\n*   排序，按左边界大小排，如果相等的，选区间长度短的\n*   遍历，发现有交集就去掉大的区间，留小区间，计数加1\n\n### 题763：划分字母空间\n\n这道题本质是求重叠子区间的题，但因为字母多，形成的子区间多，求子区间交集较为复杂，为此有一个巧妙的思路：通过遍历字符串，比较当前索引是否等于当前字母的右区间，是则为分割点。\n\n### 题56：合并区间\n\n也是求重叠子区间问题，常规思路，排序，依次遍历，发现有重合的就合并，否则加入结果集返回。\n\n### 题738：单调递增的数字\n\n找规律：从后往前，依次比较，如果出现不符合预期单调的，基于该规则改：比如32改为29，如此反复：4332，4329，4299，3299，2999。\n\n### 题968：监控二叉树\n\n贪心思路：让摄像头数量最少 等价于 让叶子节点尽量不要有摄像头，因为叶子节点放摄像头是非叶子节点的指数倍。\n\n为实现这种思路，需要对节点的状态分级：\n\n*   0：节点无覆盖\n*   1：节点有摄像头\n*   2：节点有覆盖\n\n通过后序遍历，基于每个节点的情况递推该状态值，并按情况放摄像头和计数。\n\n## 动态规划\n\n### 题509：斐波那契数\n\nf(2) = f(1) + f(0); f(3) = f(2) + f(1)；f(0)和f(1)已知，所以直接基于此for循环滚动相加到指定n值即可。\n\n动态规划在这里面用到的位置为：每次for循环记录n-1 n-2处的值。\n\n### 题70：爬楼梯\n\nn阶楼梯到顶，就有n-1阶楼梯的dp\\[n-1]种方法 + n-2阶楼梯的dp\\[n - 2]种方法。\n\n本质是斐波那契数。\n\n所以解法和斐波那契数一致。\n\n### 题746：使用最小花费爬楼梯\n\n动态规划数组定义：dp\\[i] = min(dp\\[i-1] + cost\\[i-1], dp\\[i-2] + cost\\[i-2])\n\n解释：dp\\[i]指当前第i阶所花费的最小费用。\n\n### 题62：不同路径\n\n机器人到达mxn矩阵右下角有多少不同路径，定义dp\\[i]\\[j]，表示到达i,j点有多少不同路径，其等于(i-1,j),(i,j-1)点的路径数之和。\n\n**变式题63：不同路径2**\n\n这道题在mxn矩阵中加了障碍物，整体思路是不变的，核心点在于遇到障碍物后，障碍物位置的dp\\[i]\\[j]要清零。\n\n### 题343：整数拆分\n\n一个整数i，可以拆分为：\n\n*   两个整数，j \\* (i - j)\n*   一个整数和再拆分的整数相乘：j \\* 再拆分(i - j)\n\n定义dp\\[i]为整数i的最大乘积\n\n那么上述再拆分的乘积即为：j \\* dp\\[i - j]\n\n那么整数i的最大乘积即可从上述两种情况中获取：\n\n```bash\nmax(j * (i - j), j * dp[i - j])\n```\n\nj的取值可以从1到i-1遍历，计算每种拆分j的值，取最大，就得到当前dp\\[i]最大：\n\n```bash\ncurMax = 0;\nfor j = 1..i-1\n\tcurMax = max(curMax, max(j * (i - j), j * dp[i - j]))\ndp[i] = curMax\n```\n\n### 题96：不同的二叉搜索树\n\n动态规划思路：\n\n遍历1..n，计算每个数i作为根节点时的二叉树个数，然后求和。\n\n定义dp\\[i]，表示以i为根节点时的二叉树个数\n\n针对每个根节点的取值j，都有dp\\[j] = dp\\[j-1] \\* dp\\[i-j]，得解。\n\n### 题kama46：01背包\n\n定义物品的weight和价值value，求一个给定bagweight容量的背包，可以放入的最大价值。\n\n这种就是01背包问题，对于每个物品，要么选1个，要么不选\n\n如果是每个物品可以选多次，那就是完全背包问题。\n\n背包问题的dp数组定义：dp\\[j]表示达到重量为j的背包最大可放入的价值。\n\n递推公式：dp\\[j] = max(dp\\[j], dp\\[j - weight\\[i]] + value\\[i])\n\n解释：不选，dp\\[j]，选，dp\\[j - weight\\[i]] + value\\[i]\n\n遍历方式：\n\n```cpp\nfor (int i = 0; i < weight.size(); i++) {  // 遍历物品\n\tfor (int j = bagweight; j >= weight[i]; j--) {  // 遍历重量\n\t\tdp[j] = max(dp[j], dp[j - weight[i]] + value[i]);\n\t}\n}\n```\n\n### 题416：分割等和子集\n\n将一个数组分成两部分，要求和相等\n\n思路：求和，除以2，得到背包的大小target，数组本身既是weight也是value。满足条件：dp\\[target] == target。\n\n### 题1049：最后一块石头的重量2\n\n题目核心问题在于任意石头，不是相邻石头，故需要动态规划。\n\n思路：两快石头相消，得到石头A-石头B的重量，推导到整个数组就是两个子数组相消得到的最小重量。\n\n如何得到最小重量？尽量让两个数组之和相等。这就回到上面的题416解法。\n\n### 题494：目标和\n\n回溯：选+，选-，直到pos遍历完， 检查是否等于target\n\n动态规划：求sum，再添加-，得到target，故公式（设x等于+号和）：x + (sum - x) = target，x = (sum + target) / 2，此时问题转化为：填满背包大小为x的组合有多少种。\n\ndp\\[i]定义：填满i大小的背包，有dp\\[i]种组合。\n\n递推公式：dp\\[j] += dp\\[j - nums\\[i]]，表示填满0大小背包组合数+填满1大小背包组合数+...\n\n### 题kama52：完全背包\n\n完全背包和01背包的区别是，完全背包可以重复地选择1件物品，而01不行。\n\n在实现上，为支持1件物品被重复选择，只需要将内层背包循环按从小到大遍历即可。\n\n```cpp\nfor (int i = 0; i < weight.size(); i++) {  // 遍历物品\n\tfor (int j = weight[i]; j <= bagsize; j++) {  // 遍历重量，从小到大遍历\n\t\tdp[j] = max(dp[j], dp[j - weight[i]] + value[i]);\n\t}\n}\n```\n\n### 题474：一和零\n\n字符串数组，每个字符串0和1的数量，本质就是当前字符串元素的重量，0和1的数量分别不能超过m和n，那么m和n即为背包容量。所以这道题本质是背包问题。\n\ndp\\[i]\\[j]定义：容量为i的背包A和容量为j的背包B所能承载的最多物品数。\n\n### 题518：零钱兑换2\n\n硬币可重复pick，完全背包问题。\n\n**求组合数，而不是求最大价值。组合数**意味着没有顺序之分。\n\ndp\\[j]定义：背包容量为i时的组合数\n\n递推公式：dp\\[j] += dp\\[j - coins\\[i]]，表示：背包容量为j的组合数 = 不加coins\\[i]当前背包容量为j的组合数 + 新增coins\\[i]从j-coins\\[i]继承的组合数\n\n该递推公式要求dp\\[0] = 1，不能为0，否则后续的推导全部为0。\n\n| 背包dp槽位            | **0** | **1** | **2**                       | **3** | **4**                                | **5** |\n| :---------------- | :---- | :---- | :-------------------------- | :---- | :----------------------------------- | :---- |\n| coins\\[0] = 1填充背包 | 1     | 1     | 1                           | 1     | 1                                    | 1     |\n| coins\\[1] = 2填充背包 |       |       | 2=dp\\[0]+dp\\[2]，更新到当前dp\\[2] | 2     | 3=dp\\[4]+dp\\[2]，dp\\[2]前面刚更新为2，所以这里为3 | 3     |\n| coins\\[2] = 5填充背包 |       |       |                             |       |                                      | 4     |\n\n### 题377：组合总和4\n\n**本题求排列数，有顺序之分。**\n\n排列数和组合数在for循环有差别：\n\n*   **如果求组合数就是外层for循环遍历物品，内层for遍历背包**。\n*   **如果求排列数就是外层for遍历背包，内层for循环遍历物品**。\n\n原因：如果把遍历nums（物品）放在外循环，遍历target的作为内循环的话，举一个例子：计算dp\\[4]的时候，结果集只有 {1,3} 这样的集合，不会有{3,1}这样的集合，因为nums遍历放在外层，3只能出现在1后面！\n\n### 题kama57：爬楼梯\n\n爬楼梯变式，可以选择小于等于m阶步长，爬n阶大小楼梯。\n\n背包：n，物品：\\[1\\~m]\n\n递推公式：dp\\[i] += dp\\[i - j]，其中i是背包，j是物品\n\n因为有序，所以背包在外，物品在内。\n\n### 题322：零钱兑换\n\n这道题求的是最小硬币数，前面求的是组合数。\n\n二者区别在于递推公式的变化。最小硬币数：dp\\[j] = min(dp\\[j], dp\\[j - nums\\[i]] + 1)\n\n其他注意点：因为是min，所以dp数组初始化为INT\\_MAX\n\n在遍历过程中，需规避INT\\_MAX + 1情况，否则溢出。\n\n递推公式的源头是dp\\[0]，应初始化为0。\n\n### 题279：完全平方数\n\n思路和上题一致，求最小数量。只是元素上做了一点区别，不是直接给的，而是要自己做下平方。\n\n### 题139：单词拆分\n\n思路：单词数组中的单词可重复抽取 ==> 完全背包\n\n背包：目标字符串。\n\ndp\\[j]定义：长度为j的字符串背包是否能被单词数组组合得到。\n\n有序：遍历背包长度，遍历单词长度\n\n递推公式：如果单词长度的子串“xxxxx\\[子串]”在单词数组里，且dp\\[xxxxx.len] == true, 则dp\\[j] = true。\n\n初始值：dp\\[0] = true，其他为false\n\n### 题kama56：多重背包\n\n01背包限定了物品数量为1，完全背包不限定物品数量，多重背包介于二者之间，限定了物品数量，但不一定为1。\n\n多重背包符合现实中的逻辑，物品资源是有限个的。\n\n多重背包可以退化为01背包，只需要将多个物品A展开为每一个物品A。\n\n所以整体代码框架是不变的，和01背包类似，唯一需要处理的是新增一个内部的for循环：\n\n```cpp\n#include <iostream>\n#include <vector>\nusing namespace std;\n\n\nint main() {\n    int bagweight, n;\n    cin >> bagweight >> n;\n    \n    vector<int> weights(n, 0);\n    vector<int> values(n, 0);\n    vector<int> nums(n, 0);\n    for (int i = 0; i < n; i++) cin >> weights[i];\n    for (int i = 0; i < n; i++) cin >> values[i];\n    for (int i = 0; i < n; i++) cin >> nums[i];\n    \n    vector<int> dp(bagweight + 1, 0);\n    for (int i = 0; i < n; i++) {\n        for (int j = bagweight; j >= weights[i]; j--) {\n            // 这里要根据物品数量做处理\n            for (int k = 1, k < nums[i]; k++) {\n                if (j - k * weights[i] < 0) continue;\n                dp[j] = max(dp[j], dp[j - k * weights[i]] + k * values[i]);\n            }\n        }\n    }\n    return dp[bagweight];\n}\n```\n\n### 题198：打家劫舍\n\n错误思路：维护一个前面有没有偷的标记，这种思路会导致起始点的偷or不偷不好处理。\n\n正确思路：偷or不偷，状态依赖。\n\ndp\\[i]定义：遍历到第i个物品时的最大金额。\n\n递推公式：dp\\[j] = max(dp\\[i - 2] + nums\\[i], dp\\[i - 1])，这里就表示了前1个偷or不偷的关系\n\n初始化：dp\\[0] = nums\\[0]，dp\\[1] = max(nums\\[0], nums\\[1])\n\n循环：只要1层循环即可，遍历物品。\n","slug":"leetcode刷题随记","published":1,"updated":"2024-08-31T14:46:11.772Z","_id":"cm0i8sb9k0000cfp77v8c6458","comments":1,"layout":"post","photos":[],"content":"<p>本文旨在记录刷题过程中的思考，以及在给定刷题路径上做一些变式补充。</p>\n<p>刷题路径遵循：<a href=\"https://github.com/youngyangyang04/leetcode-master?tab=readme-ov-file\">https://github.com/youngyangyang04/leetcode-master?tab=readme-ov-file</a></p>\n<span id=\"more\"></span>\n\n<h2 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h2><h3 id=\"题704：二分查找\"><a href=\"#题704：二分查找\" class=\"headerlink\" title=\"题704：二分查找\"></a>题704：二分查找</h3><p>二分查找重点关注边界取舍，这里讨论left、right为闭区间的情况：</p>\n<ul>\n<li>外层循环为left &lt;&#x3D; right，具有等号</li>\n<li>里层赋值left &#x3D; mid + 1 或 right &#x3D; mid - 1，偏移1个单位</li>\n</ul>\n<p>为什么？</p>\n<p>外层循环取等号由内层赋值控制推导，存在加1减1时left &#x3D;&#x3D; right的可能，且所指向的值未曾遍历。</p>\n<p>里层赋值偏移1个单位原因是，前一次的[mid]值判断已经在条件中得到结论，故下一个[mid]无需再遍历。</p>\n<blockquote>\n<p>[数值]符号含义：指取该数值所指向的值。</p>\n</blockquote>\n<p><strong>变式题34：找边界</strong></p>\n<p>找出指定数值的起始位置和终止位置。仍然是二分查找，唯一要处理的点是：</p>\n<p>在匹配到指定数值后，不要停：</p>\n<ul>\n<li>起始位置对应：右边界 - 1</li>\n<li>终止位置对应：左边界 + 1</li>\n<li>暂存当前的位置</li>\n</ul>\n<p>最终循环会因为left &lt;&#x3D; right不满足打破。</p>\n<p><strong>变式题162：找峰值</strong></p>\n<p>题目要求只要找到任意一个峰值即可，为此可以使用二分。</p>\n<p>假设-1，n均为负无穷，所以原始数组就变为[-infinity, 1, 2, 1, -infinity]</p>\n<p>基于此取查找就可找到答案。</p>\n<p>因为数组不支持-1和n索引，所以可以定义一个匿名函数支持它，这里也利用了cpp中的pair&lt;int,int&gt;特性。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">auto</span> get = [&amp;](<span class=\"type\">int</span> i) -&gt; pair&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt; &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (i == <span class=\"number\">-1</span> || i == n) &#123;  <span class=\"comment\">// 如果是-1或n，pair第一个值比较起作用，一定是最小的</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;<span class=\"number\">0</span>, <span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;<span class=\"number\">1</span>, nums[i]&#125;;  <span class=\"comment\">// pair的第二值起作用，依据具体nums[i]</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">get</span>(idx) &gt; <span class=\"built_in\">get</span>(idx + <span class=\"number\">1</span>) &amp;&amp; <span class=\"built_in\">get</span>(idx) &gt; <span class=\"built_in\">get</span>(idx - <span class=\"number\">1</span>)  <span class=\"comment\">// 这就是峰值</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"题27：O1空间内处理数组删除\"><a href=\"#题27：O1空间内处理数组删除\" class=\"headerlink\" title=\"题27：O1空间内处理数组删除\"></a>题27：O1空间内处理数组删除</h3><p>方式1：快慢指针，快指针负责搜索不相等元素，慢指针负责等候快指针给的值进行存储。</p>\n<p>方式2：c++可以使用iterator，在<code>*it</code>匹配到相等元素后，通过erase删除v.erase(it)，并保证it不向下走，因为这里erase的实现上会讲数组后续元素都向前shift 1个单位，所以此时的it仍然指向下一个新值。</p>\n<p>当然，方式2比方式1慢很多（1ms vs 5ms），时间复杂度后者为O(n2)。</p>\n<h3 id=\"题977：On时间内平方数组\"><a href=\"#题977：On时间内平方数组\" class=\"headerlink\" title=\"题977：On时间内平方数组\"></a>题977：On时间内平方数组</h3><p>双指针解法，利用原有数组的有序特性 + 平方后的排序是两端大中间小的特性，推导出两个指针从两头开始，往中间遍历。</p>\n<h3 id=\"题209：最小连续子数组\"><a href=\"#题209：最小连续子数组\" class=\"headerlink\" title=\"题209：最小连续子数组\"></a>题209：最小连续子数组</h3><p>使用滑动窗口，本质是双指针，维护一个双指针区间内部的sum，一边加一边卸，返回区间长度。</p>\n<p><strong>变式题121：股票价值最大化</strong></p>\n<p>思路：题目要求只能1次买入卖出，所以可以设想：每一天，都想一个问题，我在历史最低点买入，今天卖出，会盈利多少（也就是保存最小价格，和当天价格相减，取max，得到结果）</p>\n<p><strong>变式题122：支持多次买入卖出</strong></p>\n<p>思路：动态规划，二维数组做状态记录</p>\n<blockquote>\n<p>其实只用2个数值做记录也够用，因为我们总是只回看前一个数。</p>\n</blockquote>\n<p>一列是未持股时手上的现金，一列是持股后手上的现金</p>\n<p>下一列的值等于：</p>\n<ul>\n<li>今日未持股现金 &#x3D; 昨日未持股现金，昨日持股后今日卖掉的现金 取最大&#x20;</li>\n<li>今日持股现金 &#x3D; 昨日持股现金，昨日未持股现金买今日股票后的现金 取最大</li>\n</ul>\n<p>最后取未持股时的现金返回。</p>\n<h3 id=\"题59：螺旋矩阵\"><a href=\"#题59：螺旋矩阵\" class=\"headerlink\" title=\"题59：螺旋矩阵\"></a>题59：螺旋矩阵</h3><p>螺旋矩阵没什么算法，纯粹是边界处理，顺着方向写就行。</p>\n<p>right -&gt; down -&gt; left -&gt; up</p>\n<p>每转一圈，边长减1。</p>\n<h2 id=\"链表\"><a href=\"#链表\" class=\"headerlink\" title=\"链表\"></a>链表</h2><h3 id=\"题203：移除链表元素\"><a href=\"#题203：移除链表元素\" class=\"headerlink\" title=\"题203：移除链表元素\"></a>题203：移除链表元素</h3><p>两个基本注意点：</p>\n<ul>\n<li>要创建一个dummy节点，作为起始遍历辅助</li>\n<li>结束时要返回dummy.next，而不是head，因为head有可能已被删除</li>\n</ul>\n<h3 id=\"题707：设计链表\"><a href=\"#题707：设计链表\" class=\"headerlink\" title=\"题707：设计链表\"></a>题707：设计链表</h3><p>核心方法：addAtIndex，deleteAtIndex，get</p>\n<p>关键点是要初始化一个dummy节点，从该节点开始处理链表的新增和删除。其本质和上述移除链表元素是一样的，必须得有个假的头节点来处理index为0的情况。</p>\n<h3 id=\"题206：翻转链表\"><a href=\"#题206：翻转链表\" class=\"headerlink\" title=\"题206：翻转链表\"></a>题206：翻转链表</h3><p>观察翻转前后的变化，只有相邻节点的next箭头变了，因此只需要prev、current两个变量：</p>\n<ul>\n<li>先暂存next，翻转current-&gt;prev</li>\n<li>然后prev、current往下平移1个单位</li>\n</ul>\n<p>最后prev就是头了。</p>\n<p>当然这道题的另一种思路是拷贝到新链表，弊端是占用了额外内存空间。</p>\n<h3 id=\"题24：两两节点交换\"><a href=\"#题24：两两节点交换\" class=\"headerlink\" title=\"题24：两两节点交换\"></a>题24：两两节点交换</h3><p><img src=\"https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg\"></p>\n<p>最小可重复交换操作为：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 三个数一组</span></span><br><span class=\"line\">[dummy 1 2] 3 4</span><br><span class=\"line\">[dummy 2 1] 3 4</span><br><span class=\"line\"><span class=\"comment\"># 指针偏移2个单位</span></span><br><span class=\"line\">dummy 2 [1 3 4]</span><br><span class=\"line\">dummy 2 [1 4 3]</span><br><span class=\"line\"><span class=\"comment\"># 再偏移2个单位</span></span><br><span class=\"line\">dummy 2 1 4 [3 null null]  <span class=\"comment\"># 无需交换</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 不满两组的情况</span></span><br><span class=\"line\">[dummy 1 2] 3</span><br><span class=\"line\">[dummy 2 1] 3</span><br><span class=\"line\">dummy 2 [1 3 null]  <span class=\"comment\"># 无需交换</span></span><br></pre></td></tr></table></figure>\n\n<p>所以截止条件为：只要有null，就无需再操作。</p>\n<p>这种最小可重复操作怎么发现的？</p>\n<p>观察一次有多少元素需要参与运算，上述1 2参与了，2的下一个元素3属于下一次运算的范畴，可以不处理。下一次运算时，3 4交换，此时前面的1箭头也要变，所以参与运算的就有3个。为了抽象为通用操作，第一次运算1 2时，在其前补充dummy元素。</p>\n<h3 id=\"题19：删除链表的倒数第N个节点\"><a href=\"#题19：删除链表的倒数第N个节点\" class=\"headerlink\" title=\"题19：删除链表的倒数第N个节点\"></a>题19：删除链表的倒数第N个节点</h3><p>要求一次遍历计算出来：</p>\n<ul>\n<li><p>链表长度怎么获取？</p>\n<ul>\n<li>只能遍历完。</li>\n</ul>\n</li>\n<li><p>遍历完后推算出倒数第n的位置，怎么返回获取前后节点？</p>\n<ul>\n<li>遍历时有意识的保存</li>\n</ul>\n</li>\n</ul>\n<p>如何实现有意识的保存？思路：构造2个有距离的指针，同时shift遍历，距离就是n。</p>\n<h3 id=\"题02-07：链表相交\"><a href=\"#题02-07：链表相交\" class=\"headerlink\" title=\"题02.07：链表相交\"></a>题02.07：链表相交</h3><p>思路1：普通解法</p>\n<ul>\n<li>分别遍历每条链表，计算长度，得到长度之差</li>\n<li>挑长链表磨平差值</li>\n<li>此时两条链表并排，开始遍历比较，第一个出现相等的元素就是了</li>\n</ul>\n<p>思路2：数学算法</p>\n<p>链表A不相交部分长度a，链表A相交部分长度c</p>\n<p>链表A不相交部分长度a，链表A相交部分长度c</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a + c = m</span><br><span class=\"line\">b + c = n</span><br><span class=\"line\">a + c + b = b + c + a</span><br></pre></td></tr></table></figure>\n\n<p>可以得到，不相交部分长度走完，一定是交点。</p>\n<h3 id=\"题142：环形链表\"><a href=\"#题142：环形链表\" class=\"headerlink\" title=\"题142：环形链表\"></a>题142：环形链表</h3><p>思路1：将所有被遍历的节点压栈set集合，如果有重复节点，set长度将不会增长。</p>\n<ul>\n<li>缺点：需要额外内存空间存储节点地址</li>\n</ul>\n<p>思路2：设置快慢指针，快指针1次2步，慢指针1次1步，如果快指针追上慢指针，则满足条件。</p>\n<p>一定能相遇吗？</p>\n<ul>\n<li>一定能的，即便快指针在固定节点循环，慢指针属于遍历，一定能踩到。</li>\n</ul>\n<p>相遇的点一定是交点吗？</p>\n<ul>\n<li>不是，但可以通过以下公式推导：假设a是环外长度，b是环内长度，n表示在环内转了n圈，f是快指针走的里程，s是慢指针走的里程</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 已知快指针比慢指针多走一倍里程</span></span><br><span class=\"line\">f = 2s</span><br><span class=\"line\"><span class=\"comment\"># 已知快慢相遇时，在相遇节点开始走n圈 + s就是快指针的里程</span></span><br><span class=\"line\">f = s + nb</span><br><span class=\"line\"><span class=\"comment\"># 推导得到</span></span><br><span class=\"line\">s = nb</span><br><span class=\"line\"><span class=\"comment\"># 已知从head走到入口节点需要：</span></span><br><span class=\"line\">a + nb</span><br><span class=\"line\"><span class=\"comment\"># 慢指针已经走了nb步，还需再走a步，a步怎么来？和head开始的指针一起走，直至相遇，得到结论。</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"hash表\"><a href=\"#hash表\" class=\"headerlink\" title=\"hash表\"></a>hash表</h2><h3 id=\"题242：有效的字母异位词\"><a href=\"#题242：有效的字母异位词\" class=\"headerlink\" title=\"题242：有效的字母异位词\"></a>题242：有效的字母异位词</h3><p>思路1：最直接的方法是定义一个hashmap，第一轮迭代填充charMap，第二轮迭代减少charMap计数，如果出现-1的则return false。</p>\n<p>思路2：定义1个具有26长度的数组，每个位置依据字符串的字符位置进行++–，最后check一遍得到结果。</p>\n<h3 id=\"题1002：查找共用字符\"><a href=\"#题1002：查找共用字符\" class=\"headerlink\" title=\"题1002：查找共用字符\"></a>题1002：查找共用字符</h3><p>这里有个坑是，不是说一个字母统计一次就行，而是如相同字母在多个words里分别重复出现了，那就都得输出出来。</p>\n<p>思路：一个当前word的freq数组，一个全局words的最小freq数组，分别统计每个词的字母出现频率。</p>\n<p>全局word在的foreach每个词时，总是取当前word每个槽位的最小值。</p>\n<h3 id=\"题349：两个数组的交集\"><a href=\"#题349：两个数组的交集\" class=\"headerlink\" title=\"题349：两个数组的交集\"></a>题349：两个数组的交集</h3><p>这道题跟上面一道题有点类似，这道题要求一个字母只统计1次，并且只有两个数组之间的比较，所以可以认为是上一道题的简单版本。</p>\n<p>思路：set存储第一个数组内容，set.count(第二个数组中的每一个元素)，如果存在，则return</p>\n<h3 id=\"题202：快乐数\"><a href=\"#题202：快乐数\" class=\"headerlink\" title=\"题202：快乐数\"></a>题202：快乐数</h3><p>首先理解题意：</p>\n<ul>\n<li>拆解的数的每一位做平方</li>\n<li>希望得到1</li>\n<li>可能永远都得不到</li>\n<li>得不到的原因是无限循环（在某个圈内循环转）</li>\n</ul>\n<p>解题关键：找到循环的入口</p>\n<p>具体思路：记录历史算数，如果重复或为1，则退出</p>\n<h3 id=\"题1：两数之和\"><a href=\"#题1：两数之和\" class=\"headerlink\" title=\"题1：两数之和\"></a>题1：两数之和</h3><p>思路：排序，二分，要寻找的对象是：find(和 - 当前数值)。</p>\n<p>寻找对象的方法还可以是hashset，即hashset + find，这里要注意，find到值不能是自己，并且还要有数组下标返回，所以通过hashmap更合适。</p>\n<h3 id=\"题454：四数相加\"><a href=\"#题454：四数相加\" class=\"headerlink\" title=\"题454：四数相加\"></a>题454：四数相加</h3><p>四个数组，长度一致；每个数组挑1个数，和其他数相加；求和要等于0；返回有多少种可能。</p>\n<p>要把所有组合都遍历一遍，n的4次方。减少复杂度方法是，分为2组，每组n的2次方，从等于0改为ab组 &#x3D; -cd组。ab组的求和存入hash表，值为等于该和的组数；cd组查询，这样就得到最终结果。</p>\n<h3 id=\"题383：赎金信\"><a href=\"#题383：赎金信\" class=\"headerlink\" title=\"题383：赎金信\"></a>题383：赎金信</h3><p>数组2中的字符作为候选，数组1消费。</p>\n<p>给1个hashmap对候选计数，数组1遍历时消费，如果找不到或value出现小于0的情况，则为false。</p>\n<h3 id=\"题15：三数之和\"><a href=\"#题15：三数之和\" class=\"headerlink\" title=\"题15：三数之和\"></a>题15：三数之和</h3><p>思路1：选target，剩下的元素求“两数之和”，因为本题要求返回所有元组，而两数之和给了1个只有1个元组答案的约束，所以，本题最后还得有一层去重处理。</p>\n<p>思路2：组合问题，从数组中选3，求和。</p>\n<p>组合问题是无序的，相比有序的数组还是差了点效率。所以</p>\n<p>思路3：这里可以基于排序后的数组，使用双指针解决</p>\n<ul>\n<li>遍历数组，从first &#x3D; 0，选target</li>\n<li>定义left &#x3D; first + 1、right &#x3D;&#x3D; n - 1，双指针两方向往中间靠近，找所有解</li>\n</ul>\n<p>second和third就是双指针。</p>\n<h3 id=\"题18：四数之和\"><a href=\"#题18：四数之和\" class=\"headerlink\" title=\"题18：四数之和\"></a>题18：四数之和</h3><p>本质是在三数之和上套一层循环，怎么理解？</p>\n<ul>\n<li>遍历数组，从first &#x3D; 0，选target</li>\n<li>遍历数组，从second &#x3D; first + 1</li>\n<li>定义left &#x3D; second + 1、right &#x3D; n - 1，双指针两方向往中间靠近，找所有解</li>\n</ul>\n<p>相关剪枝细节（其实就是哪些可以跳过不做的）这里不展开。</p>\n<h2 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h2><h3 id=\"题344：反转字符串\"><a href=\"#题344：反转字符串\" class=\"headerlink\" title=\"题344：反转字符串\"></a>题344：反转字符串</h3><p>这道题要求原地反转。</p>\n<p>思路：双指针从两端到中间依次反转字符对，截止条件：指针相遇或错过。</p>\n<p><strong>变式题541：反转字符串2</strong></p>\n<p>相比上一道字符串增加了步长，其余逻辑一致。</p>\n<h3 id=\"题kama54：替换数字\"><a href=\"#题kama54：替换数字\" class=\"headerlink\" title=\"题kama54：替换数字\"></a>题kama54：替换数字</h3><p>这道题也是要做到原地变更字符串。利用C++里的s.resize方法。</p>\n<p>核心思路是：预留卡位，从后往前填。</p>\n<h3 id=\"题151：反转字符串中的单词\"><a href=\"#题151：反转字符串中的单词\" class=\"headerlink\" title=\"题151：反转字符串中的单词\"></a>题151：反转字符串中的单词</h3><p>这题考察对string api的熟悉程度。</p>\n<p>更高要求：原地修改字符串，大致步骤：</p>\n<ul>\n<li>字符串reverse</li>\n<li>删除多余空格</li>\n<li>单词reverse</li>\n</ul>\n<h3 id=\"题kama55：右旋字符串\"><a href=\"#题kama55：右旋字符串\" class=\"headerlink\" title=\"题kama55：右旋字符串\"></a>题kama55：右旋字符串</h3><p>思路上跟上道题类似，右旋只是表象，本质还是2个操作：</p>\n<ul>\n<li>字符串reverse</li>\n<li>区间字符串reverse（等同于单词reverse）</li>\n</ul>\n<h3 id=\"题459：重复的子字符串\"><a href=\"#题459：重复的子字符串\" class=\"headerlink\" title=\"题459：重复的子字符串\"></a>题459：重复的子字符串</h3><p>特殊例子：ababdababd、acdfdacdfd，这也是重复的</p>\n<p>思路1：比较朴素的解法</p>\n<ul>\n<li>遍历各种长度（满足size % 长度 &#x3D;&#x3D; 0）的子串</li>\n<li>始终满足是前一个子串的前缀：s[j] &#x3D;&#x3D; s[j - 1]，j++，j &lt; size</li>\n</ul>\n<p>思路2：特殊性质</p>\n<ul>\n<li>如果是重复子串，则abab + abab，去掉头尾， &#x3D; bababa 包含ab</li>\n<li>如果不是，则absab + absab &#x3D; bsababsa 不包含 absab</li>\n</ul>\n<h2 id=\"双指针\"><a href=\"#双指针\" class=\"headerlink\" title=\"双指针\"></a>双指针</h2><h3 id=\"题27：移除元素\"><a href=\"#题27：移除元素\" class=\"headerlink\" title=\"题27：移除元素\"></a>题27：移除元素</h3><p>原地操作移除元素，可使用快慢指针，慢指针指向当前要赋值的位置，快指针指向非目标元素的位置，如此迭代。</p>\n<h2 id=\"栈与队列\"><a href=\"#栈与队列\" class=\"headerlink\" title=\"栈与队列\"></a>栈与队列</h2><h3 id=\"题232：用栈实现队列\"><a href=\"#题232：用栈实现队列\" class=\"headerlink\" title=\"题232：用栈实现队列\"></a>题232：用栈实现队列</h3><p>队列FIFO，栈LIFO，用栈实现队列核心要解决如何将栈头元素弹出问题。</p>\n<p>让第一次进栈的元素保持在栈尾？双栈思路。</p>\n<p>在pop&#x2F;top时操作，将当前所有元素都转移到新栈上。</p>\n<p>注意这里有个tracky，新栈总是在为空时才从旧栈中补充元素。</p>\n<h3 id=\"题225：用队列实现栈\"><a href=\"#题225：用队列实现栈\" class=\"headerlink\" title=\"题225：用队列实现栈\"></a>题225：用队列实现栈</h3><p>push时操作，将新push进队列的元素置于front位置，可通过循环将其他元素pop再push的方式。</p>\n<h3 id=\"题20：有效的括号\"><a href=\"#题20：有效的括号\" class=\"headerlink\" title=\"题20：有效的括号\"></a>题20：有效的括号</h3><p>校验括号的方法：左括号进栈，右括号遇到匹配的左括号，则左括号弹栈，否则右括号进栈。</p>\n<h3 id=\"题1047：删除字符串中的所以相邻重复项\"><a href=\"#题1047：删除字符串中的所以相邻重复项\" class=\"headerlink\" title=\"题1047：删除字符串中的所以相邻重复项\"></a>题1047：删除字符串中的所以相邻重复项</h3><p>和上述题一样，相同的消掉，不同的入栈，最后反转下栈内元素输出即可。</p>\n<h3 id=\"题150：逆波兰表达式求值\"><a href=\"#题150：逆波兰表达式求值\" class=\"headerlink\" title=\"题150：逆波兰表达式求值\"></a>题150：逆波兰表达式求值</h3><p>思路：如果时数字，压栈，如果是符号，弹出两个数字，计算，再压栈。</p>\n<h3 id=\"题239：滑动窗口最大值\"><a href=\"#题239：滑动窗口最大值\" class=\"headerlink\" title=\"题239：滑动窗口最大值\"></a>题239：滑动窗口最大值</h3><p>看着简单，操作起来有点难度。</p>\n<p>思路：优先队列，它能解决区间最大值的问题。但还要考虑：</p>\n<ul>\n<li>如何删除区间的第一个值问题</li>\n</ul>\n<p>这里就有一个位置信息需要在优先队列里保留，方法：</p>\n<ul>\n<li>设置队列节点为&lt;nums[i], [i]&gt;的pair对</li>\n</ul>\n<p>那么必须要始终确保优先队列的长度为窗口大小吗？不用。其实只要确保当前队列里的top仍然在窗口内，那么top就不需要摘除，保留即可，其他比top小的窗口外元素不影响。</p>\n<h3 id=\"题347：前k个高频元素\"><a href=\"#题347：前k个高频元素\" class=\"headerlink\" title=\"题347：前k个高频元素\"></a>题347：前k个高频元素</h3><p>前k个 –&gt; 优先队列，返回高频元素，所以队列元素设计为&lt;频率,元素&gt;pair，为了得到这种pair，还需要使用map收集。</p>\n<p>这块还需要重写优先队列的排序方式，只用频率排序。</p>\n<h2 id=\"二叉树\"><a href=\"#二叉树\" class=\"headerlink\" title=\"二叉树\"></a>二叉树</h2><h3 id=\"题144-145-94：二叉树遍历\"><a href=\"#题144-145-94：二叉树遍历\" class=\"headerlink\" title=\"题144&#x2F;145&#x2F;94：二叉树遍历\"></a>题144&#x2F;145&#x2F;94：二叉树遍历</h3><p>前序：中左右</p>\n<p>中序：左中右</p>\n<p>后序：左右中</p>\n<p>可以看出，前后是基于树的高来讲，root在树顶点，那么它就是前，树的叶子节点就是后。</p>\n<h3 id=\"题102：层序遍历\"><a href=\"#题102：层序遍历\" class=\"headerlink\" title=\"题102：层序遍历\"></a>题102：层序遍历</h3><p>从上到下输出，前序</p>\n<p>遍历是深度的，所以还需要辅助信息，也就是层高</p>\n<p>层高对应到数组索引</p>\n<p>所以思路1：深度优先搜索</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">levelOrder</span>(TreeNode* root) &#123;</span><br><span class=\"line\">        vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; res;</span><br><span class=\"line\">        <span class=\"built_in\">traversal</span>(root, <span class=\"number\">0</span>, res);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">traversal</span><span class=\"params\">(TreeNode* node, <span class=\"type\">int</span> level, vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt;&amp; res)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (res.<span class=\"built_in\">size</span>() &lt;= level) &#123;</span><br><span class=\"line\">            vector&lt;<span class=\"type\">int</span>&gt; ele;</span><br><span class=\"line\">            res.<span class=\"built_in\">push_back</span>(ele);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        res[level].<span class=\"built_in\">push_back</span>(node-&gt;val);  <span class=\"comment\">// 深度遍历到对应层级时加入对应的数组内</span></span><br><span class=\"line\">        <span class=\"built_in\">traversal</span>(node-&gt;left, level + <span class=\"number\">1</span>, res);</span><br><span class=\"line\">        <span class=\"built_in\">traversal</span>(node-&gt;right, level + <span class=\"number\">1</span>, res);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>思路2：广度优先搜索的层序版</p>\n<p>通过辅助的队列来实现。队列的职责是保存每一层的节点：</p>\n<ul>\n<li>检查队列是否为空</li>\n<li><strong>全部遍历</strong>，依次弹出，取这些节点的左右节点重新入队列</li>\n<li>如此循环</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">levelOrder</span>(TreeNode* root) &#123;</span><br><span class=\"line\">        vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; res;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        queue&lt;TreeNode*&gt; q;</span><br><span class=\"line\">        q.<span class=\"built_in\">push</span>(root);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!q.<span class=\"built_in\">empty</span>()) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> levelsize = q.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">            res.<span class=\"built_in\">push_back</span>(<span class=\"built_in\">vector</span>&lt;<span class=\"type\">int</span>&gt;());</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; levelsize; i++) &#123;  <span class=\"comment\">// 广度优先搜索不需要这一层</span></span><br><span class=\"line\">                TreeNode* cur = q.<span class=\"built_in\">front</span>();</span><br><span class=\"line\">                q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">                res.<span class=\"built_in\">back</span>().<span class=\"built_in\">push_back</span>(cur-&gt;val);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (cur-&gt;left != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">                    q.<span class=\"built_in\">push</span>(cur-&gt;left);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (cur-&gt;right != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">                    q.<span class=\"built_in\">push</span>(cur-&gt;right);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>这里要注意一个细节，即层序遍历不是广度优先搜索。广度优先是1个节点1个节点逐个往下走，它没有层的信息，而层序遍历是将层的信息显性化出来。</p>\n</blockquote>\n<p><strong>变式题107：要求返回从底向上的层序遍历</strong></p>\n<p>思路：基于常规层序遍历将res翻转下。</p>\n<p>有其他思路吗？没有，官方题解本质仍然是翻转，只是在while循环中翻转和循环完翻转的问题。</p>\n<p><strong>变式题199：二叉树的右视图</strong></p>\n<p>思路1：层序，保留每一层的最优节点值。</p>\n<p>思路2：层序或dfs，在最后res中取back值。</p>\n<p><strong>变式题637：二叉树的层平均值</strong></p>\n<p>同样的做法，层序遍历时求平均。</p>\n<p><strong>变式题429：N叉树的层序遍历</strong></p>\n<p>只需要改造left、right为for children即可。</p>\n<p><strong>变式题515：二叉树的层最大值</strong></p>\n<p>同样的做法，层序遍历求最大。</p>\n<p><strong>变式题116：填充每个节点的下一个右侧节点</strong></p>\n<p>层序，在遍历时做好前后节点的next关联。</p>\n<p><strong>变式题104：二叉树的最大深度</strong></p>\n<p>思路1：层序，为层计数。</p>\n<p>思路2：深度DFS，可以不用辅助函数。</p>\n<p><strong>变式题559：N叉树的最大深度</strong></p>\n<p>思路类似，深度遍历，每下钻一层加1。</p>\n<p><strong>变式题111：二叉树的最小深度</strong></p>\n<p>思路：层序，当left、right都为空时直接返回。</p>\n<h3 id=\"题226：翻转二叉树\"><a href=\"#题226：翻转二叉树\" class=\"headerlink\" title=\"题226：翻转二叉树\"></a>题226：翻转二叉树</h3><p>思路：深度遍历，无需辅助函数，直接翻转（这里可以选择前序，也可以选择后序）。</p>\n<h3 id=\"题101：对称二叉树\"><a href=\"#题101：对称二叉树\" class=\"headerlink\" title=\"题101：对称二叉树\"></a>题101：对称二叉树</h3><p>思路：层序遍历，弹出单层数组，判断是否对称。这里有个处理技巧，就是单层元素不按从左到右加入队列，而是两端对称加入；每次循环弹出2个节点进行比较。</p>\n<h3 id=\"题222：完全二叉树的节点个数\"><a href=\"#题222：完全二叉树的节点个数\" class=\"headerlink\" title=\"题222：完全二叉树的节点个数\"></a>题222：完全二叉树的节点个数</h3><p>参考二叉树的最大深度解法，通过DFS来解。</p>\n<p>因为二叉树的性质，这里还有一种二分查找的解法，先算出有多少层，然后再二分叶子节点。</p>\n<h3 id=\"题110：平衡二叉树\"><a href=\"#题110：平衡二叉树\" class=\"headerlink\" title=\"题110：平衡二叉树\"></a>题110：平衡二叉树</h3><p>平衡的性质是左右子树的高相差小于等于1</p>\n<ul>\n<li>首先要能算出高</li>\n<li>其次是判断是否满足小于等于1的条件</li>\n</ul>\n<h3 id=\"题257：二叉树的所有路径\"><a href=\"#题257：二叉树的所有路径\" class=\"headerlink\" title=\"题257：二叉树的所有路径\"></a>题257：二叉树的所有路径</h3><p>深度优先搜索，本质也是使用回溯的方法，设计好输入、截止条件即可。</p>\n<h3 id=\"题513：找树左下角的值\"><a href=\"#题513：找树左下角的值\" class=\"headerlink\" title=\"题513：找树左下角的值\"></a>题513：找树左下角的值</h3><p>左下角，高度最大，最左</p>\n<p>深度遍历需要带上这两个状态，同时要带上answer（当前高度，当前值）</p>\n<p>如果新遍历的比当前高度高，则刷新answer。</p>\n<p>处理细节：是否为左节点的状态可以去掉，转为由height &gt; answer.curHeight代替，原因：height递增时的首次遍历的节点一定是左节点（通过由先遍历左子树再遍历右子树的方式控制）。</p>\n<h3 id=\"题112：路径之和\"><a href=\"#题112：路径之和\" class=\"headerlink\" title=\"题112：路径之和\"></a>题112：路径之和</h3><p>求路径和，判断是否等于目标值。</p>\n<p>路径和 &#x3D; DFS + sum累加，遇到叶子节点后截止。</p>\n<h3 id=\"题106：已知中后序，构造二叉树\"><a href=\"#题106：已知中后序，构造二叉树\" class=\"headerlink\" title=\"题106：已知中后序，构造二叉树\"></a>题106：已知中后序，构造二叉树</h3><p>特征：后序的最后1个元素总是根节点。</p>\n<p>步骤：</p>\n<ul>\n<li>后序数组倒序遍历，选取的元素拿到中序遍历中做边界，分出左右子树数组</li>\n<li>递归构造左子树数组</li>\n<li>递归构造右子树数组</li>\n<li>左右子树拼接到当前的根节点</li>\n</ul>\n<p>因为涉及元素到index的查询，所以，构造1个（元素，index）的map加快索引。</p>\n<h3 id=\"题654：最大二叉树\"><a href=\"#题654：最大二叉树\" class=\"headerlink\" title=\"题654：最大二叉树\"></a>题654：最大二叉树</h3><p>这道题跟题106类似，递归，选出根节点，构造左右子树，拼接到根节点即可。</p>\n<h3 id=\"题617：合并二叉树\"><a href=\"#题617：合并二叉树\" class=\"headerlink\" title=\"题617：合并二叉树\"></a>题617：合并二叉树</h3><p>合并二叉树的逻辑也是构造左右子树，拼接到根节点。</p>\n<h3 id=\"题700：二叉搜索树\"><a href=\"#题700：二叉搜索树\" class=\"headerlink\" title=\"题700：二叉搜索树\"></a>题700：二叉搜索树</h3><p>深度遍历即可，小于往左，大于往右。</p>\n<h3 id=\"题98：验证二叉搜索树\"><a href=\"#题98：验证二叉搜索树\" class=\"headerlink\" title=\"题98：验证二叉搜索树\"></a>题98：验证二叉搜索树</h3><p>需满足两条规则：</p>\n<ul>\n<li>当前节点比左节点大，比右节点小；</li>\n<li>当前节点要小于或大于整体子树的区间范围，比如[5,4,7,null,null,3,9]，3比4小，false</li>\n</ul>\n<blockquote>\n<p>搜索树有个特征：不存在两个节点的值重复。</p>\n</blockquote>\n<h3 id=\"题530：二叉搜索树的最小差值\"><a href=\"#题530：二叉搜索树的最小差值\" class=\"headerlink\" title=\"题530：二叉搜索树的最小差值\"></a>题530：二叉搜索树的最小差值</h3><p>注意题目要求是任意两节点，非相邻节点。但实际根据树的性质，最小值只会存在于<strong>中序遍历</strong>下相邻的两个节点（因为中序遍历将得到1个递增序列）。</p>\n<p>中序遍历需具有以下状态：前一个节点的值，当前的最小值。</p>\n<h3 id=\"题501：二叉搜索树的众数\"><a href=\"#题501：二叉搜索树的众数\" class=\"headerlink\" title=\"题501：二叉搜索树的众数\"></a>题501：二叉搜索树的众数</h3><p>这道题的二叉树定义为节点值可重复。</p>\n<p>仍然按中序遍历，因为是递增序列，所以在遍历时保存前一个节点值preval，该值的count，当前的最大count，以及当前的最大countVals（因为要返回具体的val值）</p>\n<p>官方解答对首次处理中序有一个比较晦涩的点：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> preval, <span class=\"type\">int</span> curCount, <span class=\"type\">int</span> maxCount</span><br><span class=\"line\"></span><br><span class=\"line\">dfs <span class=\"comment\">// 前序</span></span><br><span class=\"line\"><span class=\"comment\">// 中序，注意看这里省略了对preval未初始化情况的处理</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (node-&gt;val == preval) &#123;</span><br><span class=\"line\">  curCount++; </span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  curCount = <span class=\"number\">1</span>;</span><br><span class=\"line\">  preval = node-&gt;val;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>更直观的写法：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> preNode, <span class=\"type\">int</span> curCount, <span class=\"type\">int</span> maxCount</span><br><span class=\"line\">dfs <span class=\"comment\">// 前序</span></span><br><span class=\"line\"><span class=\"comment\">// 中序</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (preNode == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">  curCount = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (preNode-&gt;val == node-&gt;val) &#123;</span><br><span class=\"line\">  curCount++;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  curCount = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">preNode = node;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，直观的写法中，if elseif块内的处理是一致的，故官方解法直接将二者合并为1个，无论preval是什么。</p>\n<h3 id=\"题236：二叉树的最近公共祖先\"><a href=\"#题236：二叉树的最近公共祖先\" class=\"headerlink\" title=\"题236：二叉树的最近公共祖先\"></a>题236：二叉树的最近公共祖先</h3><p>最近公共祖先的特征：</p>\n<ul>\n<li>该祖先的下一个node-&gt;left和node-&gt;right必有一方不是祖先</li>\n</ul>\n<p>所以在搜索时，可以先探查左右子树，如果同时为空，则说明该节点不包含目标；如果同时不为空，则说明该节点就是二者的公共祖先；如果一方为空、一方不为空，为空的子树没有包含目标，往不为空的搜索。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">TreeNode* <span class=\"title\">lowestCommonAncestor</span><span class=\"params\">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span> || root == p || root == q) <span class=\"keyword\">return</span> root;</span><br><span class=\"line\"></span><br><span class=\"line\">        TreeNode* left = <span class=\"built_in\">lowestCommonAncestor</span>(root-&gt;left, p, q);</span><br><span class=\"line\">        TreeNode* right = <span class=\"built_in\">lowestCommonAncestor</span>(root-&gt;right, p, q);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (left == <span class=\"literal\">nullptr</span> &amp;&amp; right == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (left != <span class=\"literal\">nullptr</span> &amp;&amp; right != <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (left == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> right;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (right == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> left;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"题701：二叉树的插入操作\"><a href=\"#题701：二叉树的插入操作\" class=\"headerlink\" title=\"题701：二叉树的插入操作\"></a>题701：二叉树的插入操作</h3><p>思路：找到节点要插入的位置，挂上去，这种适合前序遍历。</p>\n<p>首先判断节点是否为null，是则构造一个当前val的节点返回；否则对left、right进行遍历，并对返回值重新挂载到root。</p>\n<h3 id=\"题450：二叉树的删除操作\"><a href=\"#题450：二叉树的删除操作\" class=\"headerlink\" title=\"题450：二叉树的删除操作\"></a>题450：二叉树的删除操作</h3><p>类似插入操作，同样是找到节点，然后执行删除：</p>\n<ul>\n<li>如果左右子树均为空，返回空</li>\n<li>如果左子树为空，返回右子树</li>\n<li>如果右子树为空，返回左子树</li>\n<li>如果都不为空，则找到右子树的最左节点，把当前左子树挂到这个节点上，然后返回右子树</li>\n</ul>\n<h3 id=\"题669：修剪二叉搜索树\"><a href=\"#题669：修剪二叉搜索树\" class=\"headerlink\" title=\"题669：修剪二叉搜索树\"></a>题669：修剪二叉搜索树</h3><p>区间描述要保留的节点，中序遍历，一路trim节点，trim规则：</p>\n<ul>\n<li>小于左边界的，trim左子树</li>\n<li>大于右边界的，trim右子树</li>\n<li>满足区间内的，左子树的trim结果挂到左节点，右子树的trim结果挂到右节点（整体结构上只会有边界节点会变化）</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">TreeNode* <span class=\"title\">trimBST</span><span class=\"params\">(TreeNode* root, <span class=\"type\">int</span> low, <span class=\"type\">int</span> high)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root-&gt;val &lt; low) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">trimBST</span>(root-&gt;right, low, high);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root-&gt;val &gt; high) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">trimBST</span>(root-&gt;left, low, high);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        root-&gt;left = <span class=\"built_in\">trimBST</span>(root-&gt;left, low, high);</span><br><span class=\"line\">        root-&gt;right = <span class=\"built_in\">trimBST</span>(root-&gt;right, low, high);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"题108：有序数组转平衡二叉树\"><a href=\"#题108：有序数组转平衡二叉树\" class=\"headerlink\" title=\"题108：有序数组转平衡二叉树\"></a>题108：有序数组转平衡二叉树</h3><p>二分查找，每个被发现的中间元素作为root节点，而二分本身能够确保树平衡。</p>\n<h3 id=\"题538：二叉树转换为累加树\"><a href=\"#题538：二叉树转换为累加树\" class=\"headerlink\" title=\"题538：二叉树转换为累加树\"></a>题538：二叉树转换为累加树</h3><p>二叉树转为递减数组，每次遍历累加前一个节点的值</p>\n<p>如果实现递减遍历？通过颠倒的中序遍历来做。</p>\n<p>遍历过程需要维护一个<a href=\"\">currentSum</a>值。</p>\n<h2 id=\"回溯\"><a href=\"#回溯\" class=\"headerlink\" title=\"回溯\"></a>回溯</h2><h3 id=\"题77：组合\"><a href=\"#题77：组合\" class=\"headerlink\" title=\"题77：组合\"></a>题77：组合</h3><p>这道题有两种写法，第一种是带有for循环的：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">combine</span>(<span class=\"type\">int</span> n, <span class=\"type\">int</span> k) &#123;</span><br><span class=\"line\">        vector&lt;<span class=\"type\">int</span>&gt; curVec;</span><br><span class=\"line\">        vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; res;</span><br><span class=\"line\">        <span class=\"built_in\">backtracking</span>(n, k, <span class=\"number\">1</span>, curVec, res);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">backtracking</span><span class=\"params\">(<span class=\"type\">int</span> n, <span class=\"type\">int</span> k, <span class=\"type\">int</span> start, vector&lt;<span class=\"type\">int</span>&gt;&amp; curVec, vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt;&amp; res)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (curVec.<span class=\"built_in\">size</span>() == k) &#123;</span><br><span class=\"line\">            res.<span class=\"built_in\">emplace_back</span>(curVec);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = start; i &lt;= n; i++) &#123;</span><br><span class=\"line\">            curVec.<span class=\"built_in\">push_back</span>(i);</span><br><span class=\"line\">            <span class=\"built_in\">backtracking</span>(n, k, i + <span class=\"number\">1</span>, curVec, res);</span><br><span class=\"line\">            curVec.<span class=\"built_in\">pop_back</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>第二种是不带for循环的：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">combine</span>(<span class=\"type\">int</span> n, <span class=\"type\">int</span> k) &#123;</span><br><span class=\"line\">        vector&lt;<span class=\"type\">int</span>&gt; curVec;</span><br><span class=\"line\">        vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; res;</span><br><span class=\"line\">        <span class=\"built_in\">backtracking</span>(n, k, <span class=\"number\">1</span>, curVec, res);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">backtracking</span><span class=\"params\">(<span class=\"type\">int</span> n, <span class=\"type\">int</span> k, <span class=\"type\">int</span> cur, vector&lt;<span class=\"type\">int</span>&gt;&amp; curVec, vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt;&amp; res)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (curVec.<span class=\"built_in\">size</span>() + n - cur + <span class=\"number\">1</span> &lt; k) &#123;  <span class=\"comment\">// 这里做了剪枝处理，表示如果当前数组长度+剩余待遍历区间长度小于k时，跳过不遍历，因为没必要</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (curVec.<span class=\"built_in\">size</span>() == k) &#123;</span><br><span class=\"line\">            res.<span class=\"built_in\">emplace_back</span>(curVec);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cur == n + <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        curVec.<span class=\"built_in\">push_back</span>(cur);</span><br><span class=\"line\">        <span class=\"built_in\">backtracking</span>(n, k, cur + <span class=\"number\">1</span>, curVec, res);</span><br><span class=\"line\">        curVec.<span class=\"built_in\">pop_back</span>();</span><br><span class=\"line\">        <span class=\"built_in\">backtracking</span>(n, k, cur + <span class=\"number\">1</span>, curVec, res);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>以上存在一个细节，在回收结果处，使用了emplace_back来copy数组</p>\n<p>其他方案有：</p>\n<ul>\n<li>入参不带&amp;，而使用copy：backtracking(int n, int k, int cur, vector&lt;int&gt; curVec, vector&lt;vector&lt;int&gt;&gt;&amp; res)</li>\n<li>入参带&amp;，在回收结果时，自行构造一个新vector拷贝curVec</li>\n</ul>\n<p>实验证明，上述两种都不高效，且第一种方案内存使用异常高，是最优方案的10倍。</p>\n<p><strong>变式题216：组合总和3</strong></p>\n<p>这道题同样求组合，加了1个约束，要求组合的总和要等于指定值。</p>\n<p>思路：遍历所有组合，维护当前总和值，如果等于指定值且组合的size等于指定size，则返回，否则回溯。</p>\n<p>剪枝细节：同上道题，vec长度+区间长度 &lt; 指定长度或者 vec长度大于指定长度的，无需遍历，直接返回。</p>\n<p><strong>变式题39：组合总和</strong></p>\n<p>这道题的约束为，不限制给定数组中的某个数被选择几次，找出所有能够求和等于target值的组合。</p>\n<p>类似题目：爬楼梯，可选的一步台阶范围类比这里给定的数组。</p>\n<p>解法（更适合不具有for循环的递归）</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">backtracking</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; candidates, <span class=\"type\">int</span> index, <span class=\"type\">int</span> target, vector&lt;<span class=\"type\">int</span>&gt;&amp; curVec, vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt;&amp; res)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index == candidates.<span class=\"built_in\">size</span>()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (target == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        res.<span class=\"built_in\">emplace_back</span>(curVec);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 跳过不使用candidates[index]</span></span><br><span class=\"line\">    <span class=\"built_in\">backtracking</span>(candidates, index + <span class=\"number\">1</span>, target, curVec, res);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 使用candicates[index]</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (target - candidates[index] &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        curVec.<span class=\"built_in\">emplace_back</span>(candidates[index]);</span><br><span class=\"line\">        <span class=\"built_in\">backtracking</span>(candidates, index, target - candidates[index], curVec, res);</span><br><span class=\"line\">        curVec.<span class=\"built_in\">pop_back</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>变式题40：组合总和2</strong></p>\n<p>这道题放宽了对给定数组的约束，允许数组内有元素重复，并且，结果要求不可重复，且每个元素只能被用一次。</p>\n<p>对于只能被用一次这条，正常组合解法已覆盖。</p>\n<p>对于结果要求不可重复这条，需要做两个步骤：</p>\n<ul>\n<li>对给定数组排序</li>\n<li>带for循环递归时，检查前后两个元素是否相同，是则跳过</li>\n</ul>\n<p>剪枝细节：如果target - 当前元素小于0，可以直接break，无需继续遍历。</p>\n<h3 id=\"题17：电话号码的字母组合\"><a href=\"#题17：电话号码的字母组合\" class=\"headerlink\" title=\"题17：电话号码的字母组合\"></a>题17：电话号码的字母组合</h3><p>这道题求的是多组字母内分别取1的组合，之前的题型则为1组数内取k的组合。</p>\n<p>多组取1，对上述1组取多进行变式：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">backtracking</span><span class=\"params\">(vector&lt;string&gt;&amp; digitLetters <span class=\"comment\">/* 多组取1 */</span>, <span class=\"type\">int</span> index <span class=\"comment\">/* 指向哪一组 */</span>, string&amp; curStr, vector&lt;string&gt;&amp; res)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (curStr.<span class=\"built_in\">size</span>() == digitLetters.<span class=\"built_in\">size</span>()) &#123;</span><br><span class=\"line\">        res.<span class=\"built_in\">emplace_back</span>(curStr);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; digitLetters[index].<span class=\"built_in\">size</span>(); i++) &#123;  <span class=\"comment\">// 遍历每一组内的所有字母</span></span><br><span class=\"line\">        curStr.<span class=\"built_in\">push_back</span>(digitLetters[index][i]);</span><br><span class=\"line\">        <span class=\"built_in\">backtracking</span>(digitLetters, index + <span class=\"number\">1</span>, curStr, res);</span><br><span class=\"line\">        curStr.<span class=\"built_in\">pop_back</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"题131：回文字符串\"><a href=\"#题131：回文字符串\" class=\"headerlink\" title=\"题131：回文字符串\"></a>题131：回文字符串</h3><p>遍历字符串，选择步长，可以是1，2，3等，检查该子串是否符合，如果符合，加入结果；如果不符合，继续往大步长遍历。</p>\n<p>每次处理完当前子串后，对剩余的子串做相同动作（回溯）</p>\n<p>将这个过程具象化为一张横纵回溯图，如下所示：</p>\n<p><img src=\"https://camo.githubusercontent.com/0e9d7097c5f8a06d6ee1a6fd0ab110e981442669d0dbcdeb6d5e25ef615d5f1a/68747470733a2f2f636f64652d7468696e6b696e672e63646e2e626365626f732e636f6d2f706963732f3133312e2545352538382538362545352538392542322545352539422539452545362539362538372545342542382542322e6a7067\" alt=\"image\"></p>\n<p>横向对当前子串的区间放大，并分别判断</p>\n<p>纵向对剩余子串做同等处理</p>\n<h3 id=\"题93：复原IP地址\"><a href=\"#题93：复原IP地址\" class=\"headerlink\" title=\"题93：复原IP地址\"></a>题93：复原IP地址</h3><p>和回文串类似，对当前子串长度进行遍历，对剩余子串进行回溯。</p>\n<p>这里唯一要注意下对子串的合法性进行校验。</p>\n<h3 id=\"题78：子集\"><a href=\"#题78：子集\" class=\"headerlink\" title=\"题78：子集\"></a>题78：子集</h3><p>和爬楼梯类似，无需for循环，分考虑当前位置、不考虑当前位置两种场景进行回溯。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">subsets</span>(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums) &#123;</span><br><span class=\"line\">        vector&lt;<span class=\"type\">int</span>&gt; subset;</span><br><span class=\"line\">        vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; res;</span><br><span class=\"line\">        <span class=\"built_in\">backtracking</span>(nums, <span class=\"number\">0</span>, subset, res);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">backtracking</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> start, vector&lt;<span class=\"type\">int</span>&gt;&amp; subset, vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt;&amp; subsets)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (start &gt;= nums.<span class=\"built_in\">size</span>()) &#123;</span><br><span class=\"line\">            subsets.<span class=\"built_in\">emplace_back</span>(subset);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        subset.<span class=\"built_in\">push_back</span>(nums[start]);</span><br><span class=\"line\">        <span class=\"built_in\">backtracking</span>(nums, start + <span class=\"number\">1</span>, subset, subsets);</span><br><span class=\"line\">        subset.<span class=\"built_in\">pop_back</span>();</span><br><span class=\"line\">        <span class=\"built_in\">backtracking</span>(nums, start + <span class=\"number\">1</span>, subset, subsets);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>思考：什么时候回溯需要for循环，什么时候不用？</p>\n<p>其实这道题也可以套for循环：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">subsets</span>(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums) &#123;</span><br><span class=\"line\">        vector&lt;<span class=\"type\">int</span>&gt; subset;</span><br><span class=\"line\">        vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; res;</span><br><span class=\"line\">        <span class=\"built_in\">backtracking</span>(nums, <span class=\"number\">0</span>, subset, res);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">backtracking</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> startIndex, vector&lt;<span class=\"type\">int</span>&gt;&amp; subset, vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt;&amp; subsets)</span> </span>&#123;</span><br><span class=\"line\">        subsets.<span class=\"built_in\">push_back</span>(subset); <span class=\"comment\">// 收集子集，要放在终止添加的上面，否则会漏掉自己</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (startIndex &gt;= nums.<span class=\"built_in\">size</span>()) &#123; <span class=\"comment\">// 终止条件可以不加</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = startIndex; i &lt; nums.<span class=\"built_in\">size</span>(); i++) &#123;</span><br><span class=\"line\">            subset.<span class=\"built_in\">push_back</span>(nums[i]);</span><br><span class=\"line\">            <span class=\"built_in\">backtracking</span>(nums, i + <span class=\"number\">1</span>, subset, subsets);</span><br><span class=\"line\">            subset.<span class=\"built_in\">pop_back</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>相比第一种没有for循环写法，具有for循环的写法明显不那么直观。</p>\n<p><strong>变式题90：子集2</strong></p>\n<p>相比上道题，这道题给定的数组元素重复，求不重复的子集。</p>\n<p>解法和<strong>组合求和2</strong>一致，先排序，再回溯，检测前后重复的跳过。</p>\n<h3 id=\"题491：非递减子序列\"><a href=\"#题491：非递减子序列\" class=\"headerlink\" title=\"题491：非递减子序列\"></a>题491：非递减子序列</h3><p>给定数组，带重复元素，找所有非递减子序列。</p>\n<p>这道题特殊之处在于需要给子序列回溯加限定条件：</p>\n<ul>\n<li>当前元素比序列中最后1个元素大的，不考虑</li>\n<li>当前元素已经在之前用过的，不考虑（使用set数据结构，保存本层当前元素）</li>\n</ul>\n<p>比如[4,7,6,7]：4回溯，7回溯，6跳过，7跳过</p>\n<h3 id=\"题46：全排列\"><a href=\"#题46：全排列\" class=\"headerlink\" title=\"题46：全排列\"></a>题46：全排列</h3><p>push1 push2 push3 &#x3D;&#x3D;&gt; 1,2,3</p>\n<p>push1 push2 pop2 push3 &#x3D;&#x3D;&gt; 1,3,2</p>\n<p>pop掉的元素需要有地方暂存，直接存回数组？—— 可以用1个bool数组标记是否被使用过。</p>\n<p>因为全排列不分前后顺序，所以在每层回溯时都要遍历全部nums数组元素。</p>\n<p><strong>变式题47：全排列2</strong></p>\n<p>给定的nums数组现在具有重复元素了，求全排列。</p>\n<p>重复元素的做法：排序，for循环遇到重复元素，跳过</p>\n<p>这里仅上述判断还不够，因为类似[1,2,2]的答案，2和2重复，但不能跳。</p>\n<p>所以还得再加1个原则：nums[i - 1]被用过，即used[i - 1] &#x3D;&#x3D; false。</p>\n<h2 id=\"贪心\"><a href=\"#贪心\" class=\"headerlink\" title=\"贪心\"></a>贪心</h2><h3 id=\"题455：分发饼干\"><a href=\"#题455：分发饼干\" class=\"headerlink\" title=\"题455：分发饼干\"></a>题455：分发饼干</h3><p>约束：每个人最多获得1块饼干。</p>\n<p>贪心策略：人按胃口排序，饼干按大小排序，遍历每个人，找能满足当前这个人胃口的最小饼干。</p>\n<h3 id=\"题376：摆动序列\"><a href=\"#题376：摆动序列\" class=\"headerlink\" title=\"题376：摆动序列\"></a>题376：摆动序列</h3><p>删除若干元素后形成摆动序列，求序列最长的长度：可以转化为统计峰谷的数量。</p>\n<blockquote>\n<p>这里有个思维误区是：求要删除多少个元素，然后用序列总长 - 要删除的元素，该思路本身没问题，但对前后相等的过渡元素场景不好处理。</p>\n</blockquote>\n<h3 id=\"题53：最大子数组和\"><a href=\"#题53：最大子数组和\" class=\"headerlink\" title=\"题53：最大子数组和\"></a>题53：最大子数组和</h3><p>贪心策略：如果当前数组的sum为负数，则直接丢弃当前数组的sum（使sum置为0），从下一个新的元素开始计数。</p>\n<h3 id=\"题122：买卖股票的最佳时机2\"><a href=\"#题122：买卖股票的最佳时机2\" class=\"headerlink\" title=\"题122：买卖股票的最佳时机2\"></a>题122：买卖股票的最佳时机2</h3><p>贪心策略：求多个不相交的区间，区间的利润不存在负收益，然后对这些区间求和，得到最大利润。</p>\n<p>因为多个不相交无负收益区间之和等价于多个间隔为1的无负收益区间之和，所以问题可以简化相邻元素相减。</p>\n<h3 id=\"题55：跳跃游戏\"><a href=\"#题55：跳跃游戏\" class=\"headerlink\" title=\"题55：跳跃游戏\"></a>题55：跳跃游戏</h3><p>贪心策略：每一个元素都遍历一遍，检查该元素能够跳到的位置，不断统计取最远，如果遍历时发现的当前i指针超过了最远的位置，那就说明后面的元素不可达，return false。</p>\n<h3 id=\"题45：跳跃游戏2\"><a href=\"#题45：跳跃游戏2\" class=\"headerlink\" title=\"题45：跳跃游戏2\"></a>题45：跳跃游戏2</h3><p>这道题保证了一定能跳到终点，求最小步数。</p>\n<p>仍然是每个元素都遍历一遍，检查该元素能够跳到的位置，不断统计取最远。不同的是，在这里面，需要维护一个每次跳的区间。</p>\n<p>比如首次区间就是：start &#x3D; 0, end &#x3D; 1</p>\n<p>后面的区间则为：start &#x3D; end, end &#x3D; rightmost + 1</p>\n<h3 id=\"题1005：K次取反后的数组最大和\"><a href=\"#题1005：K次取反后的数组最大和\" class=\"headerlink\" title=\"题1005：K次取反后的数组最大和\"></a>题1005：K次取反后的数组最大和</h3><p>贪心策略：</p>\n<ul>\n<li>值越小取反收益越大，比如：1 2选1，-2 -1选-2</li>\n<li>都是非负数时，对当前最小值进行反复取反</li>\n</ul>\n<p>简单点可以考虑用最小堆。</p>\n<h3 id=\"题134：加油站\"><a href=\"#题134：加油站\" class=\"headerlink\" title=\"题134：加油站\"></a>题134：加油站</h3><p>能否到终点：对所有剩余油量求和，如果小于0，则无法到终点。</p>\n<p>选起点：该起点应能到达下一站；该起点应剩余油量要足够大（反例：[1,1,3], [1,2,1]，0号加油站不能作为起点，2号可以 &#x3D;&#x3D;&gt;[0,-1,2]）</p>\n<p>如果有1段特别大cost的呢？比如剩余油量：[1,2,-3]，选1号加油站过不去，只能选0号加油站。</p>\n<p>所以问题变为，剩余油量序列，累积子序列不能为负。</p>\n<p>如果出现负数，怎么办？</p>\n<p>思路1：从后往前寻找能填平该负数的index，如果有，那么该index就是起点。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">canCompleteCircuit</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; gas, vector&lt;<span class=\"type\">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> endIndex = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> sumRest = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> minGasRest = INT_MAX;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; gas.<span class=\"built_in\">size</span>(); i++) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> rest = gas[i] - cost[i];</span><br><span class=\"line\">            sumRest += rest;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (sumRest &lt; minGasRest) &#123;</span><br><span class=\"line\">                minGasRest = sumRest;</span><br><span class=\"line\">                endIndex = i;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sumRest &lt; <span class=\"number\">0</span>) &#123;  <span class=\"comment\">// 不能到达终点</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (minGasRest &gt;= <span class=\"number\">0</span>) &#123;  <span class=\"comment\">// 0作为起点就能到达终点</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 0作为起点不能达到终点，缺油，从后面补</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = gas.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>; i &gt;= endIndex + <span class=\"number\">1</span>; i--) &#123;  <span class=\"comment\">// 注意有些答案将endIndex + 1处理为0，原因是即便从后往前重复计算前半段，前半段已经明确缺油，前半段计算进去也找不到补</span></span><br><span class=\"line\">            <span class=\"type\">int</span> rest = gas[i] - cost[i];</span><br><span class=\"line\">            minGasRest += rest;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (minGasRest &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>思路2：借鉴最大子序列和的思路，出现负数时，就需要舍弃这部分，从下一个元素作为新起点。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">canCompleteCircuit</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; gas, vector&lt;<span class=\"type\">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> curSum = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> totalSum = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> start = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; gas.<span class=\"built_in\">size</span>(); i++) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> rest = gas[i] - cost[i];</span><br><span class=\"line\">            curSum += rest;</span><br><span class=\"line\">            totalSum += rest;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (curSum &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                start = i + <span class=\"number\">1</span>;</span><br><span class=\"line\">                curSum = <span class=\"number\">0</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (totalSum &lt; <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;  <span class=\"comment\">// 无解</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> start;  <span class=\"comment\">// 如果有解，一定从子序列之和为非负数开始</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"题135：分发糖果\"><a href=\"#题135：分发糖果\" class=\"headerlink\" title=\"题135：分发糖果\"></a>题135：分发糖果</h3><p>rating为1,2,3的，糖果为1,(1+1),(2+1)，后一个数&#x3D;前一个数+1</p>\n<p>rating为3,2,1的，糖果为(2+1),(1+1),1，前一个数&#x3D;后一个数+1</p>\n<p>推测：正方向遍历</p>\n<p>如果遇到正向递减的，如1,2,3,2,1，是否要跟着减一？不需要，如果减一会丢失的重复元素的位置信息。故正向递减按规则得到1,2,3,1,1</p>\n<p>按倒序规则得到1,1,3,2,1</p>\n<p>两个数组结合取最大值，得到1,2,3,2,1，就是我们最后想要的。</p>\n<p>重复元素怎么办？也适用</p>\n<p>1,2,3,3,3,2,1</p>\n<ul>\n<li>正向：1,2,3,1,1,1,1</li>\n<li>反向：1,1,1,1,3,2,1</li>\n<li>最大：1,2,3,1,3,2,1 &#x3D;&#x3D;&gt; 是最终结果</li>\n</ul>\n<h3 id=\"题860：柠檬水找零\"><a href=\"#题860：柠檬水找零\" class=\"headerlink\" title=\"题860：柠檬水找零\"></a>题860：柠檬水找零</h3><p>贪心思路：拿当前能够满足找零的最大面额去填。</p>\n<h3 id=\"题406：根据身高重建队列\"><a href=\"#题406：根据身高重建队列\" class=\"headerlink\" title=\"题406：根据身高重建队列\"></a>题406：根据身高重建队列</h3><p>这道题有点脑筋急转弯。关键还是要发现队列的规律：</p>\n<ul>\n<li>先按身高排（从高到低），如果身高相等的，按前方高于自身的数量排（从小到大），此时的序列接近直觉</li>\n<li>按上述顺序依次插入到新队列，身高高的总是先插入，身高矮的后插入，插入位置基于当前元素的前面高于自身的数量定，无论插入到哪都不会对当前新队列中已有的元素值造成影响，所以得到的新队列结果就是我们想要的。</li>\n</ul>\n<h3 id=\"题452：用最小数量的箭引爆气球\"><a href=\"#题452：用最小数量的箭引爆气球\" class=\"headerlink\" title=\"题452：用最小数量的箭引爆气球\"></a>题452：用最小数量的箭引爆气球</h3><p>气球区间重叠的可用1支箭射爆，那么问题就变为寻找子集的数量。</p>\n<p>我们对所有气球区间按左边界排序，然后维护1个子集和所有气球区间比对，有更小的子集就更新，最后返回子集数量即可。</p>\n<h3 id=\"题435：无重叠区间\"><a href=\"#题435：无重叠区间\" class=\"headerlink\" title=\"题435：无重叠区间\"></a>题435：无重叠区间</h3><p>两个步骤：</p>\n<ul>\n<li>排序，按右边界大小排（优先参加结束时间早的），如果相等的，选区间长度短的</li>\n<li>遍历，发现有交集就去掉当前区间，计数加1</li>\n</ul>\n<p>另一个思路：</p>\n<ul>\n<li>排序，按左边界大小排，如果相等的，选区间长度短的</li>\n<li>遍历，发现有交集就去掉大的区间，留小区间，计数加1</li>\n</ul>\n<h3 id=\"题763：划分字母空间\"><a href=\"#题763：划分字母空间\" class=\"headerlink\" title=\"题763：划分字母空间\"></a>题763：划分字母空间</h3><p>这道题本质是求重叠子区间的题，但因为字母多，形成的子区间多，求子区间交集较为复杂，为此有一个巧妙的思路：通过遍历字符串，比较当前索引是否等于当前字母的右区间，是则为分割点。</p>\n<h3 id=\"题56：合并区间\"><a href=\"#题56：合并区间\" class=\"headerlink\" title=\"题56：合并区间\"></a>题56：合并区间</h3><p>也是求重叠子区间问题，常规思路，排序，依次遍历，发现有重合的就合并，否则加入结果集返回。</p>\n<h3 id=\"题738：单调递增的数字\"><a href=\"#题738：单调递增的数字\" class=\"headerlink\" title=\"题738：单调递增的数字\"></a>题738：单调递增的数字</h3><p>找规律：从后往前，依次比较，如果出现不符合预期单调的，基于该规则改：比如32改为29，如此反复：4332，4329，4299，3299，2999。</p>\n<h3 id=\"题968：监控二叉树\"><a href=\"#题968：监控二叉树\" class=\"headerlink\" title=\"题968：监控二叉树\"></a>题968：监控二叉树</h3><p>贪心思路：让摄像头数量最少 等价于 让叶子节点尽量不要有摄像头，因为叶子节点放摄像头是非叶子节点的指数倍。</p>\n<p>为实现这种思路，需要对节点的状态分级：</p>\n<ul>\n<li>0：节点无覆盖</li>\n<li>1：节点有摄像头</li>\n<li>2：节点有覆盖</li>\n</ul>\n<p>通过后序遍历，基于每个节点的情况递推该状态值，并按情况放摄像头和计数。</p>\n<h2 id=\"动态规划\"><a href=\"#动态规划\" class=\"headerlink\" title=\"动态规划\"></a>动态规划</h2><h3 id=\"题509：斐波那契数\"><a href=\"#题509：斐波那契数\" class=\"headerlink\" title=\"题509：斐波那契数\"></a>题509：斐波那契数</h3><p>f(2) &#x3D; f(1) + f(0); f(3) &#x3D; f(2) + f(1)；f(0)和f(1)已知，所以直接基于此for循环滚动相加到指定n值即可。</p>\n<p>动态规划在这里面用到的位置为：每次for循环记录n-1 n-2处的值。</p>\n<h3 id=\"题70：爬楼梯\"><a href=\"#题70：爬楼梯\" class=\"headerlink\" title=\"题70：爬楼梯\"></a>题70：爬楼梯</h3><p>n阶楼梯到顶，就有n-1阶楼梯的dp[n-1]种方法 + n-2阶楼梯的dp[n - 2]种方法。</p>\n<p>本质是斐波那契数。</p>\n<p>所以解法和斐波那契数一致。</p>\n<h3 id=\"题746：使用最小花费爬楼梯\"><a href=\"#题746：使用最小花费爬楼梯\" class=\"headerlink\" title=\"题746：使用最小花费爬楼梯\"></a>题746：使用最小花费爬楼梯</h3><p>动态规划数组定义：dp[i] &#x3D; min(dp[i-1] + cost[i-1], dp[i-2] + cost[i-2])</p>\n<p>解释：dp[i]指当前第i阶所花费的最小费用。</p>\n<h3 id=\"题62：不同路径\"><a href=\"#题62：不同路径\" class=\"headerlink\" title=\"题62：不同路径\"></a>题62：不同路径</h3><p>机器人到达mxn矩阵右下角有多少不同路径，定义dp[i][j]，表示到达i,j点有多少不同路径，其等于(i-1,j),(i,j-1)点的路径数之和。</p>\n<p><strong>变式题63：不同路径2</strong></p>\n<p>这道题在mxn矩阵中加了障碍物，整体思路是不变的，核心点在于遇到障碍物后，障碍物位置的dp[i][j]要清零。</p>\n<h3 id=\"题343：整数拆分\"><a href=\"#题343：整数拆分\" class=\"headerlink\" title=\"题343：整数拆分\"></a>题343：整数拆分</h3><p>一个整数i，可以拆分为：</p>\n<ul>\n<li>两个整数，j * (i - j)</li>\n<li>一个整数和再拆分的整数相乘：j * 再拆分(i - j)</li>\n</ul>\n<p>定义dp[i]为整数i的最大乘积</p>\n<p>那么上述再拆分的乘积即为：j * dp[i - j]</p>\n<p>那么整数i的最大乘积即可从上述两种情况中获取：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">max(j * (i - j), j * dp[i - j])</span><br></pre></td></tr></table></figure>\n\n<p>j的取值可以从1到i-1遍历，计算每种拆分j的值，取最大，就得到当前dp[i]最大：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curMax = 0;</span><br><span class=\"line\"><span class=\"keyword\">for</span> j = 1..i-1</span><br><span class=\"line\">\tcurMax = max(curMax, max(j * (i - j), j * dp[i - j]))</span><br><span class=\"line\">dp[i] = curMax</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"题96：不同的二叉搜索树\"><a href=\"#题96：不同的二叉搜索树\" class=\"headerlink\" title=\"题96：不同的二叉搜索树\"></a>题96：不同的二叉搜索树</h3><p>动态规划思路：</p>\n<p>遍历1..n，计算每个数i作为根节点时的二叉树个数，然后求和。</p>\n<p>定义dp[i]，表示以i为根节点时的二叉树个数</p>\n<p>针对每个根节点的取值j，都有dp[j] &#x3D; dp[j-1] * dp[i-j]，得解。</p>\n<h3 id=\"题kama46：01背包\"><a href=\"#题kama46：01背包\" class=\"headerlink\" title=\"题kama46：01背包\"></a>题kama46：01背包</h3><p>定义物品的weight和价值value，求一个给定bagweight容量的背包，可以放入的最大价值。</p>\n<p>这种就是01背包问题，对于每个物品，要么选1个，要么不选</p>\n<p>如果是每个物品可以选多次，那就是完全背包问题。</p>\n<p>背包问题的dp数组定义：dp[j]表示达到重量为j的背包最大可放入的价值。</p>\n<p>递推公式：dp[j] &#x3D; max(dp[j], dp[j - weight[i]] + value[i])</p>\n<p>解释：不选，dp[j]，选，dp[j - weight[i]] + value[i]</p>\n<p>遍历方式：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; weight.<span class=\"built_in\">size</span>(); i++) &#123;  <span class=\"comment\">// 遍历物品</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = bagweight; j &gt;= weight[i]; j--) &#123;  <span class=\"comment\">// 遍历重量</span></span><br><span class=\"line\">\t\tdp[j] = <span class=\"built_in\">max</span>(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"题416：分割等和子集\"><a href=\"#题416：分割等和子集\" class=\"headerlink\" title=\"题416：分割等和子集\"></a>题416：分割等和子集</h3><p>将一个数组分成两部分，要求和相等</p>\n<p>思路：求和，除以2，得到背包的大小target，数组本身既是weight也是value。满足条件：dp[target] &#x3D;&#x3D; target。</p>\n<h3 id=\"题1049：最后一块石头的重量2\"><a href=\"#题1049：最后一块石头的重量2\" class=\"headerlink\" title=\"题1049：最后一块石头的重量2\"></a>题1049：最后一块石头的重量2</h3><p>题目核心问题在于任意石头，不是相邻石头，故需要动态规划。</p>\n<p>思路：两快石头相消，得到石头A-石头B的重量，推导到整个数组就是两个子数组相消得到的最小重量。</p>\n<p>如何得到最小重量？尽量让两个数组之和相等。这就回到上面的题416解法。</p>\n<h3 id=\"题494：目标和\"><a href=\"#题494：目标和\" class=\"headerlink\" title=\"题494：目标和\"></a>题494：目标和</h3><p>回溯：选+，选-，直到pos遍历完， 检查是否等于target</p>\n<p>动态规划：求sum，再添加-，得到target，故公式（设x等于+号和）：x + (sum - x) &#x3D; target，x &#x3D; (sum + target) &#x2F; 2，此时问题转化为：填满背包大小为x的组合有多少种。</p>\n<p>dp[i]定义：填满i大小的背包，有dp[i]种组合。</p>\n<p>递推公式：dp[j] +&#x3D; dp[j - nums[i]]，表示填满0大小背包组合数+填满1大小背包组合数+…</p>\n<h3 id=\"题kama52：完全背包\"><a href=\"#题kama52：完全背包\" class=\"headerlink\" title=\"题kama52：完全背包\"></a>题kama52：完全背包</h3><p>完全背包和01背包的区别是，完全背包可以重复地选择1件物品，而01不行。</p>\n<p>在实现上，为支持1件物品被重复选择，只需要将内层背包循环按从小到大遍历即可。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; weight.<span class=\"built_in\">size</span>(); i++) &#123;  <span class=\"comment\">// 遍历物品</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = weight[i]; j &lt;= bagsize; j++) &#123;  <span class=\"comment\">// 遍历重量，从小到大遍历</span></span><br><span class=\"line\">\t\tdp[j] = <span class=\"built_in\">max</span>(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"题474：一和零\"><a href=\"#题474：一和零\" class=\"headerlink\" title=\"题474：一和零\"></a>题474：一和零</h3><p>字符串数组，每个字符串0和1的数量，本质就是当前字符串元素的重量，0和1的数量分别不能超过m和n，那么m和n即为背包容量。所以这道题本质是背包问题。</p>\n<p>dp[i][j]定义：容量为i的背包A和容量为j的背包B所能承载的最多物品数。</p>\n<h3 id=\"题518：零钱兑换2\"><a href=\"#题518：零钱兑换2\" class=\"headerlink\" title=\"题518：零钱兑换2\"></a>题518：零钱兑换2</h3><p>硬币可重复pick，完全背包问题。</p>\n<p><strong>求组合数，而不是求最大价值。组合数</strong>意味着没有顺序之分。</p>\n<p>dp[j]定义：背包容量为i时的组合数</p>\n<p>递推公式：dp[j] +&#x3D; dp[j - coins[i]]，表示：背包容量为j的组合数 &#x3D; 不加coins[i]当前背包容量为j的组合数 + 新增coins[i]从j-coins[i]继承的组合数</p>\n<p>该递推公式要求dp[0] &#x3D; 1，不能为0，否则后续的推导全部为0。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">背包dp槽位</th>\n<th align=\"left\"><strong>0</strong></th>\n<th align=\"left\"><strong>1</strong></th>\n<th align=\"left\"><strong>2</strong></th>\n<th align=\"left\"><strong>3</strong></th>\n<th align=\"left\"><strong>4</strong></th>\n<th align=\"left\"><strong>5</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">coins[0] &#x3D; 1填充背包</td>\n<td align=\"left\">1</td>\n<td align=\"left\">1</td>\n<td align=\"left\">1</td>\n<td align=\"left\">1</td>\n<td align=\"left\">1</td>\n<td align=\"left\">1</td>\n</tr>\n<tr>\n<td align=\"left\">coins[1] &#x3D; 2填充背包</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\">2&#x3D;dp[0]+dp[2]，更新到当前dp[2]</td>\n<td align=\"left\">2</td>\n<td align=\"left\">3&#x3D;dp[4]+dp[2]，dp[2]前面刚更新为2，所以这里为3</td>\n<td align=\"left\">3</td>\n</tr>\n<tr>\n<td align=\"left\">coins[2] &#x3D; 5填充背包</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\">4</td>\n</tr>\n</tbody></table>\n<h3 id=\"题377：组合总和4\"><a href=\"#题377：组合总和4\" class=\"headerlink\" title=\"题377：组合总和4\"></a>题377：组合总和4</h3><p><strong>本题求排列数，有顺序之分。</strong></p>\n<p>排列数和组合数在for循环有差别：</p>\n<ul>\n<li><strong>如果求组合数就是外层for循环遍历物品，内层for遍历背包</strong>。</li>\n<li><strong>如果求排列数就是外层for遍历背包，内层for循环遍历物品</strong>。</li>\n</ul>\n<p>原因：如果把遍历nums（物品）放在外循环，遍历target的作为内循环的话，举一个例子：计算dp[4]的时候，结果集只有 {1,3} 这样的集合，不会有{3,1}这样的集合，因为nums遍历放在外层，3只能出现在1后面！</p>\n<h3 id=\"题kama57：爬楼梯\"><a href=\"#题kama57：爬楼梯\" class=\"headerlink\" title=\"题kama57：爬楼梯\"></a>题kama57：爬楼梯</h3><p>爬楼梯变式，可以选择小于等于m阶步长，爬n阶大小楼梯。</p>\n<p>背包：n，物品：[1~m]</p>\n<p>递推公式：dp[i] +&#x3D; dp[i - j]，其中i是背包，j是物品</p>\n<p>因为有序，所以背包在外，物品在内。</p>\n<h3 id=\"题322：零钱兑换\"><a href=\"#题322：零钱兑换\" class=\"headerlink\" title=\"题322：零钱兑换\"></a>题322：零钱兑换</h3><p>这道题求的是最小硬币数，前面求的是组合数。</p>\n<p>二者区别在于递推公式的变化。最小硬币数：dp[j] &#x3D; min(dp[j], dp[j - nums[i]] + 1)</p>\n<p>其他注意点：因为是min，所以dp数组初始化为INT_MAX</p>\n<p>在遍历过程中，需规避INT_MAX + 1情况，否则溢出。</p>\n<p>递推公式的源头是dp[0]，应初始化为0。</p>\n<h3 id=\"题279：完全平方数\"><a href=\"#题279：完全平方数\" class=\"headerlink\" title=\"题279：完全平方数\"></a>题279：完全平方数</h3><p>思路和上题一致，求最小数量。只是元素上做了一点区别，不是直接给的，而是要自己做下平方。</p>\n<h3 id=\"题139：单词拆分\"><a href=\"#题139：单词拆分\" class=\"headerlink\" title=\"题139：单词拆分\"></a>题139：单词拆分</h3><p>思路：单词数组中的单词可重复抽取 &#x3D;&#x3D;&gt; 完全背包</p>\n<p>背包：目标字符串。</p>\n<p>dp[j]定义：长度为j的字符串背包是否能被单词数组组合得到。</p>\n<p>有序：遍历背包长度，遍历单词长度</p>\n<p>递推公式：如果单词长度的子串“xxxxx[子串]”在单词数组里，且dp[xxxxx.len] &#x3D;&#x3D; true, 则dp[j] &#x3D; true。</p>\n<p>初始值：dp[0] &#x3D; true，其他为false</p>\n<h3 id=\"题kama56：多重背包\"><a href=\"#题kama56：多重背包\" class=\"headerlink\" title=\"题kama56：多重背包\"></a>题kama56：多重背包</h3><p>01背包限定了物品数量为1，完全背包不限定物品数量，多重背包介于二者之间，限定了物品数量，但不一定为1。</p>\n<p>多重背包符合现实中的逻辑，物品资源是有限个的。</p>\n<p>多重背包可以退化为01背包，只需要将多个物品A展开为每一个物品A。</p>\n<p>所以整体代码框架是不变的，和01背包类似，唯一需要处理的是新增一个内部的for循环：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> bagweight, n;</span><br><span class=\"line\">    cin &gt;&gt; bagweight &gt;&gt; n;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">weights</span><span class=\"params\">(n, <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">values</span><span class=\"params\">(n, <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">nums</span><span class=\"params\">(n, <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) cin &gt;&gt; weights[i];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) cin &gt;&gt; values[i];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) cin &gt;&gt; nums[i];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">dp</span><span class=\"params\">(bagweight + <span class=\"number\">1</span>, <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = bagweight; j &gt;= weights[i]; j--) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 这里要根据物品数量做处理</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> k = <span class=\"number\">1</span>, k &lt; nums[i]; k++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (j - k * weights[i] &lt; <span class=\"number\">0</span>) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                dp[j] = <span class=\"built_in\">max</span>(dp[j], dp[j - k * weights[i]] + k * values[i]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dp[bagweight];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"题198：打家劫舍\"><a href=\"#题198：打家劫舍\" class=\"headerlink\" title=\"题198：打家劫舍\"></a>题198：打家劫舍</h3><p>错误思路：维护一个前面有没有偷的标记，这种思路会导致起始点的偷or不偷不好处理。</p>\n<p>正确思路：偷or不偷，状态依赖。</p>\n<p>dp[i]定义：遍历到第i个物品时的最大金额。</p>\n<p>递推公式：dp[j] &#x3D; max(dp[i - 2] + nums[i], dp[i - 1])，这里就表示了前1个偷or不偷的关系</p>\n<p>初始化：dp[0] &#x3D; nums[0]，dp[1] &#x3D; max(nums[0], nums[1])</p>\n<p>循环：只要1层循环即可，遍历物品。</p>\n","excerpt":"<p>本文旨在记录刷题过程中的思考，以及在给定刷题路径上做一些变式补充。</p>\n<p>刷题路径遵循：<a href=\"https://github.com/youngyangyang04/leetcode-master?tab=readme-ov-file\">https://github.com/youngyangyang04/leetcode-master?tab=readme-ov-file</a></p>","more":"<h2 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h2><h3 id=\"题704：二分查找\"><a href=\"#题704：二分查找\" class=\"headerlink\" title=\"题704：二分查找\"></a>题704：二分查找</h3><p>二分查找重点关注边界取舍，这里讨论left、right为闭区间的情况：</p>\n<ul>\n<li>外层循环为left &lt;&#x3D; right，具有等号</li>\n<li>里层赋值left &#x3D; mid + 1 或 right &#x3D; mid - 1，偏移1个单位</li>\n</ul>\n<p>为什么？</p>\n<p>外层循环取等号由内层赋值控制推导，存在加1减1时left &#x3D;&#x3D; right的可能，且所指向的值未曾遍历。</p>\n<p>里层赋值偏移1个单位原因是，前一次的[mid]值判断已经在条件中得到结论，故下一个[mid]无需再遍历。</p>\n<blockquote>\n<p>[数值]符号含义：指取该数值所指向的值。</p>\n</blockquote>\n<p><strong>变式题34：找边界</strong></p>\n<p>找出指定数值的起始位置和终止位置。仍然是二分查找，唯一要处理的点是：</p>\n<p>在匹配到指定数值后，不要停：</p>\n<ul>\n<li>起始位置对应：右边界 - 1</li>\n<li>终止位置对应：左边界 + 1</li>\n<li>暂存当前的位置</li>\n</ul>\n<p>最终循环会因为left &lt;&#x3D; right不满足打破。</p>\n<p><strong>变式题162：找峰值</strong></p>\n<p>题目要求只要找到任意一个峰值即可，为此可以使用二分。</p>\n<p>假设-1，n均为负无穷，所以原始数组就变为[-infinity, 1, 2, 1, -infinity]</p>\n<p>基于此取查找就可找到答案。</p>\n<p>因为数组不支持-1和n索引，所以可以定义一个匿名函数支持它，这里也利用了cpp中的pair&lt;int,int&gt;特性。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">auto</span> get = [&amp;](<span class=\"type\">int</span> i) -&gt; pair&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt; &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (i == <span class=\"number\">-1</span> || i == n) &#123;  <span class=\"comment\">// 如果是-1或n，pair第一个值比较起作用，一定是最小的</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;<span class=\"number\">0</span>, <span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;<span class=\"number\">1</span>, nums[i]&#125;;  <span class=\"comment\">// pair的第二值起作用，依据具体nums[i]</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">get</span>(idx) &gt; <span class=\"built_in\">get</span>(idx + <span class=\"number\">1</span>) &amp;&amp; <span class=\"built_in\">get</span>(idx) &gt; <span class=\"built_in\">get</span>(idx - <span class=\"number\">1</span>)  <span class=\"comment\">// 这就是峰值</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"题27：O1空间内处理数组删除\"><a href=\"#题27：O1空间内处理数组删除\" class=\"headerlink\" title=\"题27：O1空间内处理数组删除\"></a>题27：O1空间内处理数组删除</h3><p>方式1：快慢指针，快指针负责搜索不相等元素，慢指针负责等候快指针给的值进行存储。</p>\n<p>方式2：c++可以使用iterator，在<code>*it</code>匹配到相等元素后，通过erase删除v.erase(it)，并保证it不向下走，因为这里erase的实现上会讲数组后续元素都向前shift 1个单位，所以此时的it仍然指向下一个新值。</p>\n<p>当然，方式2比方式1慢很多（1ms vs 5ms），时间复杂度后者为O(n2)。</p>\n<h3 id=\"题977：On时间内平方数组\"><a href=\"#题977：On时间内平方数组\" class=\"headerlink\" title=\"题977：On时间内平方数组\"></a>题977：On时间内平方数组</h3><p>双指针解法，利用原有数组的有序特性 + 平方后的排序是两端大中间小的特性，推导出两个指针从两头开始，往中间遍历。</p>\n<h3 id=\"题209：最小连续子数组\"><a href=\"#题209：最小连续子数组\" class=\"headerlink\" title=\"题209：最小连续子数组\"></a>题209：最小连续子数组</h3><p>使用滑动窗口，本质是双指针，维护一个双指针区间内部的sum，一边加一边卸，返回区间长度。</p>\n<p><strong>变式题121：股票价值最大化</strong></p>\n<p>思路：题目要求只能1次买入卖出，所以可以设想：每一天，都想一个问题，我在历史最低点买入，今天卖出，会盈利多少（也就是保存最小价格，和当天价格相减，取max，得到结果）</p>\n<p><strong>变式题122：支持多次买入卖出</strong></p>\n<p>思路：动态规划，二维数组做状态记录</p>\n<blockquote>\n<p>其实只用2个数值做记录也够用，因为我们总是只回看前一个数。</p>\n</blockquote>\n<p>一列是未持股时手上的现金，一列是持股后手上的现金</p>\n<p>下一列的值等于：</p>\n<ul>\n<li>今日未持股现金 &#x3D; 昨日未持股现金，昨日持股后今日卖掉的现金 取最大&#x20;</li>\n<li>今日持股现金 &#x3D; 昨日持股现金，昨日未持股现金买今日股票后的现金 取最大</li>\n</ul>\n<p>最后取未持股时的现金返回。</p>\n<h3 id=\"题59：螺旋矩阵\"><a href=\"#题59：螺旋矩阵\" class=\"headerlink\" title=\"题59：螺旋矩阵\"></a>题59：螺旋矩阵</h3><p>螺旋矩阵没什么算法，纯粹是边界处理，顺着方向写就行。</p>\n<p>right -&gt; down -&gt; left -&gt; up</p>\n<p>每转一圈，边长减1。</p>\n<h2 id=\"链表\"><a href=\"#链表\" class=\"headerlink\" title=\"链表\"></a>链表</h2><h3 id=\"题203：移除链表元素\"><a href=\"#题203：移除链表元素\" class=\"headerlink\" title=\"题203：移除链表元素\"></a>题203：移除链表元素</h3><p>两个基本注意点：</p>\n<ul>\n<li>要创建一个dummy节点，作为起始遍历辅助</li>\n<li>结束时要返回dummy.next，而不是head，因为head有可能已被删除</li>\n</ul>\n<h3 id=\"题707：设计链表\"><a href=\"#题707：设计链表\" class=\"headerlink\" title=\"题707：设计链表\"></a>题707：设计链表</h3><p>核心方法：addAtIndex，deleteAtIndex，get</p>\n<p>关键点是要初始化一个dummy节点，从该节点开始处理链表的新增和删除。其本质和上述移除链表元素是一样的，必须得有个假的头节点来处理index为0的情况。</p>\n<h3 id=\"题206：翻转链表\"><a href=\"#题206：翻转链表\" class=\"headerlink\" title=\"题206：翻转链表\"></a>题206：翻转链表</h3><p>观察翻转前后的变化，只有相邻节点的next箭头变了，因此只需要prev、current两个变量：</p>\n<ul>\n<li>先暂存next，翻转current-&gt;prev</li>\n<li>然后prev、current往下平移1个单位</li>\n</ul>\n<p>最后prev就是头了。</p>\n<p>当然这道题的另一种思路是拷贝到新链表，弊端是占用了额外内存空间。</p>\n<h3 id=\"题24：两两节点交换\"><a href=\"#题24：两两节点交换\" class=\"headerlink\" title=\"题24：两两节点交换\"></a>题24：两两节点交换</h3><p><img src=\"https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg\"></p>\n<p>最小可重复交换操作为：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 三个数一组</span></span><br><span class=\"line\">[dummy 1 2] 3 4</span><br><span class=\"line\">[dummy 2 1] 3 4</span><br><span class=\"line\"><span class=\"comment\"># 指针偏移2个单位</span></span><br><span class=\"line\">dummy 2 [1 3 4]</span><br><span class=\"line\">dummy 2 [1 4 3]</span><br><span class=\"line\"><span class=\"comment\"># 再偏移2个单位</span></span><br><span class=\"line\">dummy 2 1 4 [3 null null]  <span class=\"comment\"># 无需交换</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 不满两组的情况</span></span><br><span class=\"line\">[dummy 1 2] 3</span><br><span class=\"line\">[dummy 2 1] 3</span><br><span class=\"line\">dummy 2 [1 3 null]  <span class=\"comment\"># 无需交换</span></span><br></pre></td></tr></table></figure>\n\n<p>所以截止条件为：只要有null，就无需再操作。</p>\n<p>这种最小可重复操作怎么发现的？</p>\n<p>观察一次有多少元素需要参与运算，上述1 2参与了，2的下一个元素3属于下一次运算的范畴，可以不处理。下一次运算时，3 4交换，此时前面的1箭头也要变，所以参与运算的就有3个。为了抽象为通用操作，第一次运算1 2时，在其前补充dummy元素。</p>\n<h3 id=\"题19：删除链表的倒数第N个节点\"><a href=\"#题19：删除链表的倒数第N个节点\" class=\"headerlink\" title=\"题19：删除链表的倒数第N个节点\"></a>题19：删除链表的倒数第N个节点</h3><p>要求一次遍历计算出来：</p>\n<ul>\n<li><p>链表长度怎么获取？</p>\n<ul>\n<li>只能遍历完。</li>\n</ul>\n</li>\n<li><p>遍历完后推算出倒数第n的位置，怎么返回获取前后节点？</p>\n<ul>\n<li>遍历时有意识的保存</li>\n</ul>\n</li>\n</ul>\n<p>如何实现有意识的保存？思路：构造2个有距离的指针，同时shift遍历，距离就是n。</p>\n<h3 id=\"题02-07：链表相交\"><a href=\"#题02-07：链表相交\" class=\"headerlink\" title=\"题02.07：链表相交\"></a>题02.07：链表相交</h3><p>思路1：普通解法</p>\n<ul>\n<li>分别遍历每条链表，计算长度，得到长度之差</li>\n<li>挑长链表磨平差值</li>\n<li>此时两条链表并排，开始遍历比较，第一个出现相等的元素就是了</li>\n</ul>\n<p>思路2：数学算法</p>\n<p>链表A不相交部分长度a，链表A相交部分长度c</p>\n<p>链表A不相交部分长度a，链表A相交部分长度c</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a + c = m</span><br><span class=\"line\">b + c = n</span><br><span class=\"line\">a + c + b = b + c + a</span><br></pre></td></tr></table></figure>\n\n<p>可以得到，不相交部分长度走完，一定是交点。</p>\n<h3 id=\"题142：环形链表\"><a href=\"#题142：环形链表\" class=\"headerlink\" title=\"题142：环形链表\"></a>题142：环形链表</h3><p>思路1：将所有被遍历的节点压栈set集合，如果有重复节点，set长度将不会增长。</p>\n<ul>\n<li>缺点：需要额外内存空间存储节点地址</li>\n</ul>\n<p>思路2：设置快慢指针，快指针1次2步，慢指针1次1步，如果快指针追上慢指针，则满足条件。</p>\n<p>一定能相遇吗？</p>\n<ul>\n<li>一定能的，即便快指针在固定节点循环，慢指针属于遍历，一定能踩到。</li>\n</ul>\n<p>相遇的点一定是交点吗？</p>\n<ul>\n<li>不是，但可以通过以下公式推导：假设a是环外长度，b是环内长度，n表示在环内转了n圈，f是快指针走的里程，s是慢指针走的里程</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 已知快指针比慢指针多走一倍里程</span></span><br><span class=\"line\">f = 2s</span><br><span class=\"line\"><span class=\"comment\"># 已知快慢相遇时，在相遇节点开始走n圈 + s就是快指针的里程</span></span><br><span class=\"line\">f = s + nb</span><br><span class=\"line\"><span class=\"comment\"># 推导得到</span></span><br><span class=\"line\">s = nb</span><br><span class=\"line\"><span class=\"comment\"># 已知从head走到入口节点需要：</span></span><br><span class=\"line\">a + nb</span><br><span class=\"line\"><span class=\"comment\"># 慢指针已经走了nb步，还需再走a步，a步怎么来？和head开始的指针一起走，直至相遇，得到结论。</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"hash表\"><a href=\"#hash表\" class=\"headerlink\" title=\"hash表\"></a>hash表</h2><h3 id=\"题242：有效的字母异位词\"><a href=\"#题242：有效的字母异位词\" class=\"headerlink\" title=\"题242：有效的字母异位词\"></a>题242：有效的字母异位词</h3><p>思路1：最直接的方法是定义一个hashmap，第一轮迭代填充charMap，第二轮迭代减少charMap计数，如果出现-1的则return false。</p>\n<p>思路2：定义1个具有26长度的数组，每个位置依据字符串的字符位置进行++–，最后check一遍得到结果。</p>\n<h3 id=\"题1002：查找共用字符\"><a href=\"#题1002：查找共用字符\" class=\"headerlink\" title=\"题1002：查找共用字符\"></a>题1002：查找共用字符</h3><p>这里有个坑是，不是说一个字母统计一次就行，而是如相同字母在多个words里分别重复出现了，那就都得输出出来。</p>\n<p>思路：一个当前word的freq数组，一个全局words的最小freq数组，分别统计每个词的字母出现频率。</p>\n<p>全局word在的foreach每个词时，总是取当前word每个槽位的最小值。</p>\n<h3 id=\"题349：两个数组的交集\"><a href=\"#题349：两个数组的交集\" class=\"headerlink\" title=\"题349：两个数组的交集\"></a>题349：两个数组的交集</h3><p>这道题跟上面一道题有点类似，这道题要求一个字母只统计1次，并且只有两个数组之间的比较，所以可以认为是上一道题的简单版本。</p>\n<p>思路：set存储第一个数组内容，set.count(第二个数组中的每一个元素)，如果存在，则return</p>\n<h3 id=\"题202：快乐数\"><a href=\"#题202：快乐数\" class=\"headerlink\" title=\"题202：快乐数\"></a>题202：快乐数</h3><p>首先理解题意：</p>\n<ul>\n<li>拆解的数的每一位做平方</li>\n<li>希望得到1</li>\n<li>可能永远都得不到</li>\n<li>得不到的原因是无限循环（在某个圈内循环转）</li>\n</ul>\n<p>解题关键：找到循环的入口</p>\n<p>具体思路：记录历史算数，如果重复或为1，则退出</p>\n<h3 id=\"题1：两数之和\"><a href=\"#题1：两数之和\" class=\"headerlink\" title=\"题1：两数之和\"></a>题1：两数之和</h3><p>思路：排序，二分，要寻找的对象是：find(和 - 当前数值)。</p>\n<p>寻找对象的方法还可以是hashset，即hashset + find，这里要注意，find到值不能是自己，并且还要有数组下标返回，所以通过hashmap更合适。</p>\n<h3 id=\"题454：四数相加\"><a href=\"#题454：四数相加\" class=\"headerlink\" title=\"题454：四数相加\"></a>题454：四数相加</h3><p>四个数组，长度一致；每个数组挑1个数，和其他数相加；求和要等于0；返回有多少种可能。</p>\n<p>要把所有组合都遍历一遍，n的4次方。减少复杂度方法是，分为2组，每组n的2次方，从等于0改为ab组 &#x3D; -cd组。ab组的求和存入hash表，值为等于该和的组数；cd组查询，这样就得到最终结果。</p>\n<h3 id=\"题383：赎金信\"><a href=\"#题383：赎金信\" class=\"headerlink\" title=\"题383：赎金信\"></a>题383：赎金信</h3><p>数组2中的字符作为候选，数组1消费。</p>\n<p>给1个hashmap对候选计数，数组1遍历时消费，如果找不到或value出现小于0的情况，则为false。</p>\n<h3 id=\"题15：三数之和\"><a href=\"#题15：三数之和\" class=\"headerlink\" title=\"题15：三数之和\"></a>题15：三数之和</h3><p>思路1：选target，剩下的元素求“两数之和”，因为本题要求返回所有元组，而两数之和给了1个只有1个元组答案的约束，所以，本题最后还得有一层去重处理。</p>\n<p>思路2：组合问题，从数组中选3，求和。</p>\n<p>组合问题是无序的，相比有序的数组还是差了点效率。所以</p>\n<p>思路3：这里可以基于排序后的数组，使用双指针解决</p>\n<ul>\n<li>遍历数组，从first &#x3D; 0，选target</li>\n<li>定义left &#x3D; first + 1、right &#x3D;&#x3D; n - 1，双指针两方向往中间靠近，找所有解</li>\n</ul>\n<p>second和third就是双指针。</p>\n<h3 id=\"题18：四数之和\"><a href=\"#题18：四数之和\" class=\"headerlink\" title=\"题18：四数之和\"></a>题18：四数之和</h3><p>本质是在三数之和上套一层循环，怎么理解？</p>\n<ul>\n<li>遍历数组，从first &#x3D; 0，选target</li>\n<li>遍历数组，从second &#x3D; first + 1</li>\n<li>定义left &#x3D; second + 1、right &#x3D; n - 1，双指针两方向往中间靠近，找所有解</li>\n</ul>\n<p>相关剪枝细节（其实就是哪些可以跳过不做的）这里不展开。</p>\n<h2 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h2><h3 id=\"题344：反转字符串\"><a href=\"#题344：反转字符串\" class=\"headerlink\" title=\"题344：反转字符串\"></a>题344：反转字符串</h3><p>这道题要求原地反转。</p>\n<p>思路：双指针从两端到中间依次反转字符对，截止条件：指针相遇或错过。</p>\n<p><strong>变式题541：反转字符串2</strong></p>\n<p>相比上一道字符串增加了步长，其余逻辑一致。</p>\n<h3 id=\"题kama54：替换数字\"><a href=\"#题kama54：替换数字\" class=\"headerlink\" title=\"题kama54：替换数字\"></a>题kama54：替换数字</h3><p>这道题也是要做到原地变更字符串。利用C++里的s.resize方法。</p>\n<p>核心思路是：预留卡位，从后往前填。</p>\n<h3 id=\"题151：反转字符串中的单词\"><a href=\"#题151：反转字符串中的单词\" class=\"headerlink\" title=\"题151：反转字符串中的单词\"></a>题151：反转字符串中的单词</h3><p>这题考察对string api的熟悉程度。</p>\n<p>更高要求：原地修改字符串，大致步骤：</p>\n<ul>\n<li>字符串reverse</li>\n<li>删除多余空格</li>\n<li>单词reverse</li>\n</ul>\n<h3 id=\"题kama55：右旋字符串\"><a href=\"#题kama55：右旋字符串\" class=\"headerlink\" title=\"题kama55：右旋字符串\"></a>题kama55：右旋字符串</h3><p>思路上跟上道题类似，右旋只是表象，本质还是2个操作：</p>\n<ul>\n<li>字符串reverse</li>\n<li>区间字符串reverse（等同于单词reverse）</li>\n</ul>\n<h3 id=\"题459：重复的子字符串\"><a href=\"#题459：重复的子字符串\" class=\"headerlink\" title=\"题459：重复的子字符串\"></a>题459：重复的子字符串</h3><p>特殊例子：ababdababd、acdfdacdfd，这也是重复的</p>\n<p>思路1：比较朴素的解法</p>\n<ul>\n<li>遍历各种长度（满足size % 长度 &#x3D;&#x3D; 0）的子串</li>\n<li>始终满足是前一个子串的前缀：s[j] &#x3D;&#x3D; s[j - 1]，j++，j &lt; size</li>\n</ul>\n<p>思路2：特殊性质</p>\n<ul>\n<li>如果是重复子串，则abab + abab，去掉头尾， &#x3D; bababa 包含ab</li>\n<li>如果不是，则absab + absab &#x3D; bsababsa 不包含 absab</li>\n</ul>\n<h2 id=\"双指针\"><a href=\"#双指针\" class=\"headerlink\" title=\"双指针\"></a>双指针</h2><h3 id=\"题27：移除元素\"><a href=\"#题27：移除元素\" class=\"headerlink\" title=\"题27：移除元素\"></a>题27：移除元素</h3><p>原地操作移除元素，可使用快慢指针，慢指针指向当前要赋值的位置，快指针指向非目标元素的位置，如此迭代。</p>\n<h2 id=\"栈与队列\"><a href=\"#栈与队列\" class=\"headerlink\" title=\"栈与队列\"></a>栈与队列</h2><h3 id=\"题232：用栈实现队列\"><a href=\"#题232：用栈实现队列\" class=\"headerlink\" title=\"题232：用栈实现队列\"></a>题232：用栈实现队列</h3><p>队列FIFO，栈LIFO，用栈实现队列核心要解决如何将栈头元素弹出问题。</p>\n<p>让第一次进栈的元素保持在栈尾？双栈思路。</p>\n<p>在pop&#x2F;top时操作，将当前所有元素都转移到新栈上。</p>\n<p>注意这里有个tracky，新栈总是在为空时才从旧栈中补充元素。</p>\n<h3 id=\"题225：用队列实现栈\"><a href=\"#题225：用队列实现栈\" class=\"headerlink\" title=\"题225：用队列实现栈\"></a>题225：用队列实现栈</h3><p>push时操作，将新push进队列的元素置于front位置，可通过循环将其他元素pop再push的方式。</p>\n<h3 id=\"题20：有效的括号\"><a href=\"#题20：有效的括号\" class=\"headerlink\" title=\"题20：有效的括号\"></a>题20：有效的括号</h3><p>校验括号的方法：左括号进栈，右括号遇到匹配的左括号，则左括号弹栈，否则右括号进栈。</p>\n<h3 id=\"题1047：删除字符串中的所以相邻重复项\"><a href=\"#题1047：删除字符串中的所以相邻重复项\" class=\"headerlink\" title=\"题1047：删除字符串中的所以相邻重复项\"></a>题1047：删除字符串中的所以相邻重复项</h3><p>和上述题一样，相同的消掉，不同的入栈，最后反转下栈内元素输出即可。</p>\n<h3 id=\"题150：逆波兰表达式求值\"><a href=\"#题150：逆波兰表达式求值\" class=\"headerlink\" title=\"题150：逆波兰表达式求值\"></a>题150：逆波兰表达式求值</h3><p>思路：如果时数字，压栈，如果是符号，弹出两个数字，计算，再压栈。</p>\n<h3 id=\"题239：滑动窗口最大值\"><a href=\"#题239：滑动窗口最大值\" class=\"headerlink\" title=\"题239：滑动窗口最大值\"></a>题239：滑动窗口最大值</h3><p>看着简单，操作起来有点难度。</p>\n<p>思路：优先队列，它能解决区间最大值的问题。但还要考虑：</p>\n<ul>\n<li>如何删除区间的第一个值问题</li>\n</ul>\n<p>这里就有一个位置信息需要在优先队列里保留，方法：</p>\n<ul>\n<li>设置队列节点为&lt;nums[i], [i]&gt;的pair对</li>\n</ul>\n<p>那么必须要始终确保优先队列的长度为窗口大小吗？不用。其实只要确保当前队列里的top仍然在窗口内，那么top就不需要摘除，保留即可，其他比top小的窗口外元素不影响。</p>\n<h3 id=\"题347：前k个高频元素\"><a href=\"#题347：前k个高频元素\" class=\"headerlink\" title=\"题347：前k个高频元素\"></a>题347：前k个高频元素</h3><p>前k个 –&gt; 优先队列，返回高频元素，所以队列元素设计为&lt;频率,元素&gt;pair，为了得到这种pair，还需要使用map收集。</p>\n<p>这块还需要重写优先队列的排序方式，只用频率排序。</p>\n<h2 id=\"二叉树\"><a href=\"#二叉树\" class=\"headerlink\" title=\"二叉树\"></a>二叉树</h2><h3 id=\"题144-145-94：二叉树遍历\"><a href=\"#题144-145-94：二叉树遍历\" class=\"headerlink\" title=\"题144&#x2F;145&#x2F;94：二叉树遍历\"></a>题144&#x2F;145&#x2F;94：二叉树遍历</h3><p>前序：中左右</p>\n<p>中序：左中右</p>\n<p>后序：左右中</p>\n<p>可以看出，前后是基于树的高来讲，root在树顶点，那么它就是前，树的叶子节点就是后。</p>\n<h3 id=\"题102：层序遍历\"><a href=\"#题102：层序遍历\" class=\"headerlink\" title=\"题102：层序遍历\"></a>题102：层序遍历</h3><p>从上到下输出，前序</p>\n<p>遍历是深度的，所以还需要辅助信息，也就是层高</p>\n<p>层高对应到数组索引</p>\n<p>所以思路1：深度优先搜索</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">levelOrder</span>(TreeNode* root) &#123;</span><br><span class=\"line\">        vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; res;</span><br><span class=\"line\">        <span class=\"built_in\">traversal</span>(root, <span class=\"number\">0</span>, res);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">traversal</span><span class=\"params\">(TreeNode* node, <span class=\"type\">int</span> level, vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt;&amp; res)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (res.<span class=\"built_in\">size</span>() &lt;= level) &#123;</span><br><span class=\"line\">            vector&lt;<span class=\"type\">int</span>&gt; ele;</span><br><span class=\"line\">            res.<span class=\"built_in\">push_back</span>(ele);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        res[level].<span class=\"built_in\">push_back</span>(node-&gt;val);  <span class=\"comment\">// 深度遍历到对应层级时加入对应的数组内</span></span><br><span class=\"line\">        <span class=\"built_in\">traversal</span>(node-&gt;left, level + <span class=\"number\">1</span>, res);</span><br><span class=\"line\">        <span class=\"built_in\">traversal</span>(node-&gt;right, level + <span class=\"number\">1</span>, res);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>思路2：广度优先搜索的层序版</p>\n<p>通过辅助的队列来实现。队列的职责是保存每一层的节点：</p>\n<ul>\n<li>检查队列是否为空</li>\n<li><strong>全部遍历</strong>，依次弹出，取这些节点的左右节点重新入队列</li>\n<li>如此循环</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">levelOrder</span>(TreeNode* root) &#123;</span><br><span class=\"line\">        vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; res;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        queue&lt;TreeNode*&gt; q;</span><br><span class=\"line\">        q.<span class=\"built_in\">push</span>(root);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!q.<span class=\"built_in\">empty</span>()) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> levelsize = q.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">            res.<span class=\"built_in\">push_back</span>(<span class=\"built_in\">vector</span>&lt;<span class=\"type\">int</span>&gt;());</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; levelsize; i++) &#123;  <span class=\"comment\">// 广度优先搜索不需要这一层</span></span><br><span class=\"line\">                TreeNode* cur = q.<span class=\"built_in\">front</span>();</span><br><span class=\"line\">                q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">                res.<span class=\"built_in\">back</span>().<span class=\"built_in\">push_back</span>(cur-&gt;val);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (cur-&gt;left != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">                    q.<span class=\"built_in\">push</span>(cur-&gt;left);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (cur-&gt;right != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">                    q.<span class=\"built_in\">push</span>(cur-&gt;right);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>这里要注意一个细节，即层序遍历不是广度优先搜索。广度优先是1个节点1个节点逐个往下走，它没有层的信息，而层序遍历是将层的信息显性化出来。</p>\n</blockquote>\n<p><strong>变式题107：要求返回从底向上的层序遍历</strong></p>\n<p>思路：基于常规层序遍历将res翻转下。</p>\n<p>有其他思路吗？没有，官方题解本质仍然是翻转，只是在while循环中翻转和循环完翻转的问题。</p>\n<p><strong>变式题199：二叉树的右视图</strong></p>\n<p>思路1：层序，保留每一层的最优节点值。</p>\n<p>思路2：层序或dfs，在最后res中取back值。</p>\n<p><strong>变式题637：二叉树的层平均值</strong></p>\n<p>同样的做法，层序遍历时求平均。</p>\n<p><strong>变式题429：N叉树的层序遍历</strong></p>\n<p>只需要改造left、right为for children即可。</p>\n<p><strong>变式题515：二叉树的层最大值</strong></p>\n<p>同样的做法，层序遍历求最大。</p>\n<p><strong>变式题116：填充每个节点的下一个右侧节点</strong></p>\n<p>层序，在遍历时做好前后节点的next关联。</p>\n<p><strong>变式题104：二叉树的最大深度</strong></p>\n<p>思路1：层序，为层计数。</p>\n<p>思路2：深度DFS，可以不用辅助函数。</p>\n<p><strong>变式题559：N叉树的最大深度</strong></p>\n<p>思路类似，深度遍历，每下钻一层加1。</p>\n<p><strong>变式题111：二叉树的最小深度</strong></p>\n<p>思路：层序，当left、right都为空时直接返回。</p>\n<h3 id=\"题226：翻转二叉树\"><a href=\"#题226：翻转二叉树\" class=\"headerlink\" title=\"题226：翻转二叉树\"></a>题226：翻转二叉树</h3><p>思路：深度遍历，无需辅助函数，直接翻转（这里可以选择前序，也可以选择后序）。</p>\n<h3 id=\"题101：对称二叉树\"><a href=\"#题101：对称二叉树\" class=\"headerlink\" title=\"题101：对称二叉树\"></a>题101：对称二叉树</h3><p>思路：层序遍历，弹出单层数组，判断是否对称。这里有个处理技巧，就是单层元素不按从左到右加入队列，而是两端对称加入；每次循环弹出2个节点进行比较。</p>\n<h3 id=\"题222：完全二叉树的节点个数\"><a href=\"#题222：完全二叉树的节点个数\" class=\"headerlink\" title=\"题222：完全二叉树的节点个数\"></a>题222：完全二叉树的节点个数</h3><p>参考二叉树的最大深度解法，通过DFS来解。</p>\n<p>因为二叉树的性质，这里还有一种二分查找的解法，先算出有多少层，然后再二分叶子节点。</p>\n<h3 id=\"题110：平衡二叉树\"><a href=\"#题110：平衡二叉树\" class=\"headerlink\" title=\"题110：平衡二叉树\"></a>题110：平衡二叉树</h3><p>平衡的性质是左右子树的高相差小于等于1</p>\n<ul>\n<li>首先要能算出高</li>\n<li>其次是判断是否满足小于等于1的条件</li>\n</ul>\n<h3 id=\"题257：二叉树的所有路径\"><a href=\"#题257：二叉树的所有路径\" class=\"headerlink\" title=\"题257：二叉树的所有路径\"></a>题257：二叉树的所有路径</h3><p>深度优先搜索，本质也是使用回溯的方法，设计好输入、截止条件即可。</p>\n<h3 id=\"题513：找树左下角的值\"><a href=\"#题513：找树左下角的值\" class=\"headerlink\" title=\"题513：找树左下角的值\"></a>题513：找树左下角的值</h3><p>左下角，高度最大，最左</p>\n<p>深度遍历需要带上这两个状态，同时要带上answer（当前高度，当前值）</p>\n<p>如果新遍历的比当前高度高，则刷新answer。</p>\n<p>处理细节：是否为左节点的状态可以去掉，转为由height &gt; answer.curHeight代替，原因：height递增时的首次遍历的节点一定是左节点（通过由先遍历左子树再遍历右子树的方式控制）。</p>\n<h3 id=\"题112：路径之和\"><a href=\"#题112：路径之和\" class=\"headerlink\" title=\"题112：路径之和\"></a>题112：路径之和</h3><p>求路径和，判断是否等于目标值。</p>\n<p>路径和 &#x3D; DFS + sum累加，遇到叶子节点后截止。</p>\n<h3 id=\"题106：已知中后序，构造二叉树\"><a href=\"#题106：已知中后序，构造二叉树\" class=\"headerlink\" title=\"题106：已知中后序，构造二叉树\"></a>题106：已知中后序，构造二叉树</h3><p>特征：后序的最后1个元素总是根节点。</p>\n<p>步骤：</p>\n<ul>\n<li>后序数组倒序遍历，选取的元素拿到中序遍历中做边界，分出左右子树数组</li>\n<li>递归构造左子树数组</li>\n<li>递归构造右子树数组</li>\n<li>左右子树拼接到当前的根节点</li>\n</ul>\n<p>因为涉及元素到index的查询，所以，构造1个（元素，index）的map加快索引。</p>\n<h3 id=\"题654：最大二叉树\"><a href=\"#题654：最大二叉树\" class=\"headerlink\" title=\"题654：最大二叉树\"></a>题654：最大二叉树</h3><p>这道题跟题106类似，递归，选出根节点，构造左右子树，拼接到根节点即可。</p>\n<h3 id=\"题617：合并二叉树\"><a href=\"#题617：合并二叉树\" class=\"headerlink\" title=\"题617：合并二叉树\"></a>题617：合并二叉树</h3><p>合并二叉树的逻辑也是构造左右子树，拼接到根节点。</p>\n<h3 id=\"题700：二叉搜索树\"><a href=\"#题700：二叉搜索树\" class=\"headerlink\" title=\"题700：二叉搜索树\"></a>题700：二叉搜索树</h3><p>深度遍历即可，小于往左，大于往右。</p>\n<h3 id=\"题98：验证二叉搜索树\"><a href=\"#题98：验证二叉搜索树\" class=\"headerlink\" title=\"题98：验证二叉搜索树\"></a>题98：验证二叉搜索树</h3><p>需满足两条规则：</p>\n<ul>\n<li>当前节点比左节点大，比右节点小；</li>\n<li>当前节点要小于或大于整体子树的区间范围，比如[5,4,7,null,null,3,9]，3比4小，false</li>\n</ul>\n<blockquote>\n<p>搜索树有个特征：不存在两个节点的值重复。</p>\n</blockquote>\n<h3 id=\"题530：二叉搜索树的最小差值\"><a href=\"#题530：二叉搜索树的最小差值\" class=\"headerlink\" title=\"题530：二叉搜索树的最小差值\"></a>题530：二叉搜索树的最小差值</h3><p>注意题目要求是任意两节点，非相邻节点。但实际根据树的性质，最小值只会存在于<strong>中序遍历</strong>下相邻的两个节点（因为中序遍历将得到1个递增序列）。</p>\n<p>中序遍历需具有以下状态：前一个节点的值，当前的最小值。</p>\n<h3 id=\"题501：二叉搜索树的众数\"><a href=\"#题501：二叉搜索树的众数\" class=\"headerlink\" title=\"题501：二叉搜索树的众数\"></a>题501：二叉搜索树的众数</h3><p>这道题的二叉树定义为节点值可重复。</p>\n<p>仍然按中序遍历，因为是递增序列，所以在遍历时保存前一个节点值preval，该值的count，当前的最大count，以及当前的最大countVals（因为要返回具体的val值）</p>\n<p>官方解答对首次处理中序有一个比较晦涩的点：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> preval, <span class=\"type\">int</span> curCount, <span class=\"type\">int</span> maxCount</span><br><span class=\"line\"></span><br><span class=\"line\">dfs <span class=\"comment\">// 前序</span></span><br><span class=\"line\"><span class=\"comment\">// 中序，注意看这里省略了对preval未初始化情况的处理</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (node-&gt;val == preval) &#123;</span><br><span class=\"line\">  curCount++; </span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  curCount = <span class=\"number\">1</span>;</span><br><span class=\"line\">  preval = node-&gt;val;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>更直观的写法：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> preNode, <span class=\"type\">int</span> curCount, <span class=\"type\">int</span> maxCount</span><br><span class=\"line\">dfs <span class=\"comment\">// 前序</span></span><br><span class=\"line\"><span class=\"comment\">// 中序</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (preNode == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">  curCount = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (preNode-&gt;val == node-&gt;val) &#123;</span><br><span class=\"line\">  curCount++;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  curCount = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">preNode = node;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，直观的写法中，if elseif块内的处理是一致的，故官方解法直接将二者合并为1个，无论preval是什么。</p>\n<h3 id=\"题236：二叉树的最近公共祖先\"><a href=\"#题236：二叉树的最近公共祖先\" class=\"headerlink\" title=\"题236：二叉树的最近公共祖先\"></a>题236：二叉树的最近公共祖先</h3><p>最近公共祖先的特征：</p>\n<ul>\n<li>该祖先的下一个node-&gt;left和node-&gt;right必有一方不是祖先</li>\n</ul>\n<p>所以在搜索时，可以先探查左右子树，如果同时为空，则说明该节点不包含目标；如果同时不为空，则说明该节点就是二者的公共祖先；如果一方为空、一方不为空，为空的子树没有包含目标，往不为空的搜索。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">TreeNode* <span class=\"title\">lowestCommonAncestor</span><span class=\"params\">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span> || root == p || root == q) <span class=\"keyword\">return</span> root;</span><br><span class=\"line\"></span><br><span class=\"line\">        TreeNode* left = <span class=\"built_in\">lowestCommonAncestor</span>(root-&gt;left, p, q);</span><br><span class=\"line\">        TreeNode* right = <span class=\"built_in\">lowestCommonAncestor</span>(root-&gt;right, p, q);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (left == <span class=\"literal\">nullptr</span> &amp;&amp; right == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (left != <span class=\"literal\">nullptr</span> &amp;&amp; right != <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (left == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> right;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (right == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> left;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"题701：二叉树的插入操作\"><a href=\"#题701：二叉树的插入操作\" class=\"headerlink\" title=\"题701：二叉树的插入操作\"></a>题701：二叉树的插入操作</h3><p>思路：找到节点要插入的位置，挂上去，这种适合前序遍历。</p>\n<p>首先判断节点是否为null，是则构造一个当前val的节点返回；否则对left、right进行遍历，并对返回值重新挂载到root。</p>\n<h3 id=\"题450：二叉树的删除操作\"><a href=\"#题450：二叉树的删除操作\" class=\"headerlink\" title=\"题450：二叉树的删除操作\"></a>题450：二叉树的删除操作</h3><p>类似插入操作，同样是找到节点，然后执行删除：</p>\n<ul>\n<li>如果左右子树均为空，返回空</li>\n<li>如果左子树为空，返回右子树</li>\n<li>如果右子树为空，返回左子树</li>\n<li>如果都不为空，则找到右子树的最左节点，把当前左子树挂到这个节点上，然后返回右子树</li>\n</ul>\n<h3 id=\"题669：修剪二叉搜索树\"><a href=\"#题669：修剪二叉搜索树\" class=\"headerlink\" title=\"题669：修剪二叉搜索树\"></a>题669：修剪二叉搜索树</h3><p>区间描述要保留的节点，中序遍历，一路trim节点，trim规则：</p>\n<ul>\n<li>小于左边界的，trim左子树</li>\n<li>大于右边界的，trim右子树</li>\n<li>满足区间内的，左子树的trim结果挂到左节点，右子树的trim结果挂到右节点（整体结构上只会有边界节点会变化）</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">TreeNode* <span class=\"title\">trimBST</span><span class=\"params\">(TreeNode* root, <span class=\"type\">int</span> low, <span class=\"type\">int</span> high)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root-&gt;val &lt; low) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">trimBST</span>(root-&gt;right, low, high);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root-&gt;val &gt; high) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">trimBST</span>(root-&gt;left, low, high);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        root-&gt;left = <span class=\"built_in\">trimBST</span>(root-&gt;left, low, high);</span><br><span class=\"line\">        root-&gt;right = <span class=\"built_in\">trimBST</span>(root-&gt;right, low, high);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"题108：有序数组转平衡二叉树\"><a href=\"#题108：有序数组转平衡二叉树\" class=\"headerlink\" title=\"题108：有序数组转平衡二叉树\"></a>题108：有序数组转平衡二叉树</h3><p>二分查找，每个被发现的中间元素作为root节点，而二分本身能够确保树平衡。</p>\n<h3 id=\"题538：二叉树转换为累加树\"><a href=\"#题538：二叉树转换为累加树\" class=\"headerlink\" title=\"题538：二叉树转换为累加树\"></a>题538：二叉树转换为累加树</h3><p>二叉树转为递减数组，每次遍历累加前一个节点的值</p>\n<p>如果实现递减遍历？通过颠倒的中序遍历来做。</p>\n<p>遍历过程需要维护一个<a href=\"\">currentSum</a>值。</p>\n<h2 id=\"回溯\"><a href=\"#回溯\" class=\"headerlink\" title=\"回溯\"></a>回溯</h2><h3 id=\"题77：组合\"><a href=\"#题77：组合\" class=\"headerlink\" title=\"题77：组合\"></a>题77：组合</h3><p>这道题有两种写法，第一种是带有for循环的：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">combine</span>(<span class=\"type\">int</span> n, <span class=\"type\">int</span> k) &#123;</span><br><span class=\"line\">        vector&lt;<span class=\"type\">int</span>&gt; curVec;</span><br><span class=\"line\">        vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; res;</span><br><span class=\"line\">        <span class=\"built_in\">backtracking</span>(n, k, <span class=\"number\">1</span>, curVec, res);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">backtracking</span><span class=\"params\">(<span class=\"type\">int</span> n, <span class=\"type\">int</span> k, <span class=\"type\">int</span> start, vector&lt;<span class=\"type\">int</span>&gt;&amp; curVec, vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt;&amp; res)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (curVec.<span class=\"built_in\">size</span>() == k) &#123;</span><br><span class=\"line\">            res.<span class=\"built_in\">emplace_back</span>(curVec);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = start; i &lt;= n; i++) &#123;</span><br><span class=\"line\">            curVec.<span class=\"built_in\">push_back</span>(i);</span><br><span class=\"line\">            <span class=\"built_in\">backtracking</span>(n, k, i + <span class=\"number\">1</span>, curVec, res);</span><br><span class=\"line\">            curVec.<span class=\"built_in\">pop_back</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>第二种是不带for循环的：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">combine</span>(<span class=\"type\">int</span> n, <span class=\"type\">int</span> k) &#123;</span><br><span class=\"line\">        vector&lt;<span class=\"type\">int</span>&gt; curVec;</span><br><span class=\"line\">        vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; res;</span><br><span class=\"line\">        <span class=\"built_in\">backtracking</span>(n, k, <span class=\"number\">1</span>, curVec, res);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">backtracking</span><span class=\"params\">(<span class=\"type\">int</span> n, <span class=\"type\">int</span> k, <span class=\"type\">int</span> cur, vector&lt;<span class=\"type\">int</span>&gt;&amp; curVec, vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt;&amp; res)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (curVec.<span class=\"built_in\">size</span>() + n - cur + <span class=\"number\">1</span> &lt; k) &#123;  <span class=\"comment\">// 这里做了剪枝处理，表示如果当前数组长度+剩余待遍历区间长度小于k时，跳过不遍历，因为没必要</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (curVec.<span class=\"built_in\">size</span>() == k) &#123;</span><br><span class=\"line\">            res.<span class=\"built_in\">emplace_back</span>(curVec);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cur == n + <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        curVec.<span class=\"built_in\">push_back</span>(cur);</span><br><span class=\"line\">        <span class=\"built_in\">backtracking</span>(n, k, cur + <span class=\"number\">1</span>, curVec, res);</span><br><span class=\"line\">        curVec.<span class=\"built_in\">pop_back</span>();</span><br><span class=\"line\">        <span class=\"built_in\">backtracking</span>(n, k, cur + <span class=\"number\">1</span>, curVec, res);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>以上存在一个细节，在回收结果处，使用了emplace_back来copy数组</p>\n<p>其他方案有：</p>\n<ul>\n<li>入参不带&amp;，而使用copy：backtracking(int n, int k, int cur, vector&lt;int&gt; curVec, vector&lt;vector&lt;int&gt;&gt;&amp; res)</li>\n<li>入参带&amp;，在回收结果时，自行构造一个新vector拷贝curVec</li>\n</ul>\n<p>实验证明，上述两种都不高效，且第一种方案内存使用异常高，是最优方案的10倍。</p>\n<p><strong>变式题216：组合总和3</strong></p>\n<p>这道题同样求组合，加了1个约束，要求组合的总和要等于指定值。</p>\n<p>思路：遍历所有组合，维护当前总和值，如果等于指定值且组合的size等于指定size，则返回，否则回溯。</p>\n<p>剪枝细节：同上道题，vec长度+区间长度 &lt; 指定长度或者 vec长度大于指定长度的，无需遍历，直接返回。</p>\n<p><strong>变式题39：组合总和</strong></p>\n<p>这道题的约束为，不限制给定数组中的某个数被选择几次，找出所有能够求和等于target值的组合。</p>\n<p>类似题目：爬楼梯，可选的一步台阶范围类比这里给定的数组。</p>\n<p>解法（更适合不具有for循环的递归）</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">backtracking</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; candidates, <span class=\"type\">int</span> index, <span class=\"type\">int</span> target, vector&lt;<span class=\"type\">int</span>&gt;&amp; curVec, vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt;&amp; res)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index == candidates.<span class=\"built_in\">size</span>()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (target == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        res.<span class=\"built_in\">emplace_back</span>(curVec);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 跳过不使用candidates[index]</span></span><br><span class=\"line\">    <span class=\"built_in\">backtracking</span>(candidates, index + <span class=\"number\">1</span>, target, curVec, res);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 使用candicates[index]</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (target - candidates[index] &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        curVec.<span class=\"built_in\">emplace_back</span>(candidates[index]);</span><br><span class=\"line\">        <span class=\"built_in\">backtracking</span>(candidates, index, target - candidates[index], curVec, res);</span><br><span class=\"line\">        curVec.<span class=\"built_in\">pop_back</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>变式题40：组合总和2</strong></p>\n<p>这道题放宽了对给定数组的约束，允许数组内有元素重复，并且，结果要求不可重复，且每个元素只能被用一次。</p>\n<p>对于只能被用一次这条，正常组合解法已覆盖。</p>\n<p>对于结果要求不可重复这条，需要做两个步骤：</p>\n<ul>\n<li>对给定数组排序</li>\n<li>带for循环递归时，检查前后两个元素是否相同，是则跳过</li>\n</ul>\n<p>剪枝细节：如果target - 当前元素小于0，可以直接break，无需继续遍历。</p>\n<h3 id=\"题17：电话号码的字母组合\"><a href=\"#题17：电话号码的字母组合\" class=\"headerlink\" title=\"题17：电话号码的字母组合\"></a>题17：电话号码的字母组合</h3><p>这道题求的是多组字母内分别取1的组合，之前的题型则为1组数内取k的组合。</p>\n<p>多组取1，对上述1组取多进行变式：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">backtracking</span><span class=\"params\">(vector&lt;string&gt;&amp; digitLetters <span class=\"comment\">/* 多组取1 */</span>, <span class=\"type\">int</span> index <span class=\"comment\">/* 指向哪一组 */</span>, string&amp; curStr, vector&lt;string&gt;&amp; res)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (curStr.<span class=\"built_in\">size</span>() == digitLetters.<span class=\"built_in\">size</span>()) &#123;</span><br><span class=\"line\">        res.<span class=\"built_in\">emplace_back</span>(curStr);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; digitLetters[index].<span class=\"built_in\">size</span>(); i++) &#123;  <span class=\"comment\">// 遍历每一组内的所有字母</span></span><br><span class=\"line\">        curStr.<span class=\"built_in\">push_back</span>(digitLetters[index][i]);</span><br><span class=\"line\">        <span class=\"built_in\">backtracking</span>(digitLetters, index + <span class=\"number\">1</span>, curStr, res);</span><br><span class=\"line\">        curStr.<span class=\"built_in\">pop_back</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"题131：回文字符串\"><a href=\"#题131：回文字符串\" class=\"headerlink\" title=\"题131：回文字符串\"></a>题131：回文字符串</h3><p>遍历字符串，选择步长，可以是1，2，3等，检查该子串是否符合，如果符合，加入结果；如果不符合，继续往大步长遍历。</p>\n<p>每次处理完当前子串后，对剩余的子串做相同动作（回溯）</p>\n<p>将这个过程具象化为一张横纵回溯图，如下所示：</p>\n<p><img src=\"https://camo.githubusercontent.com/0e9d7097c5f8a06d6ee1a6fd0ab110e981442669d0dbcdeb6d5e25ef615d5f1a/68747470733a2f2f636f64652d7468696e6b696e672e63646e2e626365626f732e636f6d2f706963732f3133312e2545352538382538362545352538392542322545352539422539452545362539362538372545342542382542322e6a7067\" alt=\"image\"></p>\n<p>横向对当前子串的区间放大，并分别判断</p>\n<p>纵向对剩余子串做同等处理</p>\n<h3 id=\"题93：复原IP地址\"><a href=\"#题93：复原IP地址\" class=\"headerlink\" title=\"题93：复原IP地址\"></a>题93：复原IP地址</h3><p>和回文串类似，对当前子串长度进行遍历，对剩余子串进行回溯。</p>\n<p>这里唯一要注意下对子串的合法性进行校验。</p>\n<h3 id=\"题78：子集\"><a href=\"#题78：子集\" class=\"headerlink\" title=\"题78：子集\"></a>题78：子集</h3><p>和爬楼梯类似，无需for循环，分考虑当前位置、不考虑当前位置两种场景进行回溯。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">subsets</span>(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums) &#123;</span><br><span class=\"line\">        vector&lt;<span class=\"type\">int</span>&gt; subset;</span><br><span class=\"line\">        vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; res;</span><br><span class=\"line\">        <span class=\"built_in\">backtracking</span>(nums, <span class=\"number\">0</span>, subset, res);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">backtracking</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> start, vector&lt;<span class=\"type\">int</span>&gt;&amp; subset, vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt;&amp; subsets)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (start &gt;= nums.<span class=\"built_in\">size</span>()) &#123;</span><br><span class=\"line\">            subsets.<span class=\"built_in\">emplace_back</span>(subset);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        subset.<span class=\"built_in\">push_back</span>(nums[start]);</span><br><span class=\"line\">        <span class=\"built_in\">backtracking</span>(nums, start + <span class=\"number\">1</span>, subset, subsets);</span><br><span class=\"line\">        subset.<span class=\"built_in\">pop_back</span>();</span><br><span class=\"line\">        <span class=\"built_in\">backtracking</span>(nums, start + <span class=\"number\">1</span>, subset, subsets);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>思考：什么时候回溯需要for循环，什么时候不用？</p>\n<p>其实这道题也可以套for循环：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">subsets</span>(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums) &#123;</span><br><span class=\"line\">        vector&lt;<span class=\"type\">int</span>&gt; subset;</span><br><span class=\"line\">        vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; res;</span><br><span class=\"line\">        <span class=\"built_in\">backtracking</span>(nums, <span class=\"number\">0</span>, subset, res);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">backtracking</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> startIndex, vector&lt;<span class=\"type\">int</span>&gt;&amp; subset, vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt;&amp; subsets)</span> </span>&#123;</span><br><span class=\"line\">        subsets.<span class=\"built_in\">push_back</span>(subset); <span class=\"comment\">// 收集子集，要放在终止添加的上面，否则会漏掉自己</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (startIndex &gt;= nums.<span class=\"built_in\">size</span>()) &#123; <span class=\"comment\">// 终止条件可以不加</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = startIndex; i &lt; nums.<span class=\"built_in\">size</span>(); i++) &#123;</span><br><span class=\"line\">            subset.<span class=\"built_in\">push_back</span>(nums[i]);</span><br><span class=\"line\">            <span class=\"built_in\">backtracking</span>(nums, i + <span class=\"number\">1</span>, subset, subsets);</span><br><span class=\"line\">            subset.<span class=\"built_in\">pop_back</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>相比第一种没有for循环写法，具有for循环的写法明显不那么直观。</p>\n<p><strong>变式题90：子集2</strong></p>\n<p>相比上道题，这道题给定的数组元素重复，求不重复的子集。</p>\n<p>解法和<strong>组合求和2</strong>一致，先排序，再回溯，检测前后重复的跳过。</p>\n<h3 id=\"题491：非递减子序列\"><a href=\"#题491：非递减子序列\" class=\"headerlink\" title=\"题491：非递减子序列\"></a>题491：非递减子序列</h3><p>给定数组，带重复元素，找所有非递减子序列。</p>\n<p>这道题特殊之处在于需要给子序列回溯加限定条件：</p>\n<ul>\n<li>当前元素比序列中最后1个元素大的，不考虑</li>\n<li>当前元素已经在之前用过的，不考虑（使用set数据结构，保存本层当前元素）</li>\n</ul>\n<p>比如[4,7,6,7]：4回溯，7回溯，6跳过，7跳过</p>\n<h3 id=\"题46：全排列\"><a href=\"#题46：全排列\" class=\"headerlink\" title=\"题46：全排列\"></a>题46：全排列</h3><p>push1 push2 push3 &#x3D;&#x3D;&gt; 1,2,3</p>\n<p>push1 push2 pop2 push3 &#x3D;&#x3D;&gt; 1,3,2</p>\n<p>pop掉的元素需要有地方暂存，直接存回数组？—— 可以用1个bool数组标记是否被使用过。</p>\n<p>因为全排列不分前后顺序，所以在每层回溯时都要遍历全部nums数组元素。</p>\n<p><strong>变式题47：全排列2</strong></p>\n<p>给定的nums数组现在具有重复元素了，求全排列。</p>\n<p>重复元素的做法：排序，for循环遇到重复元素，跳过</p>\n<p>这里仅上述判断还不够，因为类似[1,2,2]的答案，2和2重复，但不能跳。</p>\n<p>所以还得再加1个原则：nums[i - 1]被用过，即used[i - 1] &#x3D;&#x3D; false。</p>\n<h2 id=\"贪心\"><a href=\"#贪心\" class=\"headerlink\" title=\"贪心\"></a>贪心</h2><h3 id=\"题455：分发饼干\"><a href=\"#题455：分发饼干\" class=\"headerlink\" title=\"题455：分发饼干\"></a>题455：分发饼干</h3><p>约束：每个人最多获得1块饼干。</p>\n<p>贪心策略：人按胃口排序，饼干按大小排序，遍历每个人，找能满足当前这个人胃口的最小饼干。</p>\n<h3 id=\"题376：摆动序列\"><a href=\"#题376：摆动序列\" class=\"headerlink\" title=\"题376：摆动序列\"></a>题376：摆动序列</h3><p>删除若干元素后形成摆动序列，求序列最长的长度：可以转化为统计峰谷的数量。</p>\n<blockquote>\n<p>这里有个思维误区是：求要删除多少个元素，然后用序列总长 - 要删除的元素，该思路本身没问题，但对前后相等的过渡元素场景不好处理。</p>\n</blockquote>\n<h3 id=\"题53：最大子数组和\"><a href=\"#题53：最大子数组和\" class=\"headerlink\" title=\"题53：最大子数组和\"></a>题53：最大子数组和</h3><p>贪心策略：如果当前数组的sum为负数，则直接丢弃当前数组的sum（使sum置为0），从下一个新的元素开始计数。</p>\n<h3 id=\"题122：买卖股票的最佳时机2\"><a href=\"#题122：买卖股票的最佳时机2\" class=\"headerlink\" title=\"题122：买卖股票的最佳时机2\"></a>题122：买卖股票的最佳时机2</h3><p>贪心策略：求多个不相交的区间，区间的利润不存在负收益，然后对这些区间求和，得到最大利润。</p>\n<p>因为多个不相交无负收益区间之和等价于多个间隔为1的无负收益区间之和，所以问题可以简化相邻元素相减。</p>\n<h3 id=\"题55：跳跃游戏\"><a href=\"#题55：跳跃游戏\" class=\"headerlink\" title=\"题55：跳跃游戏\"></a>题55：跳跃游戏</h3><p>贪心策略：每一个元素都遍历一遍，检查该元素能够跳到的位置，不断统计取最远，如果遍历时发现的当前i指针超过了最远的位置，那就说明后面的元素不可达，return false。</p>\n<h3 id=\"题45：跳跃游戏2\"><a href=\"#题45：跳跃游戏2\" class=\"headerlink\" title=\"题45：跳跃游戏2\"></a>题45：跳跃游戏2</h3><p>这道题保证了一定能跳到终点，求最小步数。</p>\n<p>仍然是每个元素都遍历一遍，检查该元素能够跳到的位置，不断统计取最远。不同的是，在这里面，需要维护一个每次跳的区间。</p>\n<p>比如首次区间就是：start &#x3D; 0, end &#x3D; 1</p>\n<p>后面的区间则为：start &#x3D; end, end &#x3D; rightmost + 1</p>\n<h3 id=\"题1005：K次取反后的数组最大和\"><a href=\"#题1005：K次取反后的数组最大和\" class=\"headerlink\" title=\"题1005：K次取反后的数组最大和\"></a>题1005：K次取反后的数组最大和</h3><p>贪心策略：</p>\n<ul>\n<li>值越小取反收益越大，比如：1 2选1，-2 -1选-2</li>\n<li>都是非负数时，对当前最小值进行反复取反</li>\n</ul>\n<p>简单点可以考虑用最小堆。</p>\n<h3 id=\"题134：加油站\"><a href=\"#题134：加油站\" class=\"headerlink\" title=\"题134：加油站\"></a>题134：加油站</h3><p>能否到终点：对所有剩余油量求和，如果小于0，则无法到终点。</p>\n<p>选起点：该起点应能到达下一站；该起点应剩余油量要足够大（反例：[1,1,3], [1,2,1]，0号加油站不能作为起点，2号可以 &#x3D;&#x3D;&gt;[0,-1,2]）</p>\n<p>如果有1段特别大cost的呢？比如剩余油量：[1,2,-3]，选1号加油站过不去，只能选0号加油站。</p>\n<p>所以问题变为，剩余油量序列，累积子序列不能为负。</p>\n<p>如果出现负数，怎么办？</p>\n<p>思路1：从后往前寻找能填平该负数的index，如果有，那么该index就是起点。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">canCompleteCircuit</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; gas, vector&lt;<span class=\"type\">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> endIndex = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> sumRest = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> minGasRest = INT_MAX;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; gas.<span class=\"built_in\">size</span>(); i++) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> rest = gas[i] - cost[i];</span><br><span class=\"line\">            sumRest += rest;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (sumRest &lt; minGasRest) &#123;</span><br><span class=\"line\">                minGasRest = sumRest;</span><br><span class=\"line\">                endIndex = i;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sumRest &lt; <span class=\"number\">0</span>) &#123;  <span class=\"comment\">// 不能到达终点</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (minGasRest &gt;= <span class=\"number\">0</span>) &#123;  <span class=\"comment\">// 0作为起点就能到达终点</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 0作为起点不能达到终点，缺油，从后面补</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = gas.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>; i &gt;= endIndex + <span class=\"number\">1</span>; i--) &#123;  <span class=\"comment\">// 注意有些答案将endIndex + 1处理为0，原因是即便从后往前重复计算前半段，前半段已经明确缺油，前半段计算进去也找不到补</span></span><br><span class=\"line\">            <span class=\"type\">int</span> rest = gas[i] - cost[i];</span><br><span class=\"line\">            minGasRest += rest;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (minGasRest &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>思路2：借鉴最大子序列和的思路，出现负数时，就需要舍弃这部分，从下一个元素作为新起点。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">canCompleteCircuit</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; gas, vector&lt;<span class=\"type\">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> curSum = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> totalSum = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> start = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; gas.<span class=\"built_in\">size</span>(); i++) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> rest = gas[i] - cost[i];</span><br><span class=\"line\">            curSum += rest;</span><br><span class=\"line\">            totalSum += rest;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (curSum &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                start = i + <span class=\"number\">1</span>;</span><br><span class=\"line\">                curSum = <span class=\"number\">0</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (totalSum &lt; <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;  <span class=\"comment\">// 无解</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> start;  <span class=\"comment\">// 如果有解，一定从子序列之和为非负数开始</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"题135：分发糖果\"><a href=\"#题135：分发糖果\" class=\"headerlink\" title=\"题135：分发糖果\"></a>题135：分发糖果</h3><p>rating为1,2,3的，糖果为1,(1+1),(2+1)，后一个数&#x3D;前一个数+1</p>\n<p>rating为3,2,1的，糖果为(2+1),(1+1),1，前一个数&#x3D;后一个数+1</p>\n<p>推测：正方向遍历</p>\n<p>如果遇到正向递减的，如1,2,3,2,1，是否要跟着减一？不需要，如果减一会丢失的重复元素的位置信息。故正向递减按规则得到1,2,3,1,1</p>\n<p>按倒序规则得到1,1,3,2,1</p>\n<p>两个数组结合取最大值，得到1,2,3,2,1，就是我们最后想要的。</p>\n<p>重复元素怎么办？也适用</p>\n<p>1,2,3,3,3,2,1</p>\n<ul>\n<li>正向：1,2,3,1,1,1,1</li>\n<li>反向：1,1,1,1,3,2,1</li>\n<li>最大：1,2,3,1,3,2,1 &#x3D;&#x3D;&gt; 是最终结果</li>\n</ul>\n<h3 id=\"题860：柠檬水找零\"><a href=\"#题860：柠檬水找零\" class=\"headerlink\" title=\"题860：柠檬水找零\"></a>题860：柠檬水找零</h3><p>贪心思路：拿当前能够满足找零的最大面额去填。</p>\n<h3 id=\"题406：根据身高重建队列\"><a href=\"#题406：根据身高重建队列\" class=\"headerlink\" title=\"题406：根据身高重建队列\"></a>题406：根据身高重建队列</h3><p>这道题有点脑筋急转弯。关键还是要发现队列的规律：</p>\n<ul>\n<li>先按身高排（从高到低），如果身高相等的，按前方高于自身的数量排（从小到大），此时的序列接近直觉</li>\n<li>按上述顺序依次插入到新队列，身高高的总是先插入，身高矮的后插入，插入位置基于当前元素的前面高于自身的数量定，无论插入到哪都不会对当前新队列中已有的元素值造成影响，所以得到的新队列结果就是我们想要的。</li>\n</ul>\n<h3 id=\"题452：用最小数量的箭引爆气球\"><a href=\"#题452：用最小数量的箭引爆气球\" class=\"headerlink\" title=\"题452：用最小数量的箭引爆气球\"></a>题452：用最小数量的箭引爆气球</h3><p>气球区间重叠的可用1支箭射爆，那么问题就变为寻找子集的数量。</p>\n<p>我们对所有气球区间按左边界排序，然后维护1个子集和所有气球区间比对，有更小的子集就更新，最后返回子集数量即可。</p>\n<h3 id=\"题435：无重叠区间\"><a href=\"#题435：无重叠区间\" class=\"headerlink\" title=\"题435：无重叠区间\"></a>题435：无重叠区间</h3><p>两个步骤：</p>\n<ul>\n<li>排序，按右边界大小排（优先参加结束时间早的），如果相等的，选区间长度短的</li>\n<li>遍历，发现有交集就去掉当前区间，计数加1</li>\n</ul>\n<p>另一个思路：</p>\n<ul>\n<li>排序，按左边界大小排，如果相等的，选区间长度短的</li>\n<li>遍历，发现有交集就去掉大的区间，留小区间，计数加1</li>\n</ul>\n<h3 id=\"题763：划分字母空间\"><a href=\"#题763：划分字母空间\" class=\"headerlink\" title=\"题763：划分字母空间\"></a>题763：划分字母空间</h3><p>这道题本质是求重叠子区间的题，但因为字母多，形成的子区间多，求子区间交集较为复杂，为此有一个巧妙的思路：通过遍历字符串，比较当前索引是否等于当前字母的右区间，是则为分割点。</p>\n<h3 id=\"题56：合并区间\"><a href=\"#题56：合并区间\" class=\"headerlink\" title=\"题56：合并区间\"></a>题56：合并区间</h3><p>也是求重叠子区间问题，常规思路，排序，依次遍历，发现有重合的就合并，否则加入结果集返回。</p>\n<h3 id=\"题738：单调递增的数字\"><a href=\"#题738：单调递增的数字\" class=\"headerlink\" title=\"题738：单调递增的数字\"></a>题738：单调递增的数字</h3><p>找规律：从后往前，依次比较，如果出现不符合预期单调的，基于该规则改：比如32改为29，如此反复：4332，4329，4299，3299，2999。</p>\n<h3 id=\"题968：监控二叉树\"><a href=\"#题968：监控二叉树\" class=\"headerlink\" title=\"题968：监控二叉树\"></a>题968：监控二叉树</h3><p>贪心思路：让摄像头数量最少 等价于 让叶子节点尽量不要有摄像头，因为叶子节点放摄像头是非叶子节点的指数倍。</p>\n<p>为实现这种思路，需要对节点的状态分级：</p>\n<ul>\n<li>0：节点无覆盖</li>\n<li>1：节点有摄像头</li>\n<li>2：节点有覆盖</li>\n</ul>\n<p>通过后序遍历，基于每个节点的情况递推该状态值，并按情况放摄像头和计数。</p>\n<h2 id=\"动态规划\"><a href=\"#动态规划\" class=\"headerlink\" title=\"动态规划\"></a>动态规划</h2><h3 id=\"题509：斐波那契数\"><a href=\"#题509：斐波那契数\" class=\"headerlink\" title=\"题509：斐波那契数\"></a>题509：斐波那契数</h3><p>f(2) &#x3D; f(1) + f(0); f(3) &#x3D; f(2) + f(1)；f(0)和f(1)已知，所以直接基于此for循环滚动相加到指定n值即可。</p>\n<p>动态规划在这里面用到的位置为：每次for循环记录n-1 n-2处的值。</p>\n<h3 id=\"题70：爬楼梯\"><a href=\"#题70：爬楼梯\" class=\"headerlink\" title=\"题70：爬楼梯\"></a>题70：爬楼梯</h3><p>n阶楼梯到顶，就有n-1阶楼梯的dp[n-1]种方法 + n-2阶楼梯的dp[n - 2]种方法。</p>\n<p>本质是斐波那契数。</p>\n<p>所以解法和斐波那契数一致。</p>\n<h3 id=\"题746：使用最小花费爬楼梯\"><a href=\"#题746：使用最小花费爬楼梯\" class=\"headerlink\" title=\"题746：使用最小花费爬楼梯\"></a>题746：使用最小花费爬楼梯</h3><p>动态规划数组定义：dp[i] &#x3D; min(dp[i-1] + cost[i-1], dp[i-2] + cost[i-2])</p>\n<p>解释：dp[i]指当前第i阶所花费的最小费用。</p>\n<h3 id=\"题62：不同路径\"><a href=\"#题62：不同路径\" class=\"headerlink\" title=\"题62：不同路径\"></a>题62：不同路径</h3><p>机器人到达mxn矩阵右下角有多少不同路径，定义dp[i][j]，表示到达i,j点有多少不同路径，其等于(i-1,j),(i,j-1)点的路径数之和。</p>\n<p><strong>变式题63：不同路径2</strong></p>\n<p>这道题在mxn矩阵中加了障碍物，整体思路是不变的，核心点在于遇到障碍物后，障碍物位置的dp[i][j]要清零。</p>\n<h3 id=\"题343：整数拆分\"><a href=\"#题343：整数拆分\" class=\"headerlink\" title=\"题343：整数拆分\"></a>题343：整数拆分</h3><p>一个整数i，可以拆分为：</p>\n<ul>\n<li>两个整数，j * (i - j)</li>\n<li>一个整数和再拆分的整数相乘：j * 再拆分(i - j)</li>\n</ul>\n<p>定义dp[i]为整数i的最大乘积</p>\n<p>那么上述再拆分的乘积即为：j * dp[i - j]</p>\n<p>那么整数i的最大乘积即可从上述两种情况中获取：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">max(j * (i - j), j * dp[i - j])</span><br></pre></td></tr></table></figure>\n\n<p>j的取值可以从1到i-1遍历，计算每种拆分j的值，取最大，就得到当前dp[i]最大：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curMax = 0;</span><br><span class=\"line\"><span class=\"keyword\">for</span> j = 1..i-1</span><br><span class=\"line\">\tcurMax = max(curMax, max(j * (i - j), j * dp[i - j]))</span><br><span class=\"line\">dp[i] = curMax</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"题96：不同的二叉搜索树\"><a href=\"#题96：不同的二叉搜索树\" class=\"headerlink\" title=\"题96：不同的二叉搜索树\"></a>题96：不同的二叉搜索树</h3><p>动态规划思路：</p>\n<p>遍历1..n，计算每个数i作为根节点时的二叉树个数，然后求和。</p>\n<p>定义dp[i]，表示以i为根节点时的二叉树个数</p>\n<p>针对每个根节点的取值j，都有dp[j] &#x3D; dp[j-1] * dp[i-j]，得解。</p>\n<h3 id=\"题kama46：01背包\"><a href=\"#题kama46：01背包\" class=\"headerlink\" title=\"题kama46：01背包\"></a>题kama46：01背包</h3><p>定义物品的weight和价值value，求一个给定bagweight容量的背包，可以放入的最大价值。</p>\n<p>这种就是01背包问题，对于每个物品，要么选1个，要么不选</p>\n<p>如果是每个物品可以选多次，那就是完全背包问题。</p>\n<p>背包问题的dp数组定义：dp[j]表示达到重量为j的背包最大可放入的价值。</p>\n<p>递推公式：dp[j] &#x3D; max(dp[j], dp[j - weight[i]] + value[i])</p>\n<p>解释：不选，dp[j]，选，dp[j - weight[i]] + value[i]</p>\n<p>遍历方式：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; weight.<span class=\"built_in\">size</span>(); i++) &#123;  <span class=\"comment\">// 遍历物品</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = bagweight; j &gt;= weight[i]; j--) &#123;  <span class=\"comment\">// 遍历重量</span></span><br><span class=\"line\">\t\tdp[j] = <span class=\"built_in\">max</span>(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"题416：分割等和子集\"><a href=\"#题416：分割等和子集\" class=\"headerlink\" title=\"题416：分割等和子集\"></a>题416：分割等和子集</h3><p>将一个数组分成两部分，要求和相等</p>\n<p>思路：求和，除以2，得到背包的大小target，数组本身既是weight也是value。满足条件：dp[target] &#x3D;&#x3D; target。</p>\n<h3 id=\"题1049：最后一块石头的重量2\"><a href=\"#题1049：最后一块石头的重量2\" class=\"headerlink\" title=\"题1049：最后一块石头的重量2\"></a>题1049：最后一块石头的重量2</h3><p>题目核心问题在于任意石头，不是相邻石头，故需要动态规划。</p>\n<p>思路：两快石头相消，得到石头A-石头B的重量，推导到整个数组就是两个子数组相消得到的最小重量。</p>\n<p>如何得到最小重量？尽量让两个数组之和相等。这就回到上面的题416解法。</p>\n<h3 id=\"题494：目标和\"><a href=\"#题494：目标和\" class=\"headerlink\" title=\"题494：目标和\"></a>题494：目标和</h3><p>回溯：选+，选-，直到pos遍历完， 检查是否等于target</p>\n<p>动态规划：求sum，再添加-，得到target，故公式（设x等于+号和）：x + (sum - x) &#x3D; target，x &#x3D; (sum + target) &#x2F; 2，此时问题转化为：填满背包大小为x的组合有多少种。</p>\n<p>dp[i]定义：填满i大小的背包，有dp[i]种组合。</p>\n<p>递推公式：dp[j] +&#x3D; dp[j - nums[i]]，表示填满0大小背包组合数+填满1大小背包组合数+…</p>\n<h3 id=\"题kama52：完全背包\"><a href=\"#题kama52：完全背包\" class=\"headerlink\" title=\"题kama52：完全背包\"></a>题kama52：完全背包</h3><p>完全背包和01背包的区别是，完全背包可以重复地选择1件物品，而01不行。</p>\n<p>在实现上，为支持1件物品被重复选择，只需要将内层背包循环按从小到大遍历即可。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; weight.<span class=\"built_in\">size</span>(); i++) &#123;  <span class=\"comment\">// 遍历物品</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = weight[i]; j &lt;= bagsize; j++) &#123;  <span class=\"comment\">// 遍历重量，从小到大遍历</span></span><br><span class=\"line\">\t\tdp[j] = <span class=\"built_in\">max</span>(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"题474：一和零\"><a href=\"#题474：一和零\" class=\"headerlink\" title=\"题474：一和零\"></a>题474：一和零</h3><p>字符串数组，每个字符串0和1的数量，本质就是当前字符串元素的重量，0和1的数量分别不能超过m和n，那么m和n即为背包容量。所以这道题本质是背包问题。</p>\n<p>dp[i][j]定义：容量为i的背包A和容量为j的背包B所能承载的最多物品数。</p>\n<h3 id=\"题518：零钱兑换2\"><a href=\"#题518：零钱兑换2\" class=\"headerlink\" title=\"题518：零钱兑换2\"></a>题518：零钱兑换2</h3><p>硬币可重复pick，完全背包问题。</p>\n<p><strong>求组合数，而不是求最大价值。组合数</strong>意味着没有顺序之分。</p>\n<p>dp[j]定义：背包容量为i时的组合数</p>\n<p>递推公式：dp[j] +&#x3D; dp[j - coins[i]]，表示：背包容量为j的组合数 &#x3D; 不加coins[i]当前背包容量为j的组合数 + 新增coins[i]从j-coins[i]继承的组合数</p>\n<p>该递推公式要求dp[0] &#x3D; 1，不能为0，否则后续的推导全部为0。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">背包dp槽位</th>\n<th align=\"left\"><strong>0</strong></th>\n<th align=\"left\"><strong>1</strong></th>\n<th align=\"left\"><strong>2</strong></th>\n<th align=\"left\"><strong>3</strong></th>\n<th align=\"left\"><strong>4</strong></th>\n<th align=\"left\"><strong>5</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">coins[0] &#x3D; 1填充背包</td>\n<td align=\"left\">1</td>\n<td align=\"left\">1</td>\n<td align=\"left\">1</td>\n<td align=\"left\">1</td>\n<td align=\"left\">1</td>\n<td align=\"left\">1</td>\n</tr>\n<tr>\n<td align=\"left\">coins[1] &#x3D; 2填充背包</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\">2&#x3D;dp[0]+dp[2]，更新到当前dp[2]</td>\n<td align=\"left\">2</td>\n<td align=\"left\">3&#x3D;dp[4]+dp[2]，dp[2]前面刚更新为2，所以这里为3</td>\n<td align=\"left\">3</td>\n</tr>\n<tr>\n<td align=\"left\">coins[2] &#x3D; 5填充背包</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\">4</td>\n</tr>\n</tbody></table>\n<h3 id=\"题377：组合总和4\"><a href=\"#题377：组合总和4\" class=\"headerlink\" title=\"题377：组合总和4\"></a>题377：组合总和4</h3><p><strong>本题求排列数，有顺序之分。</strong></p>\n<p>排列数和组合数在for循环有差别：</p>\n<ul>\n<li><strong>如果求组合数就是外层for循环遍历物品，内层for遍历背包</strong>。</li>\n<li><strong>如果求排列数就是外层for遍历背包，内层for循环遍历物品</strong>。</li>\n</ul>\n<p>原因：如果把遍历nums（物品）放在外循环，遍历target的作为内循环的话，举一个例子：计算dp[4]的时候，结果集只有 {1,3} 这样的集合，不会有{3,1}这样的集合，因为nums遍历放在外层，3只能出现在1后面！</p>\n<h3 id=\"题kama57：爬楼梯\"><a href=\"#题kama57：爬楼梯\" class=\"headerlink\" title=\"题kama57：爬楼梯\"></a>题kama57：爬楼梯</h3><p>爬楼梯变式，可以选择小于等于m阶步长，爬n阶大小楼梯。</p>\n<p>背包：n，物品：[1~m]</p>\n<p>递推公式：dp[i] +&#x3D; dp[i - j]，其中i是背包，j是物品</p>\n<p>因为有序，所以背包在外，物品在内。</p>\n<h3 id=\"题322：零钱兑换\"><a href=\"#题322：零钱兑换\" class=\"headerlink\" title=\"题322：零钱兑换\"></a>题322：零钱兑换</h3><p>这道题求的是最小硬币数，前面求的是组合数。</p>\n<p>二者区别在于递推公式的变化。最小硬币数：dp[j] &#x3D; min(dp[j], dp[j - nums[i]] + 1)</p>\n<p>其他注意点：因为是min，所以dp数组初始化为INT_MAX</p>\n<p>在遍历过程中，需规避INT_MAX + 1情况，否则溢出。</p>\n<p>递推公式的源头是dp[0]，应初始化为0。</p>\n<h3 id=\"题279：完全平方数\"><a href=\"#题279：完全平方数\" class=\"headerlink\" title=\"题279：完全平方数\"></a>题279：完全平方数</h3><p>思路和上题一致，求最小数量。只是元素上做了一点区别，不是直接给的，而是要自己做下平方。</p>\n<h3 id=\"题139：单词拆分\"><a href=\"#题139：单词拆分\" class=\"headerlink\" title=\"题139：单词拆分\"></a>题139：单词拆分</h3><p>思路：单词数组中的单词可重复抽取 &#x3D;&#x3D;&gt; 完全背包</p>\n<p>背包：目标字符串。</p>\n<p>dp[j]定义：长度为j的字符串背包是否能被单词数组组合得到。</p>\n<p>有序：遍历背包长度，遍历单词长度</p>\n<p>递推公式：如果单词长度的子串“xxxxx[子串]”在单词数组里，且dp[xxxxx.len] &#x3D;&#x3D; true, 则dp[j] &#x3D; true。</p>\n<p>初始值：dp[0] &#x3D; true，其他为false</p>\n<h3 id=\"题kama56：多重背包\"><a href=\"#题kama56：多重背包\" class=\"headerlink\" title=\"题kama56：多重背包\"></a>题kama56：多重背包</h3><p>01背包限定了物品数量为1，完全背包不限定物品数量，多重背包介于二者之间，限定了物品数量，但不一定为1。</p>\n<p>多重背包符合现实中的逻辑，物品资源是有限个的。</p>\n<p>多重背包可以退化为01背包，只需要将多个物品A展开为每一个物品A。</p>\n<p>所以整体代码框架是不变的，和01背包类似，唯一需要处理的是新增一个内部的for循环：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> bagweight, n;</span><br><span class=\"line\">    cin &gt;&gt; bagweight &gt;&gt; n;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">weights</span><span class=\"params\">(n, <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">values</span><span class=\"params\">(n, <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">nums</span><span class=\"params\">(n, <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) cin &gt;&gt; weights[i];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) cin &gt;&gt; values[i];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) cin &gt;&gt; nums[i];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">dp</span><span class=\"params\">(bagweight + <span class=\"number\">1</span>, <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = bagweight; j &gt;= weights[i]; j--) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 这里要根据物品数量做处理</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> k = <span class=\"number\">1</span>, k &lt; nums[i]; k++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (j - k * weights[i] &lt; <span class=\"number\">0</span>) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                dp[j] = <span class=\"built_in\">max</span>(dp[j], dp[j - k * weights[i]] + k * values[i]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dp[bagweight];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"题198：打家劫舍\"><a href=\"#题198：打家劫舍\" class=\"headerlink\" title=\"题198：打家劫舍\"></a>题198：打家劫舍</h3><p>错误思路：维护一个前面有没有偷的标记，这种思路会导致起始点的偷or不偷不好处理。</p>\n<p>正确思路：偷or不偷，状态依赖。</p>\n<p>dp[i]定义：遍历到第i个物品时的最大金额。</p>\n<p>递推公式：dp[j] &#x3D; max(dp[i - 2] + nums[i], dp[i - 1])，这里就表示了前1个偷or不偷的关系</p>\n<p>初始化：dp[0] &#x3D; nums[0]，dp[1] &#x3D; max(nums[0], nums[1])</p>\n<p>循环：只要1层循环即可，遍历物品。</p>"},{"title":"kubernetes","date":"2024-03-05T15:00:00.000Z","toc":true,"_content":"\n本文尝试部署kubernetes集群，并理解该组件能够做什么，什么时候使用。\n\n<!-- more -->\n\n## 部署集群\n\n假设我们有3台设备，每台设备都已修改过hostname：\n\n```bash\nhostnamectl set-hostname xxxx\n```\n\n并已同步在/etc/hosts里配置了对应的ip hostname映射。\n\nmaster、node01、node02\n\n前置准备（此步骤在所有节点上做）：\n\n```bash\n# This overwrites any existing configuration in /etc/yum.repos.d/kubernetes.repo\ncat <<EOF | sudo tee /etc/yum.repos.d/kubernetes.repo\n[kubernetes]\nname=Kubernetes\nbaseurl=https://pkgs.k8s.io/core:/stable:/v1.29/rpm/\nenabled=1\ngpgcheck=1\ngpgkey=https://pkgs.k8s.io/core:/stable:/v1.29/rpm/repodata/repomd.xml.key\nexclude=kubelet kubeadm kubectl cri-tools kubernetes-cni\nEOF\n\nyum install -y kubelet kubeadm kubectl --disableexcludes=kubernetes\nyum install -y docker\n```\n\n环境准备，包括关闭selinux、关闭swap、关闭防火墙、打开IP forward、修改docker的cgroupfs驱动为systemd、准备docker-shim（此步骤在所有节点上做）：\n\n```bash\nsetenforce 0\nswapoff -a\nsystemctl stop firewalld\nsystemctl disable firewalld\n\ncat <<EOF | sudo tee /etc/sysctl.d/k8s.conf\nnet.bridge.bridge-nf-call-ip6tables = 1\nnet.bridge.bridge-nf-call-iptables = 1\nnet.ipv4.ip_forward = 1\nEOF\nsysctl --system\n\ncat <<EOF | sudo tee /etc/docker/daemon.json\n{\n  \"exec-opts\": [\"native.cgroupdriver=systemd\"],\n  \"log-driver\": \"json-file\",\n  \"log-opts\": {\n    \"max-size\": \"100m\"\n  },\n  \"storage-driver\": \"overlay2\"\n}\nEOF\n\nwget https://github.com/Mirantis/cri-dockerd/releases/download/v0.3.10/cri-dockerd-0.3.10.arm64.tgz\ntar -zxf cri-dockerd-0.3.10.arm64.tgz\ncd cri-dockerd\ninstall cri-dockerd /usr/bin\n\ngit clone https://github.com/Mirantis/cri-dockerd.git\ncd cri-dockerd\ninstall packaging/systemd/* /etc/systemd/system\nsystemctl daemon-reload\nsystemctl restart docker\nsystemctl start cri-docker.socket\n\n# 启动集群服务进程\nsystemctl enable --now kubelet\n```\n\n我们现在在master节点上启动集群：\n\n```bash\nkubeadm init --apiserver-advertise-address=[网卡ip] --pod-network-cidr=10.224.0.0/16\n```\n\n配置.kube/config，否则无法查询集群信息：\n\n```bash\nmkdir ~/.kube\ncp /etc/kubernetes/admin.conf ~/.kube/config\nkubectl get pods --all-namespaces\n```\n\n此时有两个coredns pod应该是pending的，因为它在等待cni插件。\n\n安装cni插件，这里选calico：\n\n> 注意这里calico在arm上有bug，遵循[官网的yml](https://docs.tigera.io/calico/latest/getting-started/kubernetes/quickstart)会安装失败报libpcap.so找不到，跟calico版本有关，原因[见该issue](https://github.com/bettercap/bettercap/issues/98)\n\n```bash\nkubectl create -f https://docs.projectcalico.org/manifests/tigera-operator.yaml\n\nwget https://docs.projectcalico.org/manifests/custom-resources.yaml\nvim custom-resources.yaml\n# 修改cidr为10.244.0.0/16\nkubectl create -f custom-resources.yaml\n```\n\n安装成功后观察coredns是否为running。\n\n如果coredns出现错误，通过kubectl describe coredns-xxxx -n kube-system查到bind 53: permission denied错误，则需要做如下变更：\n\n```bash\nkubectl edit cm coredns -n kube-system\n# 修改为.:1053 {\n#   forward . 8.8.8.8:53\n#   ...\n```\n\n意思是监听1053，再转发到8.8.8.8:53地址。\n\n修改后重启coredns：\n\n```bash\nkubectl delete pod coredns-xxxx -n kube-system\nkubectl delete pod coredns-xxxx -n kube-system\n```\n\n重启后应能正确运行。\n\n剩下的就是join工作节点了：\n\n```bash\n# 在master节点上运行\nkubeadm token create --print-join-command\n# 将输出的命令在其他节点上执行\nkubeadm join 170.70.226.121:6443 --token jalb9p.6os29537lon9befl --discovery-token-ca-cert-hash sha256:923a907a5fb070aad4d91f4e5ce6a5b8c55b8c1d6d6e326eadc8c95eaa8987d2\n# 成功后查询\nkubectl get nodes\n```\n\n应全部ready。\n\n至此集群搭建完成。\n\n## 使用集群\n\n准备一个样例：\n\n数据库部分不在kubernetes上部署，只准备服务部分。\n\n服务采用spring cloud，分几段：\n\n*   服务网关spring cloud gateway\n*   具体处理业务的服务\n\n服务网关将通过rpc调用具体处理业务的服务。\n\n网关和具体服务分开为两个pod\n\n为了接近生产配置，网关设置出2个副本（分散在2个node），具体服务也同样处理。\n\n**Gateway**\n\ngateway作用：\n\n![Spring Cloud Gateway diagram](https://static.spring.io/blog/fombico/20220826/spring-cloud-gateway-diagram.png \"Spring Cloud Gateway diagram\")\n\n官方样例：<https://spring.io/guides/gs/gateway>\n\n```bash\ngit clone https://github.com/spring-guides/gs-gateway.git\ncd gs-gateway/initial\n# 使用idea打开\n```\n\n编写简单的gateway处理，路由到httpbin.org（一个公共的实验站点）。\n\n```java\n@Bean\npublic RouteLocator myRoutes(RouteLocatorBuilder builder) {\n    return builder.routes()\n        .route(p -> p\n            .path(\"/get\")\n            .filters(f -> f.addRequestHeader(\"Hello\", \"World\"))\n            .uri(\"http://httpbin.org:80\"))\n        .build();\n}\n```\n\n示例解释：代理httpbin.org/get请求，新增了一个Hello\\:World消息头字段。\n\n\n> 这种gateway跟nginx的区别？nginx不能做吗？\n\n> gateway相对更灵活，可编程，内置有权限、服务熔断等功能，可以做的事情跟多些。&#x20;\n\n\n**rpc服务**\n\nrpc服务采用阿里的sofa-rpc，示例下载：<https://help.aliyun.com/document_detail/149866.html?spm=a2c4g.152618.0.0.754c480bbGsKic>\n\nrpc调用涉及client和server，server提供interface实现，client调用interface。这里隐含了client和server的工程内需分别放一个interface文件。\n\n工程目录如下：\n\n```bash\n.\n├── myclient-app  # 客户端\n│   ├── app\n│   │   ├── endpoint\n│   │   │   ├── pom.xml\n│   │   │   └── src\n│   │   │       └── main\n│   │   │           ├── java\n│   │   │           │   └── com\n│   │   │           │       └── alipay\n│   │   │           │           └── samples\n│   │   │           │               └── rpc\n│   │   │           │                   ├── SampleRestFacade.java\n│   │   │           │                   └── SampleService.java  # 接口文件\n│   │   │           └── resources\n│   │   └── web\n│   │       ├── pom.xml\n│   │       └── src\n│   │           ├── main\n│   │           │   ├── java\n│   │           │   │   └── com\n│   │           │   │       └── alipay\n│   │           │   │           └── mytestsofa\n│   │           │   │               ├── ReferenceHolder.java  # 获取SampleService实例引用\n│   │           │   │               └── SOFABootWebSpringApplication.java  # 拉起服务，调用SampleService接口\n│   │           │   └── resources\n│   │           │       ├── config\n│   │           │       │   ├── application-dev.properties\n│   │           │       │   ├── application.properties\n│   │           │       │   └── application-test.properties\n│   │           │       ├── logback-spring.xml\n│   │           │       └── static\n│   │           │           └── index.html\n│   │           └── test\n│   │               └── java\n│   └── pom.xml\n└── myserver-app  # 服务端\n    ├── app\n    │   ├── endpoint\n    │   │   ├── pom.xml\n    │   │   └── src\n    │   │       └── main\n    │   │           ├── java\n    │   │           │   └── com\n    │   │           │       └── alipay\n    │   │           │           └── samples\n    │   │           │               └── rpc\n    │   │           │                   ├── impl\n    │   │           │                   │   ├── SampleRestFacadeImpl.java\n    │   │           │                   │   └── SampleServiceImpl.java  # SampleService实现\n    │   │           │                   ├── SampleRestFacade.java\n    │   │           │                   └── SampleService.java  # 如你所见，这里也有一个SampleService接口文件\n    │   │           └── resources\n    │   │               └── META-INF\n    │   │                   └── sofa-rpc\n    │   │                       └── sofa-config.json\n    │   └── web\n    │       ├── pom.xml\n    │       └── src\n    │           ├── main\n    │           │   ├── java\n    │           │   │   └── com\n    │           │   │       └── alipay\n    │           │   │           └── mytestsofa\n    │           │   │               └── SOFABootWebSpringApplication.java  # 仅做拉起服务的动作，为的是让SampleService实例暴露出去\n    │           │   └── resources\n    │           │       ├── config\n    │           │       │   ├── application-dev.properties\n    │           │       │   ├── application.properties\n    │           │       │   └── application-test.properties\n    │           │       ├── logback-spring.xml\n    │           │       └── static\n    │           │           └── index.html\n    │           └── test\n    │               └── java\n    │                   └── com\n    │                       └── alipay\n    │                           └── mytestsofa\n    │                               └── web\n    └── pom.xml\n\n```\n\n本地编译需先配置\\~/.m2/settings.xml指向阿里maven仓库（central仓库是没有pom表描述的这些包的）：<https://help.aliyun.com/document_detail/133192.html?spm=a2c4g.149866.0.0.3a17480bTRbEmC>\n\n> 新版maven默认要求https，这里的settings源为http，可能会碰到网络问题，请修改`external:https:*`中的https为dummy\n\n\n编译好会得到两个可执行jar包，启动方式：\n\n```bash\njava -jar myserver-xxxx-executable.jar\njava -jar myclient-xxxx-executable.jar\n```\n\n**rpc client集成gateway**\n\n思路，定义一个filter，从SampleService获取相关字段，然后concat到httpbin响应里。\n\n这里碰到问题，sofaboot应用有自己的依赖，和spring cloud gateway依赖似乎有冲突，尝试集成二者存在包不匹配导致类找不到的情况。\n\n这块作为遗留问题，以后有时间再解。\n\n**使用spring cloud**\n\n尝试做一次spring cloud组件集成，包括：\n\n*   配置中心：spring cloud config\n*   注册中心：spring cloud eureka\n*   rest接口：spring cloud web\n*   数据映射：mybatis\n*   数据库：mysql\n\n1、配置中心效果：\n\nproduct和order服务[从github上](https://github.com/StaveWu/config-repository)读取配置，并本地运行。\n\nconfig-repository/productService-dev.properties：\n\n```properties\nspring.datasource.driver-class-name=com.mysql.jdbc.Driver\nspring.datasource.url=jdbc:mysql://127.0.0.1:3306/experiment?serverTimezone=UTC&useUnicode=true&characterEncoding=utf8&useSSL=false\nspring.datasource.username=root\nspring.datasource.password=123456\nspring.datasource.type=com.zaxxer.hikari.HikariDataSource\nspring.datasource.hikari.minimum-idle=5\nspring.datasource.hikari.maximum-pool-size=15\nspring.datasource.hikari.auto-commit=true\nspring.datasource.hikari.idle-timeout=30000\nspring.datasource.hikari.pool-name=DatebookHikariCP\nspring.datasource.hikari.max-lifetime=1800000\nspring.datasource.hikari.connection-timeout=30000\nspring.datasource.hikari.connection-test-query=SELECT 1\nmybatis.mapper-locations=classpath:mapper/*.xml\n```\n\n本地product配置：\n\n```properties\nspring.application.name=productService\neureka.client.service-url.defaultZone=http://localhost:8764/eureka/\nspring.cloud.config.discovery.enabled=true\nspring.cloud.config.discovery.service-id=CONFIGCENTER\nspring.cloud.config.profile=dev\nspring.config.import=configserver:http://localhost:8096\n```\n\n上述8096端口有配置中心服务在监听：\n\n```properties\nserver.port=8096\nspring.application.name=configCenter\neureka.client.service-url.defaultZone=http://localhost:8764/eureka/\nspring.cloud.config.server.git.uri=https://github.com/StaveWu/config-repository.git\nspring.cloud.config.server.git.username=stavewu\nspring.cloud.config.server.git.password=******\n```\n\n配置中心服务主要用到了spring cloud config组件Config Server，注解：`@EnableConfigServer`\n\nproduct使用的是Config Client，无需注解。\n\n这样就形成了一条从`product -> config server:8096 -> github/config-repository`的通路。\n\nconfig-repository里有好几个配置文件，product服务怎么知道要拿哪一个？\n\n这里猜测是一种约定：基于spring.appliction.name + spring.cloud.config.profile命名的配置文件将被读取，product服务对应到productService-dev.properties。\n\n2、mybatis效果：\n\n在product配置文件里，通过`mybatis.mapper-locations=classpath:mapper/*.xml`读取到位于resources/mapper下的配置文件；通过`spring.datasource.url=jdbc:mysql://127.0.0.1:3306/experiment?serverTimezone=UTC&useUnicode=true&characterEncoding=utf8&useSSL=false`连接到名为experiment的数据库实例，与配置文件配合形成数据库数据读取加载。\n","source":"_posts/kubernetes.md","raw":"---\ntitle: kubernetes\ndate: 2024/03/05 23:00:00\ntoc: true\ncategories: \n - 云组件\ntags: \n - 虚拟化\n---\n\n本文尝试部署kubernetes集群，并理解该组件能够做什么，什么时候使用。\n\n<!-- more -->\n\n## 部署集群\n\n假设我们有3台设备，每台设备都已修改过hostname：\n\n```bash\nhostnamectl set-hostname xxxx\n```\n\n并已同步在/etc/hosts里配置了对应的ip hostname映射。\n\nmaster、node01、node02\n\n前置准备（此步骤在所有节点上做）：\n\n```bash\n# This overwrites any existing configuration in /etc/yum.repos.d/kubernetes.repo\ncat <<EOF | sudo tee /etc/yum.repos.d/kubernetes.repo\n[kubernetes]\nname=Kubernetes\nbaseurl=https://pkgs.k8s.io/core:/stable:/v1.29/rpm/\nenabled=1\ngpgcheck=1\ngpgkey=https://pkgs.k8s.io/core:/stable:/v1.29/rpm/repodata/repomd.xml.key\nexclude=kubelet kubeadm kubectl cri-tools kubernetes-cni\nEOF\n\nyum install -y kubelet kubeadm kubectl --disableexcludes=kubernetes\nyum install -y docker\n```\n\n环境准备，包括关闭selinux、关闭swap、关闭防火墙、打开IP forward、修改docker的cgroupfs驱动为systemd、准备docker-shim（此步骤在所有节点上做）：\n\n```bash\nsetenforce 0\nswapoff -a\nsystemctl stop firewalld\nsystemctl disable firewalld\n\ncat <<EOF | sudo tee /etc/sysctl.d/k8s.conf\nnet.bridge.bridge-nf-call-ip6tables = 1\nnet.bridge.bridge-nf-call-iptables = 1\nnet.ipv4.ip_forward = 1\nEOF\nsysctl --system\n\ncat <<EOF | sudo tee /etc/docker/daemon.json\n{\n  \"exec-opts\": [\"native.cgroupdriver=systemd\"],\n  \"log-driver\": \"json-file\",\n  \"log-opts\": {\n    \"max-size\": \"100m\"\n  },\n  \"storage-driver\": \"overlay2\"\n}\nEOF\n\nwget https://github.com/Mirantis/cri-dockerd/releases/download/v0.3.10/cri-dockerd-0.3.10.arm64.tgz\ntar -zxf cri-dockerd-0.3.10.arm64.tgz\ncd cri-dockerd\ninstall cri-dockerd /usr/bin\n\ngit clone https://github.com/Mirantis/cri-dockerd.git\ncd cri-dockerd\ninstall packaging/systemd/* /etc/systemd/system\nsystemctl daemon-reload\nsystemctl restart docker\nsystemctl start cri-docker.socket\n\n# 启动集群服务进程\nsystemctl enable --now kubelet\n```\n\n我们现在在master节点上启动集群：\n\n```bash\nkubeadm init --apiserver-advertise-address=[网卡ip] --pod-network-cidr=10.224.0.0/16\n```\n\n配置.kube/config，否则无法查询集群信息：\n\n```bash\nmkdir ~/.kube\ncp /etc/kubernetes/admin.conf ~/.kube/config\nkubectl get pods --all-namespaces\n```\n\n此时有两个coredns pod应该是pending的，因为它在等待cni插件。\n\n安装cni插件，这里选calico：\n\n> 注意这里calico在arm上有bug，遵循[官网的yml](https://docs.tigera.io/calico/latest/getting-started/kubernetes/quickstart)会安装失败报libpcap.so找不到，跟calico版本有关，原因[见该issue](https://github.com/bettercap/bettercap/issues/98)\n\n```bash\nkubectl create -f https://docs.projectcalico.org/manifests/tigera-operator.yaml\n\nwget https://docs.projectcalico.org/manifests/custom-resources.yaml\nvim custom-resources.yaml\n# 修改cidr为10.244.0.0/16\nkubectl create -f custom-resources.yaml\n```\n\n安装成功后观察coredns是否为running。\n\n如果coredns出现错误，通过kubectl describe coredns-xxxx -n kube-system查到bind 53: permission denied错误，则需要做如下变更：\n\n```bash\nkubectl edit cm coredns -n kube-system\n# 修改为.:1053 {\n#   forward . 8.8.8.8:53\n#   ...\n```\n\n意思是监听1053，再转发到8.8.8.8:53地址。\n\n修改后重启coredns：\n\n```bash\nkubectl delete pod coredns-xxxx -n kube-system\nkubectl delete pod coredns-xxxx -n kube-system\n```\n\n重启后应能正确运行。\n\n剩下的就是join工作节点了：\n\n```bash\n# 在master节点上运行\nkubeadm token create --print-join-command\n# 将输出的命令在其他节点上执行\nkubeadm join 170.70.226.121:6443 --token jalb9p.6os29537lon9befl --discovery-token-ca-cert-hash sha256:923a907a5fb070aad4d91f4e5ce6a5b8c55b8c1d6d6e326eadc8c95eaa8987d2\n# 成功后查询\nkubectl get nodes\n```\n\n应全部ready。\n\n至此集群搭建完成。\n\n## 使用集群\n\n准备一个样例：\n\n数据库部分不在kubernetes上部署，只准备服务部分。\n\n服务采用spring cloud，分几段：\n\n*   服务网关spring cloud gateway\n*   具体处理业务的服务\n\n服务网关将通过rpc调用具体处理业务的服务。\n\n网关和具体服务分开为两个pod\n\n为了接近生产配置，网关设置出2个副本（分散在2个node），具体服务也同样处理。\n\n**Gateway**\n\ngateway作用：\n\n![Spring Cloud Gateway diagram](https://static.spring.io/blog/fombico/20220826/spring-cloud-gateway-diagram.png \"Spring Cloud Gateway diagram\")\n\n官方样例：<https://spring.io/guides/gs/gateway>\n\n```bash\ngit clone https://github.com/spring-guides/gs-gateway.git\ncd gs-gateway/initial\n# 使用idea打开\n```\n\n编写简单的gateway处理，路由到httpbin.org（一个公共的实验站点）。\n\n```java\n@Bean\npublic RouteLocator myRoutes(RouteLocatorBuilder builder) {\n    return builder.routes()\n        .route(p -> p\n            .path(\"/get\")\n            .filters(f -> f.addRequestHeader(\"Hello\", \"World\"))\n            .uri(\"http://httpbin.org:80\"))\n        .build();\n}\n```\n\n示例解释：代理httpbin.org/get请求，新增了一个Hello\\:World消息头字段。\n\n\n> 这种gateway跟nginx的区别？nginx不能做吗？\n\n> gateway相对更灵活，可编程，内置有权限、服务熔断等功能，可以做的事情跟多些。&#x20;\n\n\n**rpc服务**\n\nrpc服务采用阿里的sofa-rpc，示例下载：<https://help.aliyun.com/document_detail/149866.html?spm=a2c4g.152618.0.0.754c480bbGsKic>\n\nrpc调用涉及client和server，server提供interface实现，client调用interface。这里隐含了client和server的工程内需分别放一个interface文件。\n\n工程目录如下：\n\n```bash\n.\n├── myclient-app  # 客户端\n│   ├── app\n│   │   ├── endpoint\n│   │   │   ├── pom.xml\n│   │   │   └── src\n│   │   │       └── main\n│   │   │           ├── java\n│   │   │           │   └── com\n│   │   │           │       └── alipay\n│   │   │           │           └── samples\n│   │   │           │               └── rpc\n│   │   │           │                   ├── SampleRestFacade.java\n│   │   │           │                   └── SampleService.java  # 接口文件\n│   │   │           └── resources\n│   │   └── web\n│   │       ├── pom.xml\n│   │       └── src\n│   │           ├── main\n│   │           │   ├── java\n│   │           │   │   └── com\n│   │           │   │       └── alipay\n│   │           │   │           └── mytestsofa\n│   │           │   │               ├── ReferenceHolder.java  # 获取SampleService实例引用\n│   │           │   │               └── SOFABootWebSpringApplication.java  # 拉起服务，调用SampleService接口\n│   │           │   └── resources\n│   │           │       ├── config\n│   │           │       │   ├── application-dev.properties\n│   │           │       │   ├── application.properties\n│   │           │       │   └── application-test.properties\n│   │           │       ├── logback-spring.xml\n│   │           │       └── static\n│   │           │           └── index.html\n│   │           └── test\n│   │               └── java\n│   └── pom.xml\n└── myserver-app  # 服务端\n    ├── app\n    │   ├── endpoint\n    │   │   ├── pom.xml\n    │   │   └── src\n    │   │       └── main\n    │   │           ├── java\n    │   │           │   └── com\n    │   │           │       └── alipay\n    │   │           │           └── samples\n    │   │           │               └── rpc\n    │   │           │                   ├── impl\n    │   │           │                   │   ├── SampleRestFacadeImpl.java\n    │   │           │                   │   └── SampleServiceImpl.java  # SampleService实现\n    │   │           │                   ├── SampleRestFacade.java\n    │   │           │                   └── SampleService.java  # 如你所见，这里也有一个SampleService接口文件\n    │   │           └── resources\n    │   │               └── META-INF\n    │   │                   └── sofa-rpc\n    │   │                       └── sofa-config.json\n    │   └── web\n    │       ├── pom.xml\n    │       └── src\n    │           ├── main\n    │           │   ├── java\n    │           │   │   └── com\n    │           │   │       └── alipay\n    │           │   │           └── mytestsofa\n    │           │   │               └── SOFABootWebSpringApplication.java  # 仅做拉起服务的动作，为的是让SampleService实例暴露出去\n    │           │   └── resources\n    │           │       ├── config\n    │           │       │   ├── application-dev.properties\n    │           │       │   ├── application.properties\n    │           │       │   └── application-test.properties\n    │           │       ├── logback-spring.xml\n    │           │       └── static\n    │           │           └── index.html\n    │           └── test\n    │               └── java\n    │                   └── com\n    │                       └── alipay\n    │                           └── mytestsofa\n    │                               └── web\n    └── pom.xml\n\n```\n\n本地编译需先配置\\~/.m2/settings.xml指向阿里maven仓库（central仓库是没有pom表描述的这些包的）：<https://help.aliyun.com/document_detail/133192.html?spm=a2c4g.149866.0.0.3a17480bTRbEmC>\n\n> 新版maven默认要求https，这里的settings源为http，可能会碰到网络问题，请修改`external:https:*`中的https为dummy\n\n\n编译好会得到两个可执行jar包，启动方式：\n\n```bash\njava -jar myserver-xxxx-executable.jar\njava -jar myclient-xxxx-executable.jar\n```\n\n**rpc client集成gateway**\n\n思路，定义一个filter，从SampleService获取相关字段，然后concat到httpbin响应里。\n\n这里碰到问题，sofaboot应用有自己的依赖，和spring cloud gateway依赖似乎有冲突，尝试集成二者存在包不匹配导致类找不到的情况。\n\n这块作为遗留问题，以后有时间再解。\n\n**使用spring cloud**\n\n尝试做一次spring cloud组件集成，包括：\n\n*   配置中心：spring cloud config\n*   注册中心：spring cloud eureka\n*   rest接口：spring cloud web\n*   数据映射：mybatis\n*   数据库：mysql\n\n1、配置中心效果：\n\nproduct和order服务[从github上](https://github.com/StaveWu/config-repository)读取配置，并本地运行。\n\nconfig-repository/productService-dev.properties：\n\n```properties\nspring.datasource.driver-class-name=com.mysql.jdbc.Driver\nspring.datasource.url=jdbc:mysql://127.0.0.1:3306/experiment?serverTimezone=UTC&useUnicode=true&characterEncoding=utf8&useSSL=false\nspring.datasource.username=root\nspring.datasource.password=123456\nspring.datasource.type=com.zaxxer.hikari.HikariDataSource\nspring.datasource.hikari.minimum-idle=5\nspring.datasource.hikari.maximum-pool-size=15\nspring.datasource.hikari.auto-commit=true\nspring.datasource.hikari.idle-timeout=30000\nspring.datasource.hikari.pool-name=DatebookHikariCP\nspring.datasource.hikari.max-lifetime=1800000\nspring.datasource.hikari.connection-timeout=30000\nspring.datasource.hikari.connection-test-query=SELECT 1\nmybatis.mapper-locations=classpath:mapper/*.xml\n```\n\n本地product配置：\n\n```properties\nspring.application.name=productService\neureka.client.service-url.defaultZone=http://localhost:8764/eureka/\nspring.cloud.config.discovery.enabled=true\nspring.cloud.config.discovery.service-id=CONFIGCENTER\nspring.cloud.config.profile=dev\nspring.config.import=configserver:http://localhost:8096\n```\n\n上述8096端口有配置中心服务在监听：\n\n```properties\nserver.port=8096\nspring.application.name=configCenter\neureka.client.service-url.defaultZone=http://localhost:8764/eureka/\nspring.cloud.config.server.git.uri=https://github.com/StaveWu/config-repository.git\nspring.cloud.config.server.git.username=stavewu\nspring.cloud.config.server.git.password=******\n```\n\n配置中心服务主要用到了spring cloud config组件Config Server，注解：`@EnableConfigServer`\n\nproduct使用的是Config Client，无需注解。\n\n这样就形成了一条从`product -> config server:8096 -> github/config-repository`的通路。\n\nconfig-repository里有好几个配置文件，product服务怎么知道要拿哪一个？\n\n这里猜测是一种约定：基于spring.appliction.name + spring.cloud.config.profile命名的配置文件将被读取，product服务对应到productService-dev.properties。\n\n2、mybatis效果：\n\n在product配置文件里，通过`mybatis.mapper-locations=classpath:mapper/*.xml`读取到位于resources/mapper下的配置文件；通过`spring.datasource.url=jdbc:mysql://127.0.0.1:3306/experiment?serverTimezone=UTC&useUnicode=true&characterEncoding=utf8&useSSL=false`连接到名为experiment的数据库实例，与配置文件配合形成数据库数据读取加载。\n","slug":"kubernetes","published":1,"updated":"2024-08-31T14:46:57.012Z","_id":"cm0i903jz0002cfp7gjs69v4b","comments":1,"layout":"post","photos":[],"content":"<p>本文尝试部署kubernetes集群，并理解该组件能够做什么，什么时候使用。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"部署集群\"><a href=\"#部署集群\" class=\"headerlink\" title=\"部署集群\"></a>部署集群</h2><p>假设我们有3台设备，每台设备都已修改过hostname：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hostnamectl set-hostname xxxx</span><br></pre></td></tr></table></figure>\n\n<p>并已同步在&#x2F;etc&#x2F;hosts里配置了对应的ip hostname映射。</p>\n<p>master、node01、node02</p>\n<p>前置准备（此步骤在所有节点上做）：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># This overwrites any existing configuration in /etc/yum.repos.d/kubernetes.repo</span></span><br><span class=\"line\"><span class=\"built_in\">cat</span> &lt;&lt;<span class=\"string\">EOF | sudo tee /etc/yum.repos.d/kubernetes.repo</span></span><br><span class=\"line\"><span class=\"string\">[kubernetes]</span></span><br><span class=\"line\"><span class=\"string\">name=Kubernetes</span></span><br><span class=\"line\"><span class=\"string\">baseurl=https://pkgs.k8s.io/core:/stable:/v1.29/rpm/</span></span><br><span class=\"line\"><span class=\"string\">enabled=1</span></span><br><span class=\"line\"><span class=\"string\">gpgcheck=1</span></span><br><span class=\"line\"><span class=\"string\">gpgkey=https://pkgs.k8s.io/core:/stable:/v1.29/rpm/repodata/repomd.xml.key</span></span><br><span class=\"line\"><span class=\"string\">exclude=kubelet kubeadm kubectl cri-tools kubernetes-cni</span></span><br><span class=\"line\"><span class=\"string\">EOF</span></span><br><span class=\"line\"></span><br><span class=\"line\">yum install -y kubelet kubeadm kubectl --disableexcludes=kubernetes</span><br><span class=\"line\">yum install -y docker</span><br></pre></td></tr></table></figure>\n\n<p>环境准备，包括关闭selinux、关闭swap、关闭防火墙、打开IP forward、修改docker的cgroupfs驱动为systemd、准备docker-shim（此步骤在所有节点上做）：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setenforce 0</span><br><span class=\"line\">swapoff -a</span><br><span class=\"line\">systemctl stop firewalld</span><br><span class=\"line\">systemctl <span class=\"built_in\">disable</span> firewalld</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cat</span> &lt;&lt;<span class=\"string\">EOF | sudo tee /etc/sysctl.d/k8s.conf</span></span><br><span class=\"line\"><span class=\"string\">net.bridge.bridge-nf-call-ip6tables = 1</span></span><br><span class=\"line\"><span class=\"string\">net.bridge.bridge-nf-call-iptables = 1</span></span><br><span class=\"line\"><span class=\"string\">net.ipv4.ip_forward = 1</span></span><br><span class=\"line\"><span class=\"string\">EOF</span></span><br><span class=\"line\">sysctl --system</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cat</span> &lt;&lt;<span class=\"string\">EOF | sudo tee /etc/docker/daemon.json</span></span><br><span class=\"line\"><span class=\"string\">&#123;</span></span><br><span class=\"line\"><span class=\"string\">  &quot;exec-opts&quot;: [&quot;native.cgroupdriver=systemd&quot;],</span></span><br><span class=\"line\"><span class=\"string\">  &quot;log-driver&quot;: &quot;json-file&quot;,</span></span><br><span class=\"line\"><span class=\"string\">  &quot;log-opts&quot;: &#123;</span></span><br><span class=\"line\"><span class=\"string\">    &quot;max-size&quot;: &quot;100m&quot;</span></span><br><span class=\"line\"><span class=\"string\">  &#125;,</span></span><br><span class=\"line\"><span class=\"string\">  &quot;storage-driver&quot;: &quot;overlay2&quot;</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\">EOF</span></span><br><span class=\"line\"></span><br><span class=\"line\">wget https://github.com/Mirantis/cri-dockerd/releases/download/v0.3.10/cri-dockerd-0.3.10.arm64.tgz</span><br><span class=\"line\">tar -zxf cri-dockerd-0.3.10.arm64.tgz</span><br><span class=\"line\"><span class=\"built_in\">cd</span> cri-dockerd</span><br><span class=\"line\">install cri-dockerd /usr/bin</span><br><span class=\"line\"></span><br><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/Mirantis/cri-dockerd.git</span><br><span class=\"line\"><span class=\"built_in\">cd</span> cri-dockerd</span><br><span class=\"line\">install packaging/systemd/* /etc/systemd/system</span><br><span class=\"line\">systemctl daemon-reload</span><br><span class=\"line\">systemctl restart docker</span><br><span class=\"line\">systemctl start cri-docker.socket</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 启动集群服务进程</span></span><br><span class=\"line\">systemctl <span class=\"built_in\">enable</span> --now kubelet</span><br></pre></td></tr></table></figure>\n\n<p>我们现在在master节点上启动集群：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubeadm init --apiserver-advertise-address=[网卡ip] --pod-network-cidr=10.224.0.0/16</span><br></pre></td></tr></table></figure>\n\n<p>配置.kube&#x2F;config，否则无法查询集群信息：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">mkdir</span> ~/.kube</span><br><span class=\"line\"><span class=\"built_in\">cp</span> /etc/kubernetes/admin.conf ~/.kube/config</span><br><span class=\"line\">kubectl get pods --all-namespaces</span><br></pre></td></tr></table></figure>\n\n<p>此时有两个coredns pod应该是pending的，因为它在等待cni插件。</p>\n<p>安装cni插件，这里选calico：</p>\n<blockquote>\n<p>注意这里calico在arm上有bug，遵循<a href=\"https://docs.tigera.io/calico/latest/getting-started/kubernetes/quickstart\">官网的yml</a>会安装失败报libpcap.so找不到，跟calico版本有关，原因<a href=\"https://github.com/bettercap/bettercap/issues/98\">见该issue</a></p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl create -f https://docs.projectcalico.org/manifests/tigera-operator.yaml</span><br><span class=\"line\"></span><br><span class=\"line\">wget https://docs.projectcalico.org/manifests/custom-resources.yaml</span><br><span class=\"line\">vim custom-resources.yaml</span><br><span class=\"line\"><span class=\"comment\"># 修改cidr为10.244.0.0/16</span></span><br><span class=\"line\">kubectl create -f custom-resources.yaml</span><br></pre></td></tr></table></figure>\n\n<p>安装成功后观察coredns是否为running。</p>\n<p>如果coredns出现错误，通过kubectl describe coredns-xxxx -n kube-system查到bind 53: permission denied错误，则需要做如下变更：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl edit cm coredns -n kube-system</span><br><span class=\"line\"><span class=\"comment\"># 修改为.:1053 &#123;</span></span><br><span class=\"line\"><span class=\"comment\">#   forward . 8.8.8.8:53</span></span><br><span class=\"line\"><span class=\"comment\">#   ...</span></span><br></pre></td></tr></table></figure>\n\n<p>意思是监听1053，再转发到8.8.8.8:53地址。</p>\n<p>修改后重启coredns：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl delete pod coredns-xxxx -n kube-system</span><br><span class=\"line\">kubectl delete pod coredns-xxxx -n kube-system</span><br></pre></td></tr></table></figure>\n\n<p>重启后应能正确运行。</p>\n<p>剩下的就是join工作节点了：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 在master节点上运行</span></span><br><span class=\"line\">kubeadm token create --print-join-command</span><br><span class=\"line\"><span class=\"comment\"># 将输出的命令在其他节点上执行</span></span><br><span class=\"line\">kubeadm <span class=\"built_in\">join</span> 170.70.226.121:6443 --token jalb9p.6os29537lon9befl --discovery-token-ca-cert-hash sha256:923a907a5fb070aad4d91f4e5ce6a5b8c55b8c1d6d6e326eadc8c95eaa8987d2</span><br><span class=\"line\"><span class=\"comment\"># 成功后查询</span></span><br><span class=\"line\">kubectl get nodes</span><br></pre></td></tr></table></figure>\n\n<p>应全部ready。</p>\n<p>至此集群搭建完成。</p>\n<h2 id=\"使用集群\"><a href=\"#使用集群\" class=\"headerlink\" title=\"使用集群\"></a>使用集群</h2><p>准备一个样例：</p>\n<p>数据库部分不在kubernetes上部署，只准备服务部分。</p>\n<p>服务采用spring cloud，分几段：</p>\n<ul>\n<li>服务网关spring cloud gateway</li>\n<li>具体处理业务的服务</li>\n</ul>\n<p>服务网关将通过rpc调用具体处理业务的服务。</p>\n<p>网关和具体服务分开为两个pod</p>\n<p>为了接近生产配置，网关设置出2个副本（分散在2个node），具体服务也同样处理。</p>\n<p><strong>Gateway</strong></p>\n<p>gateway作用：</p>\n<p><img src=\"https://static.spring.io/blog/fombico/20220826/spring-cloud-gateway-diagram.png\" alt=\"Spring Cloud Gateway diagram\" title=\"Spring Cloud Gateway diagram\"></p>\n<p>官方样例：<a href=\"https://spring.io/guides/gs/gateway\">https://spring.io/guides/gs/gateway</a></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/spring-guides/gs-gateway.git</span><br><span class=\"line\"><span class=\"built_in\">cd</span> gs-gateway/initial</span><br><span class=\"line\"><span class=\"comment\"># 使用idea打开</span></span><br></pre></td></tr></table></figure>\n\n<p>编写简单的gateway处理，路由到httpbin.org（一个公共的实验站点）。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> RouteLocator <span class=\"title function_\">myRoutes</span><span class=\"params\">(RouteLocatorBuilder builder)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> builder.routes()</span><br><span class=\"line\">        .route(p -&gt; p</span><br><span class=\"line\">            .path(<span class=\"string\">&quot;/get&quot;</span>)</span><br><span class=\"line\">            .filters(f -&gt; f.addRequestHeader(<span class=\"string\">&quot;Hello&quot;</span>, <span class=\"string\">&quot;World&quot;</span>))</span><br><span class=\"line\">            .uri(<span class=\"string\">&quot;http://httpbin.org:80&quot;</span>))</span><br><span class=\"line\">        .build();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>示例解释：代理httpbin.org&#x2F;get请求，新增了一个Hello:World消息头字段。</p>\n<blockquote>\n<p>这种gateway跟nginx的区别？nginx不能做吗？</p>\n</blockquote>\n<blockquote>\n<p>gateway相对更灵活，可编程，内置有权限、服务熔断等功能，可以做的事情跟多些。&#x20;</p>\n</blockquote>\n<p><strong>rpc服务</strong></p>\n<p>rpc服务采用阿里的sofa-rpc，示例下载：<a href=\"https://help.aliyun.com/document_detail/149866.html?spm=a2c4g.152618.0.0.754c480bbGsKic\">https://help.aliyun.com/document_detail/149866.html?spm=a2c4g.152618.0.0.754c480bbGsKic</a></p>\n<p>rpc调用涉及client和server，server提供interface实现，client调用interface。这里隐含了client和server的工程内需分别放一个interface文件。</p>\n<p>工程目录如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">├── myclient-app  <span class=\"comment\"># 客户端</span></span><br><span class=\"line\">│   ├── app</span><br><span class=\"line\">│   │   ├── endpoint</span><br><span class=\"line\">│   │   │   ├── pom.xml</span><br><span class=\"line\">│   │   │   └── src</span><br><span class=\"line\">│   │   │       └── main</span><br><span class=\"line\">│   │   │           ├── java</span><br><span class=\"line\">│   │   │           │   └── com</span><br><span class=\"line\">│   │   │           │       └── alipay</span><br><span class=\"line\">│   │   │           │           └── samples</span><br><span class=\"line\">│   │   │           │               └── rpc</span><br><span class=\"line\">│   │   │           │                   ├── SampleRestFacade.java</span><br><span class=\"line\">│   │   │           │                   └── SampleService.java  <span class=\"comment\"># 接口文件</span></span><br><span class=\"line\">│   │   │           └── resources</span><br><span class=\"line\">│   │   └── web</span><br><span class=\"line\">│   │       ├── pom.xml</span><br><span class=\"line\">│   │       └── src</span><br><span class=\"line\">│   │           ├── main</span><br><span class=\"line\">│   │           │   ├── java</span><br><span class=\"line\">│   │           │   │   └── com</span><br><span class=\"line\">│   │           │   │       └── alipay</span><br><span class=\"line\">│   │           │   │           └── mytestsofa</span><br><span class=\"line\">│   │           │   │               ├── ReferenceHolder.java  <span class=\"comment\"># 获取SampleService实例引用</span></span><br><span class=\"line\">│   │           │   │               └── SOFABootWebSpringApplication.java  <span class=\"comment\"># 拉起服务，调用SampleService接口</span></span><br><span class=\"line\">│   │           │   └── resources</span><br><span class=\"line\">│   │           │       ├── config</span><br><span class=\"line\">│   │           │       │   ├── application-dev.properties</span><br><span class=\"line\">│   │           │       │   ├── application.properties</span><br><span class=\"line\">│   │           │       │   └── application-test.properties</span><br><span class=\"line\">│   │           │       ├── logback-spring.xml</span><br><span class=\"line\">│   │           │       └── static</span><br><span class=\"line\">│   │           │           └── index.html</span><br><span class=\"line\">│   │           └── <span class=\"built_in\">test</span></span><br><span class=\"line\">│   │               └── java</span><br><span class=\"line\">│   └── pom.xml</span><br><span class=\"line\">└── myserver-app  <span class=\"comment\"># 服务端</span></span><br><span class=\"line\">    ├── app</span><br><span class=\"line\">    │   ├── endpoint</span><br><span class=\"line\">    │   │   ├── pom.xml</span><br><span class=\"line\">    │   │   └── src</span><br><span class=\"line\">    │   │       └── main</span><br><span class=\"line\">    │   │           ├── java</span><br><span class=\"line\">    │   │           │   └── com</span><br><span class=\"line\">    │   │           │       └── alipay</span><br><span class=\"line\">    │   │           │           └── samples</span><br><span class=\"line\">    │   │           │               └── rpc</span><br><span class=\"line\">    │   │           │                   ├── impl</span><br><span class=\"line\">    │   │           │                   │   ├── SampleRestFacadeImpl.java</span><br><span class=\"line\">    │   │           │                   │   └── SampleServiceImpl.java  <span class=\"comment\"># SampleService实现</span></span><br><span class=\"line\">    │   │           │                   ├── SampleRestFacade.java</span><br><span class=\"line\">    │   │           │                   └── SampleService.java  <span class=\"comment\"># 如你所见，这里也有一个SampleService接口文件</span></span><br><span class=\"line\">    │   │           └── resources</span><br><span class=\"line\">    │   │               └── META-INF</span><br><span class=\"line\">    │   │                   └── sofa-rpc</span><br><span class=\"line\">    │   │                       └── sofa-config.json</span><br><span class=\"line\">    │   └── web</span><br><span class=\"line\">    │       ├── pom.xml</span><br><span class=\"line\">    │       └── src</span><br><span class=\"line\">    │           ├── main</span><br><span class=\"line\">    │           │   ├── java</span><br><span class=\"line\">    │           │   │   └── com</span><br><span class=\"line\">    │           │   │       └── alipay</span><br><span class=\"line\">    │           │   │           └── mytestsofa</span><br><span class=\"line\">    │           │   │               └── SOFABootWebSpringApplication.java  <span class=\"comment\"># 仅做拉起服务的动作，为的是让SampleService实例暴露出去</span></span><br><span class=\"line\">    │           │   └── resources</span><br><span class=\"line\">    │           │       ├── config</span><br><span class=\"line\">    │           │       │   ├── application-dev.properties</span><br><span class=\"line\">    │           │       │   ├── application.properties</span><br><span class=\"line\">    │           │       │   └── application-test.properties</span><br><span class=\"line\">    │           │       ├── logback-spring.xml</span><br><span class=\"line\">    │           │       └── static</span><br><span class=\"line\">    │           │           └── index.html</span><br><span class=\"line\">    │           └── <span class=\"built_in\">test</span></span><br><span class=\"line\">    │               └── java</span><br><span class=\"line\">    │                   └── com</span><br><span class=\"line\">    │                       └── alipay</span><br><span class=\"line\">    │                           └── mytestsofa</span><br><span class=\"line\">    │                               └── web</span><br><span class=\"line\">    └── pom.xml</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>本地编译需先配置~&#x2F;.m2&#x2F;settings.xml指向阿里maven仓库（central仓库是没有pom表描述的这些包的）：<a href=\"https://help.aliyun.com/document_detail/133192.html?spm=a2c4g.149866.0.0.3a17480bTRbEmC\">https://help.aliyun.com/document_detail/133192.html?spm=a2c4g.149866.0.0.3a17480bTRbEmC</a></p>\n<blockquote>\n<p>新版maven默认要求https，这里的settings源为http，可能会碰到网络问题，请修改<code>external:https:*</code>中的https为dummy</p>\n</blockquote>\n<p>编译好会得到两个可执行jar包，启动方式：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java -jar myserver-xxxx-executable.jar</span><br><span class=\"line\">java -jar myclient-xxxx-executable.jar</span><br></pre></td></tr></table></figure>\n\n<p><strong>rpc client集成gateway</strong></p>\n<p>思路，定义一个filter，从SampleService获取相关字段，然后concat到httpbin响应里。</p>\n<p>这里碰到问题，sofaboot应用有自己的依赖，和spring cloud gateway依赖似乎有冲突，尝试集成二者存在包不匹配导致类找不到的情况。</p>\n<p>这块作为遗留问题，以后有时间再解。</p>\n<p><strong>使用spring cloud</strong></p>\n<p>尝试做一次spring cloud组件集成，包括：</p>\n<ul>\n<li>配置中心：spring cloud config</li>\n<li>注册中心：spring cloud eureka</li>\n<li>rest接口：spring cloud web</li>\n<li>数据映射：mybatis</li>\n<li>数据库：mysql</li>\n</ul>\n<p>1、配置中心效果：</p>\n<p>product和order服务<a href=\"https://github.com/StaveWu/config-repository\">从github上</a>读取配置，并本地运行。</p>\n<p>config-repository&#x2F;productService-dev.properties：</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">spring.datasource.driver-class-name</span>=<span class=\"string\">com.mysql.jdbc.Driver</span></span><br><span class=\"line\"><span class=\"attr\">spring.datasource.url</span>=<span class=\"string\">jdbc:mysql://127.0.0.1:3306/experiment?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false</span></span><br><span class=\"line\"><span class=\"attr\">spring.datasource.username</span>=<span class=\"string\">root</span></span><br><span class=\"line\"><span class=\"attr\">spring.datasource.password</span>=<span class=\"string\">123456</span></span><br><span class=\"line\"><span class=\"attr\">spring.datasource.type</span>=<span class=\"string\">com.zaxxer.hikari.HikariDataSource</span></span><br><span class=\"line\"><span class=\"attr\">spring.datasource.hikari.minimum-idle</span>=<span class=\"string\">5</span></span><br><span class=\"line\"><span class=\"attr\">spring.datasource.hikari.maximum-pool-size</span>=<span class=\"string\">15</span></span><br><span class=\"line\"><span class=\"attr\">spring.datasource.hikari.auto-commit</span>=<span class=\"string\">true</span></span><br><span class=\"line\"><span class=\"attr\">spring.datasource.hikari.idle-timeout</span>=<span class=\"string\">30000</span></span><br><span class=\"line\"><span class=\"attr\">spring.datasource.hikari.pool-name</span>=<span class=\"string\">DatebookHikariCP</span></span><br><span class=\"line\"><span class=\"attr\">spring.datasource.hikari.max-lifetime</span>=<span class=\"string\">1800000</span></span><br><span class=\"line\"><span class=\"attr\">spring.datasource.hikari.connection-timeout</span>=<span class=\"string\">30000</span></span><br><span class=\"line\"><span class=\"attr\">spring.datasource.hikari.connection-test-query</span>=<span class=\"string\">SELECT 1</span></span><br><span class=\"line\"><span class=\"attr\">mybatis.mapper-locations</span>=<span class=\"string\">classpath:mapper/*.xml</span></span><br></pre></td></tr></table></figure>\n\n<p>本地product配置：</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">spring.application.name</span>=<span class=\"string\">productService</span></span><br><span class=\"line\"><span class=\"attr\">eureka.client.service-url.defaultZone</span>=<span class=\"string\">http://localhost:8764/eureka/</span></span><br><span class=\"line\"><span class=\"attr\">spring.cloud.config.discovery.enabled</span>=<span class=\"string\">true</span></span><br><span class=\"line\"><span class=\"attr\">spring.cloud.config.discovery.service-id</span>=<span class=\"string\">CONFIGCENTER</span></span><br><span class=\"line\"><span class=\"attr\">spring.cloud.config.profile</span>=<span class=\"string\">dev</span></span><br><span class=\"line\"><span class=\"attr\">spring.config.import</span>=<span class=\"string\">configserver:http://localhost:8096</span></span><br></pre></td></tr></table></figure>\n\n<p>上述8096端口有配置中心服务在监听：</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">server.port</span>=<span class=\"string\">8096</span></span><br><span class=\"line\"><span class=\"attr\">spring.application.name</span>=<span class=\"string\">configCenter</span></span><br><span class=\"line\"><span class=\"attr\">eureka.client.service-url.defaultZone</span>=<span class=\"string\">http://localhost:8764/eureka/</span></span><br><span class=\"line\"><span class=\"attr\">spring.cloud.config.server.git.uri</span>=<span class=\"string\">https://github.com/StaveWu/config-repository.git</span></span><br><span class=\"line\"><span class=\"attr\">spring.cloud.config.server.git.username</span>=<span class=\"string\">stavewu</span></span><br><span class=\"line\"><span class=\"attr\">spring.cloud.config.server.git.password</span>=<span class=\"string\">******</span></span><br></pre></td></tr></table></figure>\n\n<p>配置中心服务主要用到了spring cloud config组件Config Server，注解：<code>@EnableConfigServer</code></p>\n<p>product使用的是Config Client，无需注解。</p>\n<p>这样就形成了一条从<code>product -&gt; config server:8096 -&gt; github/config-repository</code>的通路。</p>\n<p>config-repository里有好几个配置文件，product服务怎么知道要拿哪一个？</p>\n<p>这里猜测是一种约定：基于spring.appliction.name + spring.cloud.config.profile命名的配置文件将被读取，product服务对应到productService-dev.properties。</p>\n<p>2、mybatis效果：</p>\n<p>在product配置文件里，通过<code>mybatis.mapper-locations=classpath:mapper/*.xml</code>读取到位于resources&#x2F;mapper下的配置文件；通过<code>spring.datasource.url=jdbc:mysql://127.0.0.1:3306/experiment?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false</code>连接到名为experiment的数据库实例，与配置文件配合形成数据库数据读取加载。</p>\n","excerpt":"<p>本文尝试部署kubernetes集群，并理解该组件能够做什么，什么时候使用。</p>","more":"<h2 id=\"部署集群\"><a href=\"#部署集群\" class=\"headerlink\" title=\"部署集群\"></a>部署集群</h2><p>假设我们有3台设备，每台设备都已修改过hostname：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hostnamectl set-hostname xxxx</span><br></pre></td></tr></table></figure>\n\n<p>并已同步在&#x2F;etc&#x2F;hosts里配置了对应的ip hostname映射。</p>\n<p>master、node01、node02</p>\n<p>前置准备（此步骤在所有节点上做）：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># This overwrites any existing configuration in /etc/yum.repos.d/kubernetes.repo</span></span><br><span class=\"line\"><span class=\"built_in\">cat</span> &lt;&lt;<span class=\"string\">EOF | sudo tee /etc/yum.repos.d/kubernetes.repo</span></span><br><span class=\"line\"><span class=\"string\">[kubernetes]</span></span><br><span class=\"line\"><span class=\"string\">name=Kubernetes</span></span><br><span class=\"line\"><span class=\"string\">baseurl=https://pkgs.k8s.io/core:/stable:/v1.29/rpm/</span></span><br><span class=\"line\"><span class=\"string\">enabled=1</span></span><br><span class=\"line\"><span class=\"string\">gpgcheck=1</span></span><br><span class=\"line\"><span class=\"string\">gpgkey=https://pkgs.k8s.io/core:/stable:/v1.29/rpm/repodata/repomd.xml.key</span></span><br><span class=\"line\"><span class=\"string\">exclude=kubelet kubeadm kubectl cri-tools kubernetes-cni</span></span><br><span class=\"line\"><span class=\"string\">EOF</span></span><br><span class=\"line\"></span><br><span class=\"line\">yum install -y kubelet kubeadm kubectl --disableexcludes=kubernetes</span><br><span class=\"line\">yum install -y docker</span><br></pre></td></tr></table></figure>\n\n<p>环境准备，包括关闭selinux、关闭swap、关闭防火墙、打开IP forward、修改docker的cgroupfs驱动为systemd、准备docker-shim（此步骤在所有节点上做）：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setenforce 0</span><br><span class=\"line\">swapoff -a</span><br><span class=\"line\">systemctl stop firewalld</span><br><span class=\"line\">systemctl <span class=\"built_in\">disable</span> firewalld</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cat</span> &lt;&lt;<span class=\"string\">EOF | sudo tee /etc/sysctl.d/k8s.conf</span></span><br><span class=\"line\"><span class=\"string\">net.bridge.bridge-nf-call-ip6tables = 1</span></span><br><span class=\"line\"><span class=\"string\">net.bridge.bridge-nf-call-iptables = 1</span></span><br><span class=\"line\"><span class=\"string\">net.ipv4.ip_forward = 1</span></span><br><span class=\"line\"><span class=\"string\">EOF</span></span><br><span class=\"line\">sysctl --system</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cat</span> &lt;&lt;<span class=\"string\">EOF | sudo tee /etc/docker/daemon.json</span></span><br><span class=\"line\"><span class=\"string\">&#123;</span></span><br><span class=\"line\"><span class=\"string\">  &quot;exec-opts&quot;: [&quot;native.cgroupdriver=systemd&quot;],</span></span><br><span class=\"line\"><span class=\"string\">  &quot;log-driver&quot;: &quot;json-file&quot;,</span></span><br><span class=\"line\"><span class=\"string\">  &quot;log-opts&quot;: &#123;</span></span><br><span class=\"line\"><span class=\"string\">    &quot;max-size&quot;: &quot;100m&quot;</span></span><br><span class=\"line\"><span class=\"string\">  &#125;,</span></span><br><span class=\"line\"><span class=\"string\">  &quot;storage-driver&quot;: &quot;overlay2&quot;</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\">EOF</span></span><br><span class=\"line\"></span><br><span class=\"line\">wget https://github.com/Mirantis/cri-dockerd/releases/download/v0.3.10/cri-dockerd-0.3.10.arm64.tgz</span><br><span class=\"line\">tar -zxf cri-dockerd-0.3.10.arm64.tgz</span><br><span class=\"line\"><span class=\"built_in\">cd</span> cri-dockerd</span><br><span class=\"line\">install cri-dockerd /usr/bin</span><br><span class=\"line\"></span><br><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/Mirantis/cri-dockerd.git</span><br><span class=\"line\"><span class=\"built_in\">cd</span> cri-dockerd</span><br><span class=\"line\">install packaging/systemd/* /etc/systemd/system</span><br><span class=\"line\">systemctl daemon-reload</span><br><span class=\"line\">systemctl restart docker</span><br><span class=\"line\">systemctl start cri-docker.socket</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 启动集群服务进程</span></span><br><span class=\"line\">systemctl <span class=\"built_in\">enable</span> --now kubelet</span><br></pre></td></tr></table></figure>\n\n<p>我们现在在master节点上启动集群：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubeadm init --apiserver-advertise-address=[网卡ip] --pod-network-cidr=10.224.0.0/16</span><br></pre></td></tr></table></figure>\n\n<p>配置.kube&#x2F;config，否则无法查询集群信息：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">mkdir</span> ~/.kube</span><br><span class=\"line\"><span class=\"built_in\">cp</span> /etc/kubernetes/admin.conf ~/.kube/config</span><br><span class=\"line\">kubectl get pods --all-namespaces</span><br></pre></td></tr></table></figure>\n\n<p>此时有两个coredns pod应该是pending的，因为它在等待cni插件。</p>\n<p>安装cni插件，这里选calico：</p>\n<blockquote>\n<p>注意这里calico在arm上有bug，遵循<a href=\"https://docs.tigera.io/calico/latest/getting-started/kubernetes/quickstart\">官网的yml</a>会安装失败报libpcap.so找不到，跟calico版本有关，原因<a href=\"https://github.com/bettercap/bettercap/issues/98\">见该issue</a></p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl create -f https://docs.projectcalico.org/manifests/tigera-operator.yaml</span><br><span class=\"line\"></span><br><span class=\"line\">wget https://docs.projectcalico.org/manifests/custom-resources.yaml</span><br><span class=\"line\">vim custom-resources.yaml</span><br><span class=\"line\"><span class=\"comment\"># 修改cidr为10.244.0.0/16</span></span><br><span class=\"line\">kubectl create -f custom-resources.yaml</span><br></pre></td></tr></table></figure>\n\n<p>安装成功后观察coredns是否为running。</p>\n<p>如果coredns出现错误，通过kubectl describe coredns-xxxx -n kube-system查到bind 53: permission denied错误，则需要做如下变更：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl edit cm coredns -n kube-system</span><br><span class=\"line\"><span class=\"comment\"># 修改为.:1053 &#123;</span></span><br><span class=\"line\"><span class=\"comment\">#   forward . 8.8.8.8:53</span></span><br><span class=\"line\"><span class=\"comment\">#   ...</span></span><br></pre></td></tr></table></figure>\n\n<p>意思是监听1053，再转发到8.8.8.8:53地址。</p>\n<p>修改后重启coredns：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl delete pod coredns-xxxx -n kube-system</span><br><span class=\"line\">kubectl delete pod coredns-xxxx -n kube-system</span><br></pre></td></tr></table></figure>\n\n<p>重启后应能正确运行。</p>\n<p>剩下的就是join工作节点了：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 在master节点上运行</span></span><br><span class=\"line\">kubeadm token create --print-join-command</span><br><span class=\"line\"><span class=\"comment\"># 将输出的命令在其他节点上执行</span></span><br><span class=\"line\">kubeadm <span class=\"built_in\">join</span> 170.70.226.121:6443 --token jalb9p.6os29537lon9befl --discovery-token-ca-cert-hash sha256:923a907a5fb070aad4d91f4e5ce6a5b8c55b8c1d6d6e326eadc8c95eaa8987d2</span><br><span class=\"line\"><span class=\"comment\"># 成功后查询</span></span><br><span class=\"line\">kubectl get nodes</span><br></pre></td></tr></table></figure>\n\n<p>应全部ready。</p>\n<p>至此集群搭建完成。</p>\n<h2 id=\"使用集群\"><a href=\"#使用集群\" class=\"headerlink\" title=\"使用集群\"></a>使用集群</h2><p>准备一个样例：</p>\n<p>数据库部分不在kubernetes上部署，只准备服务部分。</p>\n<p>服务采用spring cloud，分几段：</p>\n<ul>\n<li>服务网关spring cloud gateway</li>\n<li>具体处理业务的服务</li>\n</ul>\n<p>服务网关将通过rpc调用具体处理业务的服务。</p>\n<p>网关和具体服务分开为两个pod</p>\n<p>为了接近生产配置，网关设置出2个副本（分散在2个node），具体服务也同样处理。</p>\n<p><strong>Gateway</strong></p>\n<p>gateway作用：</p>\n<p><img src=\"https://static.spring.io/blog/fombico/20220826/spring-cloud-gateway-diagram.png\" alt=\"Spring Cloud Gateway diagram\" title=\"Spring Cloud Gateway diagram\"></p>\n<p>官方样例：<a href=\"https://spring.io/guides/gs/gateway\">https://spring.io/guides/gs/gateway</a></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/spring-guides/gs-gateway.git</span><br><span class=\"line\"><span class=\"built_in\">cd</span> gs-gateway/initial</span><br><span class=\"line\"><span class=\"comment\"># 使用idea打开</span></span><br></pre></td></tr></table></figure>\n\n<p>编写简单的gateway处理，路由到httpbin.org（一个公共的实验站点）。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> RouteLocator <span class=\"title function_\">myRoutes</span><span class=\"params\">(RouteLocatorBuilder builder)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> builder.routes()</span><br><span class=\"line\">        .route(p -&gt; p</span><br><span class=\"line\">            .path(<span class=\"string\">&quot;/get&quot;</span>)</span><br><span class=\"line\">            .filters(f -&gt; f.addRequestHeader(<span class=\"string\">&quot;Hello&quot;</span>, <span class=\"string\">&quot;World&quot;</span>))</span><br><span class=\"line\">            .uri(<span class=\"string\">&quot;http://httpbin.org:80&quot;</span>))</span><br><span class=\"line\">        .build();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>示例解释：代理httpbin.org&#x2F;get请求，新增了一个Hello:World消息头字段。</p>\n<blockquote>\n<p>这种gateway跟nginx的区别？nginx不能做吗？</p>\n</blockquote>\n<blockquote>\n<p>gateway相对更灵活，可编程，内置有权限、服务熔断等功能，可以做的事情跟多些。&#x20;</p>\n</blockquote>\n<p><strong>rpc服务</strong></p>\n<p>rpc服务采用阿里的sofa-rpc，示例下载：<a href=\"https://help.aliyun.com/document_detail/149866.html?spm=a2c4g.152618.0.0.754c480bbGsKic\">https://help.aliyun.com/document_detail/149866.html?spm=a2c4g.152618.0.0.754c480bbGsKic</a></p>\n<p>rpc调用涉及client和server，server提供interface实现，client调用interface。这里隐含了client和server的工程内需分别放一个interface文件。</p>\n<p>工程目录如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">├── myclient-app  <span class=\"comment\"># 客户端</span></span><br><span class=\"line\">│   ├── app</span><br><span class=\"line\">│   │   ├── endpoint</span><br><span class=\"line\">│   │   │   ├── pom.xml</span><br><span class=\"line\">│   │   │   └── src</span><br><span class=\"line\">│   │   │       └── main</span><br><span class=\"line\">│   │   │           ├── java</span><br><span class=\"line\">│   │   │           │   └── com</span><br><span class=\"line\">│   │   │           │       └── alipay</span><br><span class=\"line\">│   │   │           │           └── samples</span><br><span class=\"line\">│   │   │           │               └── rpc</span><br><span class=\"line\">│   │   │           │                   ├── SampleRestFacade.java</span><br><span class=\"line\">│   │   │           │                   └── SampleService.java  <span class=\"comment\"># 接口文件</span></span><br><span class=\"line\">│   │   │           └── resources</span><br><span class=\"line\">│   │   └── web</span><br><span class=\"line\">│   │       ├── pom.xml</span><br><span class=\"line\">│   │       └── src</span><br><span class=\"line\">│   │           ├── main</span><br><span class=\"line\">│   │           │   ├── java</span><br><span class=\"line\">│   │           │   │   └── com</span><br><span class=\"line\">│   │           │   │       └── alipay</span><br><span class=\"line\">│   │           │   │           └── mytestsofa</span><br><span class=\"line\">│   │           │   │               ├── ReferenceHolder.java  <span class=\"comment\"># 获取SampleService实例引用</span></span><br><span class=\"line\">│   │           │   │               └── SOFABootWebSpringApplication.java  <span class=\"comment\"># 拉起服务，调用SampleService接口</span></span><br><span class=\"line\">│   │           │   └── resources</span><br><span class=\"line\">│   │           │       ├── config</span><br><span class=\"line\">│   │           │       │   ├── application-dev.properties</span><br><span class=\"line\">│   │           │       │   ├── application.properties</span><br><span class=\"line\">│   │           │       │   └── application-test.properties</span><br><span class=\"line\">│   │           │       ├── logback-spring.xml</span><br><span class=\"line\">│   │           │       └── static</span><br><span class=\"line\">│   │           │           └── index.html</span><br><span class=\"line\">│   │           └── <span class=\"built_in\">test</span></span><br><span class=\"line\">│   │               └── java</span><br><span class=\"line\">│   └── pom.xml</span><br><span class=\"line\">└── myserver-app  <span class=\"comment\"># 服务端</span></span><br><span class=\"line\">    ├── app</span><br><span class=\"line\">    │   ├── endpoint</span><br><span class=\"line\">    │   │   ├── pom.xml</span><br><span class=\"line\">    │   │   └── src</span><br><span class=\"line\">    │   │       └── main</span><br><span class=\"line\">    │   │           ├── java</span><br><span class=\"line\">    │   │           │   └── com</span><br><span class=\"line\">    │   │           │       └── alipay</span><br><span class=\"line\">    │   │           │           └── samples</span><br><span class=\"line\">    │   │           │               └── rpc</span><br><span class=\"line\">    │   │           │                   ├── impl</span><br><span class=\"line\">    │   │           │                   │   ├── SampleRestFacadeImpl.java</span><br><span class=\"line\">    │   │           │                   │   └── SampleServiceImpl.java  <span class=\"comment\"># SampleService实现</span></span><br><span class=\"line\">    │   │           │                   ├── SampleRestFacade.java</span><br><span class=\"line\">    │   │           │                   └── SampleService.java  <span class=\"comment\"># 如你所见，这里也有一个SampleService接口文件</span></span><br><span class=\"line\">    │   │           └── resources</span><br><span class=\"line\">    │   │               └── META-INF</span><br><span class=\"line\">    │   │                   └── sofa-rpc</span><br><span class=\"line\">    │   │                       └── sofa-config.json</span><br><span class=\"line\">    │   └── web</span><br><span class=\"line\">    │       ├── pom.xml</span><br><span class=\"line\">    │       └── src</span><br><span class=\"line\">    │           ├── main</span><br><span class=\"line\">    │           │   ├── java</span><br><span class=\"line\">    │           │   │   └── com</span><br><span class=\"line\">    │           │   │       └── alipay</span><br><span class=\"line\">    │           │   │           └── mytestsofa</span><br><span class=\"line\">    │           │   │               └── SOFABootWebSpringApplication.java  <span class=\"comment\"># 仅做拉起服务的动作，为的是让SampleService实例暴露出去</span></span><br><span class=\"line\">    │           │   └── resources</span><br><span class=\"line\">    │           │       ├── config</span><br><span class=\"line\">    │           │       │   ├── application-dev.properties</span><br><span class=\"line\">    │           │       │   ├── application.properties</span><br><span class=\"line\">    │           │       │   └── application-test.properties</span><br><span class=\"line\">    │           │       ├── logback-spring.xml</span><br><span class=\"line\">    │           │       └── static</span><br><span class=\"line\">    │           │           └── index.html</span><br><span class=\"line\">    │           └── <span class=\"built_in\">test</span></span><br><span class=\"line\">    │               └── java</span><br><span class=\"line\">    │                   └── com</span><br><span class=\"line\">    │                       └── alipay</span><br><span class=\"line\">    │                           └── mytestsofa</span><br><span class=\"line\">    │                               └── web</span><br><span class=\"line\">    └── pom.xml</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>本地编译需先配置~&#x2F;.m2&#x2F;settings.xml指向阿里maven仓库（central仓库是没有pom表描述的这些包的）：<a href=\"https://help.aliyun.com/document_detail/133192.html?spm=a2c4g.149866.0.0.3a17480bTRbEmC\">https://help.aliyun.com/document_detail/133192.html?spm=a2c4g.149866.0.0.3a17480bTRbEmC</a></p>\n<blockquote>\n<p>新版maven默认要求https，这里的settings源为http，可能会碰到网络问题，请修改<code>external:https:*</code>中的https为dummy</p>\n</blockquote>\n<p>编译好会得到两个可执行jar包，启动方式：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java -jar myserver-xxxx-executable.jar</span><br><span class=\"line\">java -jar myclient-xxxx-executable.jar</span><br></pre></td></tr></table></figure>\n\n<p><strong>rpc client集成gateway</strong></p>\n<p>思路，定义一个filter，从SampleService获取相关字段，然后concat到httpbin响应里。</p>\n<p>这里碰到问题，sofaboot应用有自己的依赖，和spring cloud gateway依赖似乎有冲突，尝试集成二者存在包不匹配导致类找不到的情况。</p>\n<p>这块作为遗留问题，以后有时间再解。</p>\n<p><strong>使用spring cloud</strong></p>\n<p>尝试做一次spring cloud组件集成，包括：</p>\n<ul>\n<li>配置中心：spring cloud config</li>\n<li>注册中心：spring cloud eureka</li>\n<li>rest接口：spring cloud web</li>\n<li>数据映射：mybatis</li>\n<li>数据库：mysql</li>\n</ul>\n<p>1、配置中心效果：</p>\n<p>product和order服务<a href=\"https://github.com/StaveWu/config-repository\">从github上</a>读取配置，并本地运行。</p>\n<p>config-repository&#x2F;productService-dev.properties：</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">spring.datasource.driver-class-name</span>=<span class=\"string\">com.mysql.jdbc.Driver</span></span><br><span class=\"line\"><span class=\"attr\">spring.datasource.url</span>=<span class=\"string\">jdbc:mysql://127.0.0.1:3306/experiment?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false</span></span><br><span class=\"line\"><span class=\"attr\">spring.datasource.username</span>=<span class=\"string\">root</span></span><br><span class=\"line\"><span class=\"attr\">spring.datasource.password</span>=<span class=\"string\">123456</span></span><br><span class=\"line\"><span class=\"attr\">spring.datasource.type</span>=<span class=\"string\">com.zaxxer.hikari.HikariDataSource</span></span><br><span class=\"line\"><span class=\"attr\">spring.datasource.hikari.minimum-idle</span>=<span class=\"string\">5</span></span><br><span class=\"line\"><span class=\"attr\">spring.datasource.hikari.maximum-pool-size</span>=<span class=\"string\">15</span></span><br><span class=\"line\"><span class=\"attr\">spring.datasource.hikari.auto-commit</span>=<span class=\"string\">true</span></span><br><span class=\"line\"><span class=\"attr\">spring.datasource.hikari.idle-timeout</span>=<span class=\"string\">30000</span></span><br><span class=\"line\"><span class=\"attr\">spring.datasource.hikari.pool-name</span>=<span class=\"string\">DatebookHikariCP</span></span><br><span class=\"line\"><span class=\"attr\">spring.datasource.hikari.max-lifetime</span>=<span class=\"string\">1800000</span></span><br><span class=\"line\"><span class=\"attr\">spring.datasource.hikari.connection-timeout</span>=<span class=\"string\">30000</span></span><br><span class=\"line\"><span class=\"attr\">spring.datasource.hikari.connection-test-query</span>=<span class=\"string\">SELECT 1</span></span><br><span class=\"line\"><span class=\"attr\">mybatis.mapper-locations</span>=<span class=\"string\">classpath:mapper/*.xml</span></span><br></pre></td></tr></table></figure>\n\n<p>本地product配置：</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">spring.application.name</span>=<span class=\"string\">productService</span></span><br><span class=\"line\"><span class=\"attr\">eureka.client.service-url.defaultZone</span>=<span class=\"string\">http://localhost:8764/eureka/</span></span><br><span class=\"line\"><span class=\"attr\">spring.cloud.config.discovery.enabled</span>=<span class=\"string\">true</span></span><br><span class=\"line\"><span class=\"attr\">spring.cloud.config.discovery.service-id</span>=<span class=\"string\">CONFIGCENTER</span></span><br><span class=\"line\"><span class=\"attr\">spring.cloud.config.profile</span>=<span class=\"string\">dev</span></span><br><span class=\"line\"><span class=\"attr\">spring.config.import</span>=<span class=\"string\">configserver:http://localhost:8096</span></span><br></pre></td></tr></table></figure>\n\n<p>上述8096端口有配置中心服务在监听：</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">server.port</span>=<span class=\"string\">8096</span></span><br><span class=\"line\"><span class=\"attr\">spring.application.name</span>=<span class=\"string\">configCenter</span></span><br><span class=\"line\"><span class=\"attr\">eureka.client.service-url.defaultZone</span>=<span class=\"string\">http://localhost:8764/eureka/</span></span><br><span class=\"line\"><span class=\"attr\">spring.cloud.config.server.git.uri</span>=<span class=\"string\">https://github.com/StaveWu/config-repository.git</span></span><br><span class=\"line\"><span class=\"attr\">spring.cloud.config.server.git.username</span>=<span class=\"string\">stavewu</span></span><br><span class=\"line\"><span class=\"attr\">spring.cloud.config.server.git.password</span>=<span class=\"string\">******</span></span><br></pre></td></tr></table></figure>\n\n<p>配置中心服务主要用到了spring cloud config组件Config Server，注解：<code>@EnableConfigServer</code></p>\n<p>product使用的是Config Client，无需注解。</p>\n<p>这样就形成了一条从<code>product -&gt; config server:8096 -&gt; github/config-repository</code>的通路。</p>\n<p>config-repository里有好几个配置文件，product服务怎么知道要拿哪一个？</p>\n<p>这里猜测是一种约定：基于spring.appliction.name + spring.cloud.config.profile命名的配置文件将被读取，product服务对应到productService-dev.properties。</p>\n<p>2、mybatis效果：</p>\n<p>在product配置文件里，通过<code>mybatis.mapper-locations=classpath:mapper/*.xml</code>读取到位于resources&#x2F;mapper下的配置文件；通过<code>spring.datasource.url=jdbc:mysql://127.0.0.1:3306/experiment?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false</code>连接到名为experiment的数据库实例，与配置文件配合形成数据库数据读取加载。</p>"}],"PostAsset":[],"PostCategory":[{"post_id":"clvp3gtdz00000cpvdnfwfgc0","category_id":"clzzb0ro10006lnp7d4vk14y1","_id":"clzzb0ro20007lnp79rh1asmn"},{"post_id":"clzzb01y40003lnp758cq3wlv","category_id":"clzzb110b0008lnp7494me4g2","_id":"clzzb110d0009lnp7eqaw5qgc"},{"post_id":"clzzazpbh0000lnp76urd4qng","category_id":"clzzb1pvj000alnp781ct728p","_id":"clzzb47u3000nlnp79xg9eyxt"},{"post_id":"clvp3gte100010cpv9w2j4864","category_id":"clzzb1pvj000alnp781ct728p","_id":"clzzb4esg000olnp766gf97d3"},{"post_id":"cm0i903jz0002cfp7gjs69v4b","category_id":"cm0i910800004cfp7evcb928w","_id":"cm0i910800005cfp71een5aq9"},{"post_id":"cm0i8sb9k0000cfp77v8c6458","category_id":"cm0i9awlu0001a4p727wj82ku","_id":"cm0i9awlv0003a4p7bu2u58ht"}],"PostTag":[{"post_id":"clzzb01y40003lnp758cq3wlv","tag_id":"clzzb2hq7000flnp784blftiu","_id":"clzzb2hq7000glnp7hbj6bgkw"},{"post_id":"clvp3gtdz00000cpvdnfwfgc0","tag_id":"clzzb3gpg000jlnp76qlw46c1","_id":"clzzb3gpg000klnp7b0h8c41d"},{"post_id":"clvp3gte100010cpv9w2j4864","tag_id":"clzzb3gpg000jlnp76qlw46c1","_id":"clzzb3p78000llnp7bfi73asb"},{"post_id":"clzzazpbh0000lnp76urd4qng","tag_id":"clzzb3gpg000jlnp76qlw46c1","_id":"clzzb3ujq000mlnp70cincpcy"},{"post_id":"cm0i903jz0002cfp7gjs69v4b","tag_id":"cm0i9awlt0000a4p74aqm0kag","_id":"cm0i9awlv0002a4p788k4g3lo"}],"Tag":[{"name":"jekyll","_id":"clvow0nau0006adpvhbioalii"},{"name":"兼容性","_id":"clvow0naz000cadpv3gbteyg0"},{"name":"底软原理","_id":"clxhoiuc60002ktp7866shhiv"},{"name":"底层软件","_id":"clzzb2hq7000flnp784blftiu"},{"name":"生态","_id":"clzzb3dz5000hlnp7glzp7hmq"},{"name":"软件生态","_id":"clzzb3gpg000jlnp76qlw46c1"},{"name":"虚拟化","_id":"cm0i9awlt0000a4p74aqm0kag"}]}}